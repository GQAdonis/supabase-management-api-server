// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"tribemedia.io/m/ent/authconfig"
	"tribemedia.io/m/ent/branch"
	"tribemedia.io/m/ent/customhostname"
	"tribemedia.io/m/ent/function"
	"tribemedia.io/m/ent/networkban"
	"tribemedia.io/m/ent/organization"
	"tribemedia.io/m/ent/pgsodiumconfig"
	"tribemedia.io/m/ent/predicate"
	"tribemedia.io/m/ent/project"
	"tribemedia.io/m/ent/provider"
	"tribemedia.io/m/ent/secret"
	"tribemedia.io/m/ent/thirdpartyauth"
	"tribemedia.io/m/ent/typescripttype"
	api "tribemedia.io/m/supabase"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAuthConfig     = "AuthConfig"
	TypeBranch         = "Branch"
	TypeCustomHostname = "CustomHostname"
	TypeFunction       = "Function"
	TypeNetworkBan     = "NetworkBan"
	TypeOrganization   = "Organization"
	TypePgsodiumConfig = "PgsodiumConfig"
	TypeProject        = "Project"
	TypeProvider       = "Provider"
	TypeSecret         = "Secret"
	TypeThirdPartyAuth = "ThirdPartyAuth"
	TypeTypeScriptType = "TypeScriptType"
	TypeUser           = "User"
)

// AuthConfigMutation represents an operation that mutates the AuthConfig nodes in the graph.
type AuthConfigMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	disable_signup         *bool
	external_email_enabled *bool
	clearedFields          map[string]struct{}
	project                *uuid.UUID
	clearedproject         bool
	done                   bool
	oldValue               func(context.Context) (*AuthConfig, error)
	predicates             []predicate.AuthConfig
}

var _ ent.Mutation = (*AuthConfigMutation)(nil)

// authconfigOption allows management of the mutation configuration using functional options.
type authconfigOption func(*AuthConfigMutation)

// newAuthConfigMutation creates new mutation for the AuthConfig entity.
func newAuthConfigMutation(c config, op Op, opts ...authconfigOption) *AuthConfigMutation {
	m := &AuthConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthConfigID sets the ID field of the mutation.
func withAuthConfigID(id uuid.UUID) authconfigOption {
	return func(m *AuthConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthConfig
		)
		m.oldValue = func(ctx context.Context) (*AuthConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthConfig sets the old AuthConfig of the mutation.
func withAuthConfig(node *AuthConfig) authconfigOption {
	return func(m *AuthConfigMutation) {
		m.oldValue = func(context.Context) (*AuthConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthConfig entities.
func (m *AuthConfigMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthConfigMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthConfigMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDisableSignup sets the "disable_signup" field.
func (m *AuthConfigMutation) SetDisableSignup(b bool) {
	m.disable_signup = &b
}

// DisableSignup returns the value of the "disable_signup" field in the mutation.
func (m *AuthConfigMutation) DisableSignup() (r bool, exists bool) {
	v := m.disable_signup
	if v == nil {
		return
	}
	return *v, true
}

// OldDisableSignup returns the old "disable_signup" field's value of the AuthConfig entity.
// If the AuthConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthConfigMutation) OldDisableSignup(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisableSignup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisableSignup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisableSignup: %w", err)
	}
	return oldValue.DisableSignup, nil
}

// ResetDisableSignup resets all changes to the "disable_signup" field.
func (m *AuthConfigMutation) ResetDisableSignup() {
	m.disable_signup = nil
}

// SetExternalEmailEnabled sets the "external_email_enabled" field.
func (m *AuthConfigMutation) SetExternalEmailEnabled(b bool) {
	m.external_email_enabled = &b
}

// ExternalEmailEnabled returns the value of the "external_email_enabled" field in the mutation.
func (m *AuthConfigMutation) ExternalEmailEnabled() (r bool, exists bool) {
	v := m.external_email_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalEmailEnabled returns the old "external_email_enabled" field's value of the AuthConfig entity.
// If the AuthConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthConfigMutation) OldExternalEmailEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalEmailEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalEmailEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalEmailEnabled: %w", err)
	}
	return oldValue.ExternalEmailEnabled, nil
}

// ResetExternalEmailEnabled resets all changes to the "external_email_enabled" field.
func (m *AuthConfigMutation) ResetExternalEmailEnabled() {
	m.external_email_enabled = nil
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *AuthConfigMutation) SetProjectID(id uuid.UUID) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *AuthConfigMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *AuthConfigMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *AuthConfigMutation) ProjectID() (id uuid.UUID, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *AuthConfigMutation) ProjectIDs() (ids []uuid.UUID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *AuthConfigMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// Where appends a list predicates to the AuthConfigMutation builder.
func (m *AuthConfigMutation) Where(ps ...predicate.AuthConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuthConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuthConfig).
func (m *AuthConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthConfigMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.disable_signup != nil {
		fields = append(fields, authconfig.FieldDisableSignup)
	}
	if m.external_email_enabled != nil {
		fields = append(fields, authconfig.FieldExternalEmailEnabled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authconfig.FieldDisableSignup:
		return m.DisableSignup()
	case authconfig.FieldExternalEmailEnabled:
		return m.ExternalEmailEnabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authconfig.FieldDisableSignup:
		return m.OldDisableSignup(ctx)
	case authconfig.FieldExternalEmailEnabled:
		return m.OldExternalEmailEnabled(ctx)
	}
	return nil, fmt.Errorf("unknown AuthConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authconfig.FieldDisableSignup:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisableSignup(v)
		return nil
	case authconfig.FieldExternalEmailEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalEmailEnabled(v)
		return nil
	}
	return fmt.Errorf("unknown AuthConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthConfigMutation) ResetField(name string) error {
	switch name {
	case authconfig.FieldDisableSignup:
		m.ResetDisableSignup()
		return nil
	case authconfig.FieldExternalEmailEnabled:
		m.ResetExternalEmailEnabled()
		return nil
	}
	return fmt.Errorf("unknown AuthConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.project != nil {
		edges = append(edges, authconfig.EdgeProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case authconfig.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproject {
		edges = append(edges, authconfig.EdgeProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case authconfig.EdgeProject:
		return m.clearedproject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthConfigMutation) ClearEdge(name string) error {
	switch name {
	case authconfig.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown AuthConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthConfigMutation) ResetEdge(name string) error {
	switch name {
	case authconfig.EdgeProject:
		m.ResetProject()
		return nil
	}
	return fmt.Errorf("unknown AuthConfig edge %s", name)
}

// BranchMutation represents an operation that mutates the Branch nodes in the graph.
type BranchMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	name                 *string
	clearedFields        map[string]struct{}
	project              *uuid.UUID
	clearedproject       bool
	parentProject        *uuid.UUID
	clearedparentProject bool
	done                 bool
	oldValue             func(context.Context) (*Branch, error)
	predicates           []predicate.Branch
}

var _ ent.Mutation = (*BranchMutation)(nil)

// branchOption allows management of the mutation configuration using functional options.
type branchOption func(*BranchMutation)

// newBranchMutation creates new mutation for the Branch entity.
func newBranchMutation(c config, op Op, opts ...branchOption) *BranchMutation {
	m := &BranchMutation{
		config:        c,
		op:            op,
		typ:           TypeBranch,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBranchID sets the ID field of the mutation.
func withBranchID(id uuid.UUID) branchOption {
	return func(m *BranchMutation) {
		var (
			err   error
			once  sync.Once
			value *Branch
		)
		m.oldValue = func(ctx context.Context) (*Branch, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Branch.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBranch sets the old Branch of the mutation.
func withBranch(node *Branch) branchOption {
	return func(m *BranchMutation) {
		m.oldValue = func(context.Context) (*Branch, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BranchMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BranchMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Branch entities.
func (m *BranchMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BranchMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BranchMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Branch.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *BranchMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BranchMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BranchMutation) ResetName() {
	m.name = nil
}

// SetProjectRef sets the "project_ref" field.
func (m *BranchMutation) SetProjectRef(u uuid.UUID) {
	m.project = &u
}

// ProjectRef returns the value of the "project_ref" field in the mutation.
func (m *BranchMutation) ProjectRef() (r uuid.UUID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectRef returns the old "project_ref" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldProjectRef(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectRef: %w", err)
	}
	return oldValue.ProjectRef, nil
}

// ClearProjectRef clears the value of the "project_ref" field.
func (m *BranchMutation) ClearProjectRef() {
	m.project = nil
	m.clearedFields[branch.FieldProjectRef] = struct{}{}
}

// ProjectRefCleared returns if the "project_ref" field was cleared in this mutation.
func (m *BranchMutation) ProjectRefCleared() bool {
	_, ok := m.clearedFields[branch.FieldProjectRef]
	return ok
}

// ResetProjectRef resets all changes to the "project_ref" field.
func (m *BranchMutation) ResetProjectRef() {
	m.project = nil
	delete(m.clearedFields, branch.FieldProjectRef)
}

// SetParentProjectRef sets the "parent_project_ref" field.
func (m *BranchMutation) SetParentProjectRef(u uuid.UUID) {
	m.parentProject = &u
}

// ParentProjectRef returns the value of the "parent_project_ref" field in the mutation.
func (m *BranchMutation) ParentProjectRef() (r uuid.UUID, exists bool) {
	v := m.parentProject
	if v == nil {
		return
	}
	return *v, true
}

// OldParentProjectRef returns the old "parent_project_ref" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldParentProjectRef(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentProjectRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentProjectRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentProjectRef: %w", err)
	}
	return oldValue.ParentProjectRef, nil
}

// ClearParentProjectRef clears the value of the "parent_project_ref" field.
func (m *BranchMutation) ClearParentProjectRef() {
	m.parentProject = nil
	m.clearedFields[branch.FieldParentProjectRef] = struct{}{}
}

// ParentProjectRefCleared returns if the "parent_project_ref" field was cleared in this mutation.
func (m *BranchMutation) ParentProjectRefCleared() bool {
	_, ok := m.clearedFields[branch.FieldParentProjectRef]
	return ok
}

// ResetParentProjectRef resets all changes to the "parent_project_ref" field.
func (m *BranchMutation) ResetParentProjectRef() {
	m.parentProject = nil
	delete(m.clearedFields, branch.FieldParentProjectRef)
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *BranchMutation) SetProjectID(id uuid.UUID) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *BranchMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[branch.FieldProjectRef] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *BranchMutation) ProjectCleared() bool {
	return m.ProjectRefCleared() || m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *BranchMutation) ProjectID() (id uuid.UUID, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *BranchMutation) ProjectIDs() (ids []uuid.UUID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *BranchMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// SetParentProjectID sets the "parentProject" edge to the Project entity by id.
func (m *BranchMutation) SetParentProjectID(id uuid.UUID) {
	m.parentProject = &id
}

// ClearParentProject clears the "parentProject" edge to the Project entity.
func (m *BranchMutation) ClearParentProject() {
	m.clearedparentProject = true
	m.clearedFields[branch.FieldParentProjectRef] = struct{}{}
}

// ParentProjectCleared reports if the "parentProject" edge to the Project entity was cleared.
func (m *BranchMutation) ParentProjectCleared() bool {
	return m.ParentProjectRefCleared() || m.clearedparentProject
}

// ParentProjectID returns the "parentProject" edge ID in the mutation.
func (m *BranchMutation) ParentProjectID() (id uuid.UUID, exists bool) {
	if m.parentProject != nil {
		return *m.parentProject, true
	}
	return
}

// ParentProjectIDs returns the "parentProject" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentProjectID instead. It exists only for internal usage by the builders.
func (m *BranchMutation) ParentProjectIDs() (ids []uuid.UUID) {
	if id := m.parentProject; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentProject resets all changes to the "parentProject" edge.
func (m *BranchMutation) ResetParentProject() {
	m.parentProject = nil
	m.clearedparentProject = false
}

// Where appends a list predicates to the BranchMutation builder.
func (m *BranchMutation) Where(ps ...predicate.Branch) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BranchMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BranchMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Branch, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BranchMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BranchMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Branch).
func (m *BranchMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BranchMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, branch.FieldName)
	}
	if m.project != nil {
		fields = append(fields, branch.FieldProjectRef)
	}
	if m.parentProject != nil {
		fields = append(fields, branch.FieldParentProjectRef)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BranchMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case branch.FieldName:
		return m.Name()
	case branch.FieldProjectRef:
		return m.ProjectRef()
	case branch.FieldParentProjectRef:
		return m.ParentProjectRef()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BranchMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case branch.FieldName:
		return m.OldName(ctx)
	case branch.FieldProjectRef:
		return m.OldProjectRef(ctx)
	case branch.FieldParentProjectRef:
		return m.OldParentProjectRef(ctx)
	}
	return nil, fmt.Errorf("unknown Branch field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BranchMutation) SetField(name string, value ent.Value) error {
	switch name {
	case branch.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case branch.FieldProjectRef:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectRef(v)
		return nil
	case branch.FieldParentProjectRef:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentProjectRef(v)
		return nil
	}
	return fmt.Errorf("unknown Branch field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BranchMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BranchMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BranchMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Branch numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BranchMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(branch.FieldProjectRef) {
		fields = append(fields, branch.FieldProjectRef)
	}
	if m.FieldCleared(branch.FieldParentProjectRef) {
		fields = append(fields, branch.FieldParentProjectRef)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BranchMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BranchMutation) ClearField(name string) error {
	switch name {
	case branch.FieldProjectRef:
		m.ClearProjectRef()
		return nil
	case branch.FieldParentProjectRef:
		m.ClearParentProjectRef()
		return nil
	}
	return fmt.Errorf("unknown Branch nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BranchMutation) ResetField(name string) error {
	switch name {
	case branch.FieldName:
		m.ResetName()
		return nil
	case branch.FieldProjectRef:
		m.ResetProjectRef()
		return nil
	case branch.FieldParentProjectRef:
		m.ResetParentProjectRef()
		return nil
	}
	return fmt.Errorf("unknown Branch field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BranchMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.project != nil {
		edges = append(edges, branch.EdgeProject)
	}
	if m.parentProject != nil {
		edges = append(edges, branch.EdgeParentProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BranchMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case branch.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case branch.EdgeParentProject:
		if id := m.parentProject; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BranchMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BranchMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BranchMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproject {
		edges = append(edges, branch.EdgeProject)
	}
	if m.clearedparentProject {
		edges = append(edges, branch.EdgeParentProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BranchMutation) EdgeCleared(name string) bool {
	switch name {
	case branch.EdgeProject:
		return m.clearedproject
	case branch.EdgeParentProject:
		return m.clearedparentProject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BranchMutation) ClearEdge(name string) error {
	switch name {
	case branch.EdgeProject:
		m.ClearProject()
		return nil
	case branch.EdgeParentProject:
		m.ClearParentProject()
		return nil
	}
	return fmt.Errorf("unknown Branch unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BranchMutation) ResetEdge(name string) error {
	switch name {
	case branch.EdgeProject:
		m.ResetProject()
		return nil
	case branch.EdgeParentProject:
		m.ResetParentProject()
		return nil
	}
	return fmt.Errorf("unknown Branch edge %s", name)
}

// CustomHostnameMutation represents an operation that mutates the CustomHostname nodes in the graph.
type CustomHostnameMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	hostname       *string
	ssl_status     *string
	clearedFields  map[string]struct{}
	project        *uuid.UUID
	clearedproject bool
	done           bool
	oldValue       func(context.Context) (*CustomHostname, error)
	predicates     []predicate.CustomHostname
}

var _ ent.Mutation = (*CustomHostnameMutation)(nil)

// customhostnameOption allows management of the mutation configuration using functional options.
type customhostnameOption func(*CustomHostnameMutation)

// newCustomHostnameMutation creates new mutation for the CustomHostname entity.
func newCustomHostnameMutation(c config, op Op, opts ...customhostnameOption) *CustomHostnameMutation {
	m := &CustomHostnameMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomHostname,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomHostnameID sets the ID field of the mutation.
func withCustomHostnameID(id uuid.UUID) customhostnameOption {
	return func(m *CustomHostnameMutation) {
		var (
			err   error
			once  sync.Once
			value *CustomHostname
		)
		m.oldValue = func(ctx context.Context) (*CustomHostname, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CustomHostname.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomHostname sets the old CustomHostname of the mutation.
func withCustomHostname(node *CustomHostname) customhostnameOption {
	return func(m *CustomHostnameMutation) {
		m.oldValue = func(context.Context) (*CustomHostname, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomHostnameMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomHostnameMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CustomHostname entities.
func (m *CustomHostnameMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomHostnameMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomHostnameMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CustomHostname.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProjectID sets the "project_id" field.
func (m *CustomHostnameMutation) SetProjectID(u uuid.UUID) {
	m.project = &u
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *CustomHostnameMutation) ProjectID() (r uuid.UUID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the CustomHostname entity.
// If the CustomHostname object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomHostnameMutation) OldProjectID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *CustomHostnameMutation) ResetProjectID() {
	m.project = nil
}

// SetHostname sets the "hostname" field.
func (m *CustomHostnameMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the value of the "hostname" field in the mutation.
func (m *CustomHostnameMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "hostname" field's value of the CustomHostname entity.
// If the CustomHostname object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomHostnameMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ResetHostname resets all changes to the "hostname" field.
func (m *CustomHostnameMutation) ResetHostname() {
	m.hostname = nil
}

// SetSslStatus sets the "ssl_status" field.
func (m *CustomHostnameMutation) SetSslStatus(s string) {
	m.ssl_status = &s
}

// SslStatus returns the value of the "ssl_status" field in the mutation.
func (m *CustomHostnameMutation) SslStatus() (r string, exists bool) {
	v := m.ssl_status
	if v == nil {
		return
	}
	return *v, true
}

// OldSslStatus returns the old "ssl_status" field's value of the CustomHostname entity.
// If the CustomHostname object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomHostnameMutation) OldSslStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSslStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSslStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSslStatus: %w", err)
	}
	return oldValue.SslStatus, nil
}

// ResetSslStatus resets all changes to the "ssl_status" field.
func (m *CustomHostnameMutation) ResetSslStatus() {
	m.ssl_status = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *CustomHostnameMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[customhostname.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *CustomHostnameMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *CustomHostnameMutation) ProjectIDs() (ids []uuid.UUID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *CustomHostnameMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// Where appends a list predicates to the CustomHostnameMutation builder.
func (m *CustomHostnameMutation) Where(ps ...predicate.CustomHostname) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomHostnameMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomHostnameMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CustomHostname, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomHostnameMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomHostnameMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CustomHostname).
func (m *CustomHostnameMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomHostnameMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.project != nil {
		fields = append(fields, customhostname.FieldProjectID)
	}
	if m.hostname != nil {
		fields = append(fields, customhostname.FieldHostname)
	}
	if m.ssl_status != nil {
		fields = append(fields, customhostname.FieldSslStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomHostnameMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customhostname.FieldProjectID:
		return m.ProjectID()
	case customhostname.FieldHostname:
		return m.Hostname()
	case customhostname.FieldSslStatus:
		return m.SslStatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomHostnameMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customhostname.FieldProjectID:
		return m.OldProjectID(ctx)
	case customhostname.FieldHostname:
		return m.OldHostname(ctx)
	case customhostname.FieldSslStatus:
		return m.OldSslStatus(ctx)
	}
	return nil, fmt.Errorf("unknown CustomHostname field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomHostnameMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customhostname.FieldProjectID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case customhostname.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case customhostname.FieldSslStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSslStatus(v)
		return nil
	}
	return fmt.Errorf("unknown CustomHostname field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomHostnameMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomHostnameMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomHostnameMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CustomHostname numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomHostnameMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomHostnameMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomHostnameMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CustomHostname nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomHostnameMutation) ResetField(name string) error {
	switch name {
	case customhostname.FieldProjectID:
		m.ResetProjectID()
		return nil
	case customhostname.FieldHostname:
		m.ResetHostname()
		return nil
	case customhostname.FieldSslStatus:
		m.ResetSslStatus()
		return nil
	}
	return fmt.Errorf("unknown CustomHostname field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomHostnameMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.project != nil {
		edges = append(edges, customhostname.EdgeProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomHostnameMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customhostname.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomHostnameMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomHostnameMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomHostnameMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproject {
		edges = append(edges, customhostname.EdgeProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomHostnameMutation) EdgeCleared(name string) bool {
	switch name {
	case customhostname.EdgeProject:
		return m.clearedproject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomHostnameMutation) ClearEdge(name string) error {
	switch name {
	case customhostname.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown CustomHostname unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomHostnameMutation) ResetEdge(name string) error {
	switch name {
	case customhostname.EdgeProject:
		m.ResetProject()
		return nil
	}
	return fmt.Errorf("unknown CustomHostname edge %s", name)
}

// FunctionMutation represents an operation that mutates the Function nodes in the graph.
type FunctionMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	name           *string
	runtime        *string
	source_code    *string
	clearedFields  map[string]struct{}
	project        *uuid.UUID
	clearedproject bool
	done           bool
	oldValue       func(context.Context) (*Function, error)
	predicates     []predicate.Function
}

var _ ent.Mutation = (*FunctionMutation)(nil)

// functionOption allows management of the mutation configuration using functional options.
type functionOption func(*FunctionMutation)

// newFunctionMutation creates new mutation for the Function entity.
func newFunctionMutation(c config, op Op, opts ...functionOption) *FunctionMutation {
	m := &FunctionMutation{
		config:        c,
		op:            op,
		typ:           TypeFunction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFunctionID sets the ID field of the mutation.
func withFunctionID(id uuid.UUID) functionOption {
	return func(m *FunctionMutation) {
		var (
			err   error
			once  sync.Once
			value *Function
		)
		m.oldValue = func(ctx context.Context) (*Function, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Function.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFunction sets the old Function of the mutation.
func withFunction(node *Function) functionOption {
	return func(m *FunctionMutation) {
		m.oldValue = func(context.Context) (*Function, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FunctionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FunctionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Function entities.
func (m *FunctionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FunctionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FunctionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Function.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProjectID sets the "project_id" field.
func (m *FunctionMutation) SetProjectID(u uuid.UUID) {
	m.project = &u
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *FunctionMutation) ProjectID() (r uuid.UUID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Function entity.
// If the Function object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FunctionMutation) OldProjectID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *FunctionMutation) ResetProjectID() {
	m.project = nil
}

// SetName sets the "name" field.
func (m *FunctionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FunctionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Function entity.
// If the Function object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FunctionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FunctionMutation) ResetName() {
	m.name = nil
}

// SetRuntime sets the "runtime" field.
func (m *FunctionMutation) SetRuntime(s string) {
	m.runtime = &s
}

// Runtime returns the value of the "runtime" field in the mutation.
func (m *FunctionMutation) Runtime() (r string, exists bool) {
	v := m.runtime
	if v == nil {
		return
	}
	return *v, true
}

// OldRuntime returns the old "runtime" field's value of the Function entity.
// If the Function object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FunctionMutation) OldRuntime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRuntime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRuntime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuntime: %w", err)
	}
	return oldValue.Runtime, nil
}

// ResetRuntime resets all changes to the "runtime" field.
func (m *FunctionMutation) ResetRuntime() {
	m.runtime = nil
}

// SetSourceCode sets the "source_code" field.
func (m *FunctionMutation) SetSourceCode(s string) {
	m.source_code = &s
}

// SourceCode returns the value of the "source_code" field in the mutation.
func (m *FunctionMutation) SourceCode() (r string, exists bool) {
	v := m.source_code
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceCode returns the old "source_code" field's value of the Function entity.
// If the Function object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FunctionMutation) OldSourceCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceCode: %w", err)
	}
	return oldValue.SourceCode, nil
}

// ResetSourceCode resets all changes to the "source_code" field.
func (m *FunctionMutation) ResetSourceCode() {
	m.source_code = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *FunctionMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[function.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *FunctionMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *FunctionMutation) ProjectIDs() (ids []uuid.UUID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *FunctionMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// Where appends a list predicates to the FunctionMutation builder.
func (m *FunctionMutation) Where(ps ...predicate.Function) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FunctionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FunctionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Function, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FunctionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FunctionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Function).
func (m *FunctionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FunctionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.project != nil {
		fields = append(fields, function.FieldProjectID)
	}
	if m.name != nil {
		fields = append(fields, function.FieldName)
	}
	if m.runtime != nil {
		fields = append(fields, function.FieldRuntime)
	}
	if m.source_code != nil {
		fields = append(fields, function.FieldSourceCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FunctionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case function.FieldProjectID:
		return m.ProjectID()
	case function.FieldName:
		return m.Name()
	case function.FieldRuntime:
		return m.Runtime()
	case function.FieldSourceCode:
		return m.SourceCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FunctionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case function.FieldProjectID:
		return m.OldProjectID(ctx)
	case function.FieldName:
		return m.OldName(ctx)
	case function.FieldRuntime:
		return m.OldRuntime(ctx)
	case function.FieldSourceCode:
		return m.OldSourceCode(ctx)
	}
	return nil, fmt.Errorf("unknown Function field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FunctionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case function.FieldProjectID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case function.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case function.FieldRuntime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuntime(v)
		return nil
	case function.FieldSourceCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceCode(v)
		return nil
	}
	return fmt.Errorf("unknown Function field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FunctionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FunctionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FunctionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Function numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FunctionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FunctionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FunctionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Function nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FunctionMutation) ResetField(name string) error {
	switch name {
	case function.FieldProjectID:
		m.ResetProjectID()
		return nil
	case function.FieldName:
		m.ResetName()
		return nil
	case function.FieldRuntime:
		m.ResetRuntime()
		return nil
	case function.FieldSourceCode:
		m.ResetSourceCode()
		return nil
	}
	return fmt.Errorf("unknown Function field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FunctionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.project != nil {
		edges = append(edges, function.EdgeProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FunctionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case function.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FunctionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FunctionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FunctionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproject {
		edges = append(edges, function.EdgeProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FunctionMutation) EdgeCleared(name string) bool {
	switch name {
	case function.EdgeProject:
		return m.clearedproject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FunctionMutation) ClearEdge(name string) error {
	switch name {
	case function.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown Function unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FunctionMutation) ResetEdge(name string) error {
	switch name {
	case function.EdgeProject:
		m.ResetProject()
		return nil
	}
	return fmt.Errorf("unknown Function edge %s", name)
}

// NetworkBanMutation represents an operation that mutates the NetworkBan nodes in the graph.
type NetworkBanMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	ip_address     *string
	reason         *string
	created_at     *time.Time
	clearedFields  map[string]struct{}
	project        *uuid.UUID
	clearedproject bool
	done           bool
	oldValue       func(context.Context) (*NetworkBan, error)
	predicates     []predicate.NetworkBan
}

var _ ent.Mutation = (*NetworkBanMutation)(nil)

// networkbanOption allows management of the mutation configuration using functional options.
type networkbanOption func(*NetworkBanMutation)

// newNetworkBanMutation creates new mutation for the NetworkBan entity.
func newNetworkBanMutation(c config, op Op, opts ...networkbanOption) *NetworkBanMutation {
	m := &NetworkBanMutation{
		config:        c,
		op:            op,
		typ:           TypeNetworkBan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNetworkBanID sets the ID field of the mutation.
func withNetworkBanID(id uuid.UUID) networkbanOption {
	return func(m *NetworkBanMutation) {
		var (
			err   error
			once  sync.Once
			value *NetworkBan
		)
		m.oldValue = func(ctx context.Context) (*NetworkBan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NetworkBan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNetworkBan sets the old NetworkBan of the mutation.
func withNetworkBan(node *NetworkBan) networkbanOption {
	return func(m *NetworkBanMutation) {
		m.oldValue = func(context.Context) (*NetworkBan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NetworkBanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NetworkBanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NetworkBan entities.
func (m *NetworkBanMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NetworkBanMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NetworkBanMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NetworkBan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProjectID sets the "project_id" field.
func (m *NetworkBanMutation) SetProjectID(u uuid.UUID) {
	m.project = &u
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *NetworkBanMutation) ProjectID() (r uuid.UUID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the NetworkBan entity.
// If the NetworkBan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkBanMutation) OldProjectID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *NetworkBanMutation) ResetProjectID() {
	m.project = nil
}

// SetIPAddress sets the "ip_address" field.
func (m *NetworkBanMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *NetworkBanMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the NetworkBan entity.
// If the NetworkBan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkBanMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *NetworkBanMutation) ResetIPAddress() {
	m.ip_address = nil
}

// SetReason sets the "reason" field.
func (m *NetworkBanMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *NetworkBanMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the NetworkBan entity.
// If the NetworkBan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkBanMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *NetworkBanMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[networkban.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *NetworkBanMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[networkban.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *NetworkBanMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, networkban.FieldReason)
}

// SetCreatedAt sets the "created_at" field.
func (m *NetworkBanMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NetworkBanMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NetworkBan entity.
// If the NetworkBan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkBanMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NetworkBanMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *NetworkBanMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[networkban.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *NetworkBanMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *NetworkBanMutation) ProjectIDs() (ids []uuid.UUID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *NetworkBanMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// Where appends a list predicates to the NetworkBanMutation builder.
func (m *NetworkBanMutation) Where(ps ...predicate.NetworkBan) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NetworkBanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NetworkBanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NetworkBan, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NetworkBanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NetworkBanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NetworkBan).
func (m *NetworkBanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NetworkBanMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.project != nil {
		fields = append(fields, networkban.FieldProjectID)
	}
	if m.ip_address != nil {
		fields = append(fields, networkban.FieldIPAddress)
	}
	if m.reason != nil {
		fields = append(fields, networkban.FieldReason)
	}
	if m.created_at != nil {
		fields = append(fields, networkban.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NetworkBanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case networkban.FieldProjectID:
		return m.ProjectID()
	case networkban.FieldIPAddress:
		return m.IPAddress()
	case networkban.FieldReason:
		return m.Reason()
	case networkban.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NetworkBanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case networkban.FieldProjectID:
		return m.OldProjectID(ctx)
	case networkban.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case networkban.FieldReason:
		return m.OldReason(ctx)
	case networkban.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NetworkBan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkBanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case networkban.FieldProjectID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case networkban.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case networkban.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case networkban.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NetworkBan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NetworkBanMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NetworkBanMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkBanMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NetworkBan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NetworkBanMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(networkban.FieldReason) {
		fields = append(fields, networkban.FieldReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NetworkBanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NetworkBanMutation) ClearField(name string) error {
	switch name {
	case networkban.FieldReason:
		m.ClearReason()
		return nil
	}
	return fmt.Errorf("unknown NetworkBan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NetworkBanMutation) ResetField(name string) error {
	switch name {
	case networkban.FieldProjectID:
		m.ResetProjectID()
		return nil
	case networkban.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case networkban.FieldReason:
		m.ResetReason()
		return nil
	case networkban.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown NetworkBan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NetworkBanMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.project != nil {
		edges = append(edges, networkban.EdgeProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NetworkBanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case networkban.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NetworkBanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NetworkBanMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NetworkBanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproject {
		edges = append(edges, networkban.EdgeProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NetworkBanMutation) EdgeCleared(name string) bool {
	switch name {
	case networkban.EdgeProject:
		return m.clearedproject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NetworkBanMutation) ClearEdge(name string) error {
	switch name {
	case networkban.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown NetworkBan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NetworkBanMutation) ResetEdge(name string) error {
	switch name {
	case networkban.EdgeProject:
		m.ResetProject()
		return nil
	}
	return fmt.Errorf("unknown NetworkBan edge %s", name)
}

// OrganizationMutation represents an operation that mutates the Organization nodes in the graph.
type OrganizationMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	name                     *string
	clearedFields            map[string]struct{}
	providers                map[int]struct{}
	removedproviders         map[int]struct{}
	clearedproviders         bool
	third_party_auths        map[int]struct{}
	removedthird_party_auths map[int]struct{}
	clearedthird_party_auths bool
	done                     bool
	oldValue                 func(context.Context) (*Organization, error)
	predicates               []predicate.Organization
}

var _ ent.Mutation = (*OrganizationMutation)(nil)

// organizationOption allows management of the mutation configuration using functional options.
type organizationOption func(*OrganizationMutation)

// newOrganizationMutation creates new mutation for the Organization entity.
func newOrganizationMutation(c config, op Op, opts ...organizationOption) *OrganizationMutation {
	m := &OrganizationMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationID sets the ID field of the mutation.
func withOrganizationID(id int) organizationOption {
	return func(m *OrganizationMutation) {
		var (
			err   error
			once  sync.Once
			value *Organization
		)
		m.oldValue = func(ctx context.Context) (*Organization, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Organization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganization sets the old Organization of the mutation.
func withOrganization(node *Organization) organizationOption {
	return func(m *OrganizationMutation) {
		m.oldValue = func(context.Context) (*Organization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Organization.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *OrganizationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationMutation) ResetName() {
	m.name = nil
}

// AddProviderIDs adds the "providers" edge to the Provider entity by ids.
func (m *OrganizationMutation) AddProviderIDs(ids ...int) {
	if m.providers == nil {
		m.providers = make(map[int]struct{})
	}
	for i := range ids {
		m.providers[ids[i]] = struct{}{}
	}
}

// ClearProviders clears the "providers" edge to the Provider entity.
func (m *OrganizationMutation) ClearProviders() {
	m.clearedproviders = true
}

// ProvidersCleared reports if the "providers" edge to the Provider entity was cleared.
func (m *OrganizationMutation) ProvidersCleared() bool {
	return m.clearedproviders
}

// RemoveProviderIDs removes the "providers" edge to the Provider entity by IDs.
func (m *OrganizationMutation) RemoveProviderIDs(ids ...int) {
	if m.removedproviders == nil {
		m.removedproviders = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.providers, ids[i])
		m.removedproviders[ids[i]] = struct{}{}
	}
}

// RemovedProviders returns the removed IDs of the "providers" edge to the Provider entity.
func (m *OrganizationMutation) RemovedProvidersIDs() (ids []int) {
	for id := range m.removedproviders {
		ids = append(ids, id)
	}
	return
}

// ProvidersIDs returns the "providers" edge IDs in the mutation.
func (m *OrganizationMutation) ProvidersIDs() (ids []int) {
	for id := range m.providers {
		ids = append(ids, id)
	}
	return
}

// ResetProviders resets all changes to the "providers" edge.
func (m *OrganizationMutation) ResetProviders() {
	m.providers = nil
	m.clearedproviders = false
	m.removedproviders = nil
}

// AddThirdPartyAuthIDs adds the "third_party_auths" edge to the ThirdPartyAuth entity by ids.
func (m *OrganizationMutation) AddThirdPartyAuthIDs(ids ...int) {
	if m.third_party_auths == nil {
		m.third_party_auths = make(map[int]struct{})
	}
	for i := range ids {
		m.third_party_auths[ids[i]] = struct{}{}
	}
}

// ClearThirdPartyAuths clears the "third_party_auths" edge to the ThirdPartyAuth entity.
func (m *OrganizationMutation) ClearThirdPartyAuths() {
	m.clearedthird_party_auths = true
}

// ThirdPartyAuthsCleared reports if the "third_party_auths" edge to the ThirdPartyAuth entity was cleared.
func (m *OrganizationMutation) ThirdPartyAuthsCleared() bool {
	return m.clearedthird_party_auths
}

// RemoveThirdPartyAuthIDs removes the "third_party_auths" edge to the ThirdPartyAuth entity by IDs.
func (m *OrganizationMutation) RemoveThirdPartyAuthIDs(ids ...int) {
	if m.removedthird_party_auths == nil {
		m.removedthird_party_auths = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.third_party_auths, ids[i])
		m.removedthird_party_auths[ids[i]] = struct{}{}
	}
}

// RemovedThirdPartyAuths returns the removed IDs of the "third_party_auths" edge to the ThirdPartyAuth entity.
func (m *OrganizationMutation) RemovedThirdPartyAuthsIDs() (ids []int) {
	for id := range m.removedthird_party_auths {
		ids = append(ids, id)
	}
	return
}

// ThirdPartyAuthsIDs returns the "third_party_auths" edge IDs in the mutation.
func (m *OrganizationMutation) ThirdPartyAuthsIDs() (ids []int) {
	for id := range m.third_party_auths {
		ids = append(ids, id)
	}
	return
}

// ResetThirdPartyAuths resets all changes to the "third_party_auths" edge.
func (m *OrganizationMutation) ResetThirdPartyAuths() {
	m.third_party_auths = nil
	m.clearedthird_party_auths = false
	m.removedthird_party_auths = nil
}

// Where appends a list predicates to the OrganizationMutation builder.
func (m *OrganizationMutation) Where(ps ...predicate.Organization) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Organization, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Organization).
func (m *OrganizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, organization.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organization.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Organization field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organization.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Organization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Organization nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationMutation) ResetField(name string) error {
	switch name {
	case organization.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.providers != nil {
		edges = append(edges, organization.EdgeProviders)
	}
	if m.third_party_auths != nil {
		edges = append(edges, organization.EdgeThirdPartyAuths)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeProviders:
		ids := make([]ent.Value, 0, len(m.providers))
		for id := range m.providers {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeThirdPartyAuths:
		ids := make([]ent.Value, 0, len(m.third_party_auths))
		for id := range m.third_party_auths {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedproviders != nil {
		edges = append(edges, organization.EdgeProviders)
	}
	if m.removedthird_party_auths != nil {
		edges = append(edges, organization.EdgeThirdPartyAuths)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeProviders:
		ids := make([]ent.Value, 0, len(m.removedproviders))
		for id := range m.removedproviders {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeThirdPartyAuths:
		ids := make([]ent.Value, 0, len(m.removedthird_party_auths))
		for id := range m.removedthird_party_auths {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproviders {
		edges = append(edges, organization.EdgeProviders)
	}
	if m.clearedthird_party_auths {
		edges = append(edges, organization.EdgeThirdPartyAuths)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationMutation) EdgeCleared(name string) bool {
	switch name {
	case organization.EdgeProviders:
		return m.clearedproviders
	case organization.EdgeThirdPartyAuths:
		return m.clearedthird_party_auths
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Organization unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationMutation) ResetEdge(name string) error {
	switch name {
	case organization.EdgeProviders:
		m.ResetProviders()
		return nil
	case organization.EdgeThirdPartyAuths:
		m.ResetThirdPartyAuths()
		return nil
	}
	return fmt.Errorf("unknown Organization edge %s", name)
}

// PgsodiumConfigMutation represents an operation that mutates the PgsodiumConfig nodes in the graph.
type PgsodiumConfigMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	enabled        *bool
	clearedFields  map[string]struct{}
	project        *uuid.UUID
	clearedproject bool
	done           bool
	oldValue       func(context.Context) (*PgsodiumConfig, error)
	predicates     []predicate.PgsodiumConfig
}

var _ ent.Mutation = (*PgsodiumConfigMutation)(nil)

// pgsodiumconfigOption allows management of the mutation configuration using functional options.
type pgsodiumconfigOption func(*PgsodiumConfigMutation)

// newPgsodiumConfigMutation creates new mutation for the PgsodiumConfig entity.
func newPgsodiumConfigMutation(c config, op Op, opts ...pgsodiumconfigOption) *PgsodiumConfigMutation {
	m := &PgsodiumConfigMutation{
		config:        c,
		op:            op,
		typ:           TypePgsodiumConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPgsodiumConfigID sets the ID field of the mutation.
func withPgsodiumConfigID(id uuid.UUID) pgsodiumconfigOption {
	return func(m *PgsodiumConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *PgsodiumConfig
		)
		m.oldValue = func(ctx context.Context) (*PgsodiumConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PgsodiumConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPgsodiumConfig sets the old PgsodiumConfig of the mutation.
func withPgsodiumConfig(node *PgsodiumConfig) pgsodiumconfigOption {
	return func(m *PgsodiumConfigMutation) {
		m.oldValue = func(context.Context) (*PgsodiumConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PgsodiumConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PgsodiumConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PgsodiumConfig entities.
func (m *PgsodiumConfigMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PgsodiumConfigMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PgsodiumConfigMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PgsodiumConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProjectID sets the "project_id" field.
func (m *PgsodiumConfigMutation) SetProjectID(u uuid.UUID) {
	m.project = &u
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *PgsodiumConfigMutation) ProjectID() (r uuid.UUID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the PgsodiumConfig entity.
// If the PgsodiumConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PgsodiumConfigMutation) OldProjectID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *PgsodiumConfigMutation) ResetProjectID() {
	m.project = nil
}

// SetEnabled sets the "enabled" field.
func (m *PgsodiumConfigMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *PgsodiumConfigMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the PgsodiumConfig entity.
// If the PgsodiumConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PgsodiumConfigMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *PgsodiumConfigMutation) ResetEnabled() {
	m.enabled = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *PgsodiumConfigMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[pgsodiumconfig.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *PgsodiumConfigMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *PgsodiumConfigMutation) ProjectIDs() (ids []uuid.UUID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *PgsodiumConfigMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// Where appends a list predicates to the PgsodiumConfigMutation builder.
func (m *PgsodiumConfigMutation) Where(ps ...predicate.PgsodiumConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PgsodiumConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PgsodiumConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PgsodiumConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PgsodiumConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PgsodiumConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PgsodiumConfig).
func (m *PgsodiumConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PgsodiumConfigMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.project != nil {
		fields = append(fields, pgsodiumconfig.FieldProjectID)
	}
	if m.enabled != nil {
		fields = append(fields, pgsodiumconfig.FieldEnabled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PgsodiumConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pgsodiumconfig.FieldProjectID:
		return m.ProjectID()
	case pgsodiumconfig.FieldEnabled:
		return m.Enabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PgsodiumConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pgsodiumconfig.FieldProjectID:
		return m.OldProjectID(ctx)
	case pgsodiumconfig.FieldEnabled:
		return m.OldEnabled(ctx)
	}
	return nil, fmt.Errorf("unknown PgsodiumConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PgsodiumConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pgsodiumconfig.FieldProjectID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case pgsodiumconfig.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	}
	return fmt.Errorf("unknown PgsodiumConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PgsodiumConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PgsodiumConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PgsodiumConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PgsodiumConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PgsodiumConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PgsodiumConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PgsodiumConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PgsodiumConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PgsodiumConfigMutation) ResetField(name string) error {
	switch name {
	case pgsodiumconfig.FieldProjectID:
		m.ResetProjectID()
		return nil
	case pgsodiumconfig.FieldEnabled:
		m.ResetEnabled()
		return nil
	}
	return fmt.Errorf("unknown PgsodiumConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PgsodiumConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.project != nil {
		edges = append(edges, pgsodiumconfig.EdgeProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PgsodiumConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pgsodiumconfig.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PgsodiumConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PgsodiumConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PgsodiumConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproject {
		edges = append(edges, pgsodiumconfig.EdgeProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PgsodiumConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case pgsodiumconfig.EdgeProject:
		return m.clearedproject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PgsodiumConfigMutation) ClearEdge(name string) error {
	switch name {
	case pgsodiumconfig.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown PgsodiumConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PgsodiumConfigMutation) ResetEdge(name string) error {
	switch name {
	case pgsodiumconfig.EdgeProject:
		m.ResetProject()
		return nil
	}
	return fmt.Errorf("unknown PgsodiumConfig edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	name                   *string
	clearedFields          map[string]struct{}
	secrets                map[uuid.UUID]struct{}
	removedsecrets         map[uuid.UUID]struct{}
	clearedsecrets         bool
	typescriptTypes        map[uuid.UUID]struct{}
	removedtypescriptTypes map[uuid.UUID]struct{}
	clearedtypescriptTypes bool
	functions              map[uuid.UUID]struct{}
	removedfunctions       map[uuid.UUID]struct{}
	clearedfunctions       bool
	customHostnames        map[uuid.UUID]struct{}
	removedcustomHostnames map[uuid.UUID]struct{}
	clearedcustomHostnames bool
	pgsodiumConfigs        map[uuid.UUID]struct{}
	removedpgsodiumConfigs map[uuid.UUID]struct{}
	clearedpgsodiumConfigs bool
	networkBans            map[uuid.UUID]struct{}
	removednetworkBans     map[uuid.UUID]struct{}
	clearednetworkBans     bool
	branches               map[uuid.UUID]struct{}
	removedbranches        map[uuid.UUID]struct{}
	clearedbranches        bool
	childBranches          map[uuid.UUID]struct{}
	removedchildBranches   map[uuid.UUID]struct{}
	clearedchildBranches   bool
	auth_config            *uuid.UUID
	clearedauth_config     bool
	done                   bool
	oldValue               func(context.Context) (*Project, error)
	predicates             []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id uuid.UUID) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Project entities.
func (m *ProjectMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Project.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ProjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectMutation) ResetName() {
	m.name = nil
}

// AddSecretIDs adds the "secrets" edge to the Secret entity by ids.
func (m *ProjectMutation) AddSecretIDs(ids ...uuid.UUID) {
	if m.secrets == nil {
		m.secrets = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.secrets[ids[i]] = struct{}{}
	}
}

// ClearSecrets clears the "secrets" edge to the Secret entity.
func (m *ProjectMutation) ClearSecrets() {
	m.clearedsecrets = true
}

// SecretsCleared reports if the "secrets" edge to the Secret entity was cleared.
func (m *ProjectMutation) SecretsCleared() bool {
	return m.clearedsecrets
}

// RemoveSecretIDs removes the "secrets" edge to the Secret entity by IDs.
func (m *ProjectMutation) RemoveSecretIDs(ids ...uuid.UUID) {
	if m.removedsecrets == nil {
		m.removedsecrets = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.secrets, ids[i])
		m.removedsecrets[ids[i]] = struct{}{}
	}
}

// RemovedSecrets returns the removed IDs of the "secrets" edge to the Secret entity.
func (m *ProjectMutation) RemovedSecretsIDs() (ids []uuid.UUID) {
	for id := range m.removedsecrets {
		ids = append(ids, id)
	}
	return
}

// SecretsIDs returns the "secrets" edge IDs in the mutation.
func (m *ProjectMutation) SecretsIDs() (ids []uuid.UUID) {
	for id := range m.secrets {
		ids = append(ids, id)
	}
	return
}

// ResetSecrets resets all changes to the "secrets" edge.
func (m *ProjectMutation) ResetSecrets() {
	m.secrets = nil
	m.clearedsecrets = false
	m.removedsecrets = nil
}

// AddTypescriptTypeIDs adds the "typescriptTypes" edge to the TypeScriptType entity by ids.
func (m *ProjectMutation) AddTypescriptTypeIDs(ids ...uuid.UUID) {
	if m.typescriptTypes == nil {
		m.typescriptTypes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.typescriptTypes[ids[i]] = struct{}{}
	}
}

// ClearTypescriptTypes clears the "typescriptTypes" edge to the TypeScriptType entity.
func (m *ProjectMutation) ClearTypescriptTypes() {
	m.clearedtypescriptTypes = true
}

// TypescriptTypesCleared reports if the "typescriptTypes" edge to the TypeScriptType entity was cleared.
func (m *ProjectMutation) TypescriptTypesCleared() bool {
	return m.clearedtypescriptTypes
}

// RemoveTypescriptTypeIDs removes the "typescriptTypes" edge to the TypeScriptType entity by IDs.
func (m *ProjectMutation) RemoveTypescriptTypeIDs(ids ...uuid.UUID) {
	if m.removedtypescriptTypes == nil {
		m.removedtypescriptTypes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.typescriptTypes, ids[i])
		m.removedtypescriptTypes[ids[i]] = struct{}{}
	}
}

// RemovedTypescriptTypes returns the removed IDs of the "typescriptTypes" edge to the TypeScriptType entity.
func (m *ProjectMutation) RemovedTypescriptTypesIDs() (ids []uuid.UUID) {
	for id := range m.removedtypescriptTypes {
		ids = append(ids, id)
	}
	return
}

// TypescriptTypesIDs returns the "typescriptTypes" edge IDs in the mutation.
func (m *ProjectMutation) TypescriptTypesIDs() (ids []uuid.UUID) {
	for id := range m.typescriptTypes {
		ids = append(ids, id)
	}
	return
}

// ResetTypescriptTypes resets all changes to the "typescriptTypes" edge.
func (m *ProjectMutation) ResetTypescriptTypes() {
	m.typescriptTypes = nil
	m.clearedtypescriptTypes = false
	m.removedtypescriptTypes = nil
}

// AddFunctionIDs adds the "functions" edge to the Function entity by ids.
func (m *ProjectMutation) AddFunctionIDs(ids ...uuid.UUID) {
	if m.functions == nil {
		m.functions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.functions[ids[i]] = struct{}{}
	}
}

// ClearFunctions clears the "functions" edge to the Function entity.
func (m *ProjectMutation) ClearFunctions() {
	m.clearedfunctions = true
}

// FunctionsCleared reports if the "functions" edge to the Function entity was cleared.
func (m *ProjectMutation) FunctionsCleared() bool {
	return m.clearedfunctions
}

// RemoveFunctionIDs removes the "functions" edge to the Function entity by IDs.
func (m *ProjectMutation) RemoveFunctionIDs(ids ...uuid.UUID) {
	if m.removedfunctions == nil {
		m.removedfunctions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.functions, ids[i])
		m.removedfunctions[ids[i]] = struct{}{}
	}
}

// RemovedFunctions returns the removed IDs of the "functions" edge to the Function entity.
func (m *ProjectMutation) RemovedFunctionsIDs() (ids []uuid.UUID) {
	for id := range m.removedfunctions {
		ids = append(ids, id)
	}
	return
}

// FunctionsIDs returns the "functions" edge IDs in the mutation.
func (m *ProjectMutation) FunctionsIDs() (ids []uuid.UUID) {
	for id := range m.functions {
		ids = append(ids, id)
	}
	return
}

// ResetFunctions resets all changes to the "functions" edge.
func (m *ProjectMutation) ResetFunctions() {
	m.functions = nil
	m.clearedfunctions = false
	m.removedfunctions = nil
}

// AddCustomHostnameIDs adds the "customHostnames" edge to the CustomHostname entity by ids.
func (m *ProjectMutation) AddCustomHostnameIDs(ids ...uuid.UUID) {
	if m.customHostnames == nil {
		m.customHostnames = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.customHostnames[ids[i]] = struct{}{}
	}
}

// ClearCustomHostnames clears the "customHostnames" edge to the CustomHostname entity.
func (m *ProjectMutation) ClearCustomHostnames() {
	m.clearedcustomHostnames = true
}

// CustomHostnamesCleared reports if the "customHostnames" edge to the CustomHostname entity was cleared.
func (m *ProjectMutation) CustomHostnamesCleared() bool {
	return m.clearedcustomHostnames
}

// RemoveCustomHostnameIDs removes the "customHostnames" edge to the CustomHostname entity by IDs.
func (m *ProjectMutation) RemoveCustomHostnameIDs(ids ...uuid.UUID) {
	if m.removedcustomHostnames == nil {
		m.removedcustomHostnames = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.customHostnames, ids[i])
		m.removedcustomHostnames[ids[i]] = struct{}{}
	}
}

// RemovedCustomHostnames returns the removed IDs of the "customHostnames" edge to the CustomHostname entity.
func (m *ProjectMutation) RemovedCustomHostnamesIDs() (ids []uuid.UUID) {
	for id := range m.removedcustomHostnames {
		ids = append(ids, id)
	}
	return
}

// CustomHostnamesIDs returns the "customHostnames" edge IDs in the mutation.
func (m *ProjectMutation) CustomHostnamesIDs() (ids []uuid.UUID) {
	for id := range m.customHostnames {
		ids = append(ids, id)
	}
	return
}

// ResetCustomHostnames resets all changes to the "customHostnames" edge.
func (m *ProjectMutation) ResetCustomHostnames() {
	m.customHostnames = nil
	m.clearedcustomHostnames = false
	m.removedcustomHostnames = nil
}

// AddPgsodiumConfigIDs adds the "pgsodiumConfigs" edge to the PgsodiumConfig entity by ids.
func (m *ProjectMutation) AddPgsodiumConfigIDs(ids ...uuid.UUID) {
	if m.pgsodiumConfigs == nil {
		m.pgsodiumConfigs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.pgsodiumConfigs[ids[i]] = struct{}{}
	}
}

// ClearPgsodiumConfigs clears the "pgsodiumConfigs" edge to the PgsodiumConfig entity.
func (m *ProjectMutation) ClearPgsodiumConfigs() {
	m.clearedpgsodiumConfigs = true
}

// PgsodiumConfigsCleared reports if the "pgsodiumConfigs" edge to the PgsodiumConfig entity was cleared.
func (m *ProjectMutation) PgsodiumConfigsCleared() bool {
	return m.clearedpgsodiumConfigs
}

// RemovePgsodiumConfigIDs removes the "pgsodiumConfigs" edge to the PgsodiumConfig entity by IDs.
func (m *ProjectMutation) RemovePgsodiumConfigIDs(ids ...uuid.UUID) {
	if m.removedpgsodiumConfigs == nil {
		m.removedpgsodiumConfigs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.pgsodiumConfigs, ids[i])
		m.removedpgsodiumConfigs[ids[i]] = struct{}{}
	}
}

// RemovedPgsodiumConfigs returns the removed IDs of the "pgsodiumConfigs" edge to the PgsodiumConfig entity.
func (m *ProjectMutation) RemovedPgsodiumConfigsIDs() (ids []uuid.UUID) {
	for id := range m.removedpgsodiumConfigs {
		ids = append(ids, id)
	}
	return
}

// PgsodiumConfigsIDs returns the "pgsodiumConfigs" edge IDs in the mutation.
func (m *ProjectMutation) PgsodiumConfigsIDs() (ids []uuid.UUID) {
	for id := range m.pgsodiumConfigs {
		ids = append(ids, id)
	}
	return
}

// ResetPgsodiumConfigs resets all changes to the "pgsodiumConfigs" edge.
func (m *ProjectMutation) ResetPgsodiumConfigs() {
	m.pgsodiumConfigs = nil
	m.clearedpgsodiumConfigs = false
	m.removedpgsodiumConfigs = nil
}

// AddNetworkBanIDs adds the "networkBans" edge to the NetworkBan entity by ids.
func (m *ProjectMutation) AddNetworkBanIDs(ids ...uuid.UUID) {
	if m.networkBans == nil {
		m.networkBans = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.networkBans[ids[i]] = struct{}{}
	}
}

// ClearNetworkBans clears the "networkBans" edge to the NetworkBan entity.
func (m *ProjectMutation) ClearNetworkBans() {
	m.clearednetworkBans = true
}

// NetworkBansCleared reports if the "networkBans" edge to the NetworkBan entity was cleared.
func (m *ProjectMutation) NetworkBansCleared() bool {
	return m.clearednetworkBans
}

// RemoveNetworkBanIDs removes the "networkBans" edge to the NetworkBan entity by IDs.
func (m *ProjectMutation) RemoveNetworkBanIDs(ids ...uuid.UUID) {
	if m.removednetworkBans == nil {
		m.removednetworkBans = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.networkBans, ids[i])
		m.removednetworkBans[ids[i]] = struct{}{}
	}
}

// RemovedNetworkBans returns the removed IDs of the "networkBans" edge to the NetworkBan entity.
func (m *ProjectMutation) RemovedNetworkBansIDs() (ids []uuid.UUID) {
	for id := range m.removednetworkBans {
		ids = append(ids, id)
	}
	return
}

// NetworkBansIDs returns the "networkBans" edge IDs in the mutation.
func (m *ProjectMutation) NetworkBansIDs() (ids []uuid.UUID) {
	for id := range m.networkBans {
		ids = append(ids, id)
	}
	return
}

// ResetNetworkBans resets all changes to the "networkBans" edge.
func (m *ProjectMutation) ResetNetworkBans() {
	m.networkBans = nil
	m.clearednetworkBans = false
	m.removednetworkBans = nil
}

// AddBranchIDs adds the "branches" edge to the Branch entity by ids.
func (m *ProjectMutation) AddBranchIDs(ids ...uuid.UUID) {
	if m.branches == nil {
		m.branches = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.branches[ids[i]] = struct{}{}
	}
}

// ClearBranches clears the "branches" edge to the Branch entity.
func (m *ProjectMutation) ClearBranches() {
	m.clearedbranches = true
}

// BranchesCleared reports if the "branches" edge to the Branch entity was cleared.
func (m *ProjectMutation) BranchesCleared() bool {
	return m.clearedbranches
}

// RemoveBranchIDs removes the "branches" edge to the Branch entity by IDs.
func (m *ProjectMutation) RemoveBranchIDs(ids ...uuid.UUID) {
	if m.removedbranches == nil {
		m.removedbranches = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.branches, ids[i])
		m.removedbranches[ids[i]] = struct{}{}
	}
}

// RemovedBranches returns the removed IDs of the "branches" edge to the Branch entity.
func (m *ProjectMutation) RemovedBranchesIDs() (ids []uuid.UUID) {
	for id := range m.removedbranches {
		ids = append(ids, id)
	}
	return
}

// BranchesIDs returns the "branches" edge IDs in the mutation.
func (m *ProjectMutation) BranchesIDs() (ids []uuid.UUID) {
	for id := range m.branches {
		ids = append(ids, id)
	}
	return
}

// ResetBranches resets all changes to the "branches" edge.
func (m *ProjectMutation) ResetBranches() {
	m.branches = nil
	m.clearedbranches = false
	m.removedbranches = nil
}

// AddChildBranchIDs adds the "childBranches" edge to the Branch entity by ids.
func (m *ProjectMutation) AddChildBranchIDs(ids ...uuid.UUID) {
	if m.childBranches == nil {
		m.childBranches = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.childBranches[ids[i]] = struct{}{}
	}
}

// ClearChildBranches clears the "childBranches" edge to the Branch entity.
func (m *ProjectMutation) ClearChildBranches() {
	m.clearedchildBranches = true
}

// ChildBranchesCleared reports if the "childBranches" edge to the Branch entity was cleared.
func (m *ProjectMutation) ChildBranchesCleared() bool {
	return m.clearedchildBranches
}

// RemoveChildBranchIDs removes the "childBranches" edge to the Branch entity by IDs.
func (m *ProjectMutation) RemoveChildBranchIDs(ids ...uuid.UUID) {
	if m.removedchildBranches == nil {
		m.removedchildBranches = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.childBranches, ids[i])
		m.removedchildBranches[ids[i]] = struct{}{}
	}
}

// RemovedChildBranches returns the removed IDs of the "childBranches" edge to the Branch entity.
func (m *ProjectMutation) RemovedChildBranchesIDs() (ids []uuid.UUID) {
	for id := range m.removedchildBranches {
		ids = append(ids, id)
	}
	return
}

// ChildBranchesIDs returns the "childBranches" edge IDs in the mutation.
func (m *ProjectMutation) ChildBranchesIDs() (ids []uuid.UUID) {
	for id := range m.childBranches {
		ids = append(ids, id)
	}
	return
}

// ResetChildBranches resets all changes to the "childBranches" edge.
func (m *ProjectMutation) ResetChildBranches() {
	m.childBranches = nil
	m.clearedchildBranches = false
	m.removedchildBranches = nil
}

// SetAuthConfigID sets the "auth_config" edge to the AuthConfig entity by id.
func (m *ProjectMutation) SetAuthConfigID(id uuid.UUID) {
	m.auth_config = &id
}

// ClearAuthConfig clears the "auth_config" edge to the AuthConfig entity.
func (m *ProjectMutation) ClearAuthConfig() {
	m.clearedauth_config = true
}

// AuthConfigCleared reports if the "auth_config" edge to the AuthConfig entity was cleared.
func (m *ProjectMutation) AuthConfigCleared() bool {
	return m.clearedauth_config
}

// AuthConfigID returns the "auth_config" edge ID in the mutation.
func (m *ProjectMutation) AuthConfigID() (id uuid.UUID, exists bool) {
	if m.auth_config != nil {
		return *m.auth_config, true
	}
	return
}

// AuthConfigIDs returns the "auth_config" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthConfigID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) AuthConfigIDs() (ids []uuid.UUID) {
	if id := m.auth_config; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthConfig resets all changes to the "auth_config" edge.
func (m *ProjectMutation) ResetAuthConfig() {
	m.auth_config = nil
	m.clearedauth_config = false
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Project, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, project.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.secrets != nil {
		edges = append(edges, project.EdgeSecrets)
	}
	if m.typescriptTypes != nil {
		edges = append(edges, project.EdgeTypescriptTypes)
	}
	if m.functions != nil {
		edges = append(edges, project.EdgeFunctions)
	}
	if m.customHostnames != nil {
		edges = append(edges, project.EdgeCustomHostnames)
	}
	if m.pgsodiumConfigs != nil {
		edges = append(edges, project.EdgePgsodiumConfigs)
	}
	if m.networkBans != nil {
		edges = append(edges, project.EdgeNetworkBans)
	}
	if m.branches != nil {
		edges = append(edges, project.EdgeBranches)
	}
	if m.childBranches != nil {
		edges = append(edges, project.EdgeChildBranches)
	}
	if m.auth_config != nil {
		edges = append(edges, project.EdgeAuthConfig)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeSecrets:
		ids := make([]ent.Value, 0, len(m.secrets))
		for id := range m.secrets {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTypescriptTypes:
		ids := make([]ent.Value, 0, len(m.typescriptTypes))
		for id := range m.typescriptTypes {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeFunctions:
		ids := make([]ent.Value, 0, len(m.functions))
		for id := range m.functions {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeCustomHostnames:
		ids := make([]ent.Value, 0, len(m.customHostnames))
		for id := range m.customHostnames {
			ids = append(ids, id)
		}
		return ids
	case project.EdgePgsodiumConfigs:
		ids := make([]ent.Value, 0, len(m.pgsodiumConfigs))
		for id := range m.pgsodiumConfigs {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeNetworkBans:
		ids := make([]ent.Value, 0, len(m.networkBans))
		for id := range m.networkBans {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeBranches:
		ids := make([]ent.Value, 0, len(m.branches))
		for id := range m.branches {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeChildBranches:
		ids := make([]ent.Value, 0, len(m.childBranches))
		for id := range m.childBranches {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeAuthConfig:
		if id := m.auth_config; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedsecrets != nil {
		edges = append(edges, project.EdgeSecrets)
	}
	if m.removedtypescriptTypes != nil {
		edges = append(edges, project.EdgeTypescriptTypes)
	}
	if m.removedfunctions != nil {
		edges = append(edges, project.EdgeFunctions)
	}
	if m.removedcustomHostnames != nil {
		edges = append(edges, project.EdgeCustomHostnames)
	}
	if m.removedpgsodiumConfigs != nil {
		edges = append(edges, project.EdgePgsodiumConfigs)
	}
	if m.removednetworkBans != nil {
		edges = append(edges, project.EdgeNetworkBans)
	}
	if m.removedbranches != nil {
		edges = append(edges, project.EdgeBranches)
	}
	if m.removedchildBranches != nil {
		edges = append(edges, project.EdgeChildBranches)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeSecrets:
		ids := make([]ent.Value, 0, len(m.removedsecrets))
		for id := range m.removedsecrets {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTypescriptTypes:
		ids := make([]ent.Value, 0, len(m.removedtypescriptTypes))
		for id := range m.removedtypescriptTypes {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeFunctions:
		ids := make([]ent.Value, 0, len(m.removedfunctions))
		for id := range m.removedfunctions {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeCustomHostnames:
		ids := make([]ent.Value, 0, len(m.removedcustomHostnames))
		for id := range m.removedcustomHostnames {
			ids = append(ids, id)
		}
		return ids
	case project.EdgePgsodiumConfigs:
		ids := make([]ent.Value, 0, len(m.removedpgsodiumConfigs))
		for id := range m.removedpgsodiumConfigs {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeNetworkBans:
		ids := make([]ent.Value, 0, len(m.removednetworkBans))
		for id := range m.removednetworkBans {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeBranches:
		ids := make([]ent.Value, 0, len(m.removedbranches))
		for id := range m.removedbranches {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeChildBranches:
		ids := make([]ent.Value, 0, len(m.removedchildBranches))
		for id := range m.removedchildBranches {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedsecrets {
		edges = append(edges, project.EdgeSecrets)
	}
	if m.clearedtypescriptTypes {
		edges = append(edges, project.EdgeTypescriptTypes)
	}
	if m.clearedfunctions {
		edges = append(edges, project.EdgeFunctions)
	}
	if m.clearedcustomHostnames {
		edges = append(edges, project.EdgeCustomHostnames)
	}
	if m.clearedpgsodiumConfigs {
		edges = append(edges, project.EdgePgsodiumConfigs)
	}
	if m.clearednetworkBans {
		edges = append(edges, project.EdgeNetworkBans)
	}
	if m.clearedbranches {
		edges = append(edges, project.EdgeBranches)
	}
	if m.clearedchildBranches {
		edges = append(edges, project.EdgeChildBranches)
	}
	if m.clearedauth_config {
		edges = append(edges, project.EdgeAuthConfig)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeSecrets:
		return m.clearedsecrets
	case project.EdgeTypescriptTypes:
		return m.clearedtypescriptTypes
	case project.EdgeFunctions:
		return m.clearedfunctions
	case project.EdgeCustomHostnames:
		return m.clearedcustomHostnames
	case project.EdgePgsodiumConfigs:
		return m.clearedpgsodiumConfigs
	case project.EdgeNetworkBans:
		return m.clearednetworkBans
	case project.EdgeBranches:
		return m.clearedbranches
	case project.EdgeChildBranches:
		return m.clearedchildBranches
	case project.EdgeAuthConfig:
		return m.clearedauth_config
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	case project.EdgeAuthConfig:
		m.ClearAuthConfig()
		return nil
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeSecrets:
		m.ResetSecrets()
		return nil
	case project.EdgeTypescriptTypes:
		m.ResetTypescriptTypes()
		return nil
	case project.EdgeFunctions:
		m.ResetFunctions()
		return nil
	case project.EdgeCustomHostnames:
		m.ResetCustomHostnames()
		return nil
	case project.EdgePgsodiumConfigs:
		m.ResetPgsodiumConfigs()
		return nil
	case project.EdgeNetworkBans:
		m.ResetNetworkBans()
		return nil
	case project.EdgeBranches:
		m.ResetBranches()
		return nil
	case project.EdgeChildBranches:
		m.ResetChildBranches()
		return nil
	case project.EdgeAuthConfig:
		m.ResetAuthConfig()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// ProviderMutation represents an operation that mutates the Provider nodes in the graph.
type ProviderMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	_type               *string
	metadata_xml        *string
	metadata_url        *string
	domains             *[]string
	appenddomains       []string
	attribute_mapping   *map[string]string
	clearedFields       map[string]struct{}
	organization        *int
	clearedorganization bool
	done                bool
	oldValue            func(context.Context) (*Provider, error)
	predicates          []predicate.Provider
}

var _ ent.Mutation = (*ProviderMutation)(nil)

// providerOption allows management of the mutation configuration using functional options.
type providerOption func(*ProviderMutation)

// newProviderMutation creates new mutation for the Provider entity.
func newProviderMutation(c config, op Op, opts ...providerOption) *ProviderMutation {
	m := &ProviderMutation{
		config:        c,
		op:            op,
		typ:           TypeProvider,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProviderID sets the ID field of the mutation.
func withProviderID(id int) providerOption {
	return func(m *ProviderMutation) {
		var (
			err   error
			once  sync.Once
			value *Provider
		)
		m.oldValue = func(ctx context.Context) (*Provider, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Provider.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProvider sets the old Provider of the mutation.
func withProvider(node *Provider) providerOption {
	return func(m *ProviderMutation) {
		m.oldValue = func(context.Context) (*Provider, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProviderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProviderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProviderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProviderMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Provider.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *ProviderMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ProviderMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ProviderMutation) ResetType() {
	m._type = nil
}

// SetMetadataXML sets the "metadata_xml" field.
func (m *ProviderMutation) SetMetadataXML(s string) {
	m.metadata_xml = &s
}

// MetadataXML returns the value of the "metadata_xml" field in the mutation.
func (m *ProviderMutation) MetadataXML() (r string, exists bool) {
	v := m.metadata_xml
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadataXML returns the old "metadata_xml" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldMetadataXML(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadataXML is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadataXML requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadataXML: %w", err)
	}
	return oldValue.MetadataXML, nil
}

// ClearMetadataXML clears the value of the "metadata_xml" field.
func (m *ProviderMutation) ClearMetadataXML() {
	m.metadata_xml = nil
	m.clearedFields[provider.FieldMetadataXML] = struct{}{}
}

// MetadataXMLCleared returns if the "metadata_xml" field was cleared in this mutation.
func (m *ProviderMutation) MetadataXMLCleared() bool {
	_, ok := m.clearedFields[provider.FieldMetadataXML]
	return ok
}

// ResetMetadataXML resets all changes to the "metadata_xml" field.
func (m *ProviderMutation) ResetMetadataXML() {
	m.metadata_xml = nil
	delete(m.clearedFields, provider.FieldMetadataXML)
}

// SetMetadataURL sets the "metadata_url" field.
func (m *ProviderMutation) SetMetadataURL(s string) {
	m.metadata_url = &s
}

// MetadataURL returns the value of the "metadata_url" field in the mutation.
func (m *ProviderMutation) MetadataURL() (r string, exists bool) {
	v := m.metadata_url
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadataURL returns the old "metadata_url" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldMetadataURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadataURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadataURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadataURL: %w", err)
	}
	return oldValue.MetadataURL, nil
}

// ClearMetadataURL clears the value of the "metadata_url" field.
func (m *ProviderMutation) ClearMetadataURL() {
	m.metadata_url = nil
	m.clearedFields[provider.FieldMetadataURL] = struct{}{}
}

// MetadataURLCleared returns if the "metadata_url" field was cleared in this mutation.
func (m *ProviderMutation) MetadataURLCleared() bool {
	_, ok := m.clearedFields[provider.FieldMetadataURL]
	return ok
}

// ResetMetadataURL resets all changes to the "metadata_url" field.
func (m *ProviderMutation) ResetMetadataURL() {
	m.metadata_url = nil
	delete(m.clearedFields, provider.FieldMetadataURL)
}

// SetDomains sets the "domains" field.
func (m *ProviderMutation) SetDomains(s []string) {
	m.domains = &s
	m.appenddomains = nil
}

// Domains returns the value of the "domains" field in the mutation.
func (m *ProviderMutation) Domains() (r []string, exists bool) {
	v := m.domains
	if v == nil {
		return
	}
	return *v, true
}

// OldDomains returns the old "domains" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldDomains(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomains is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomains requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomains: %w", err)
	}
	return oldValue.Domains, nil
}

// AppendDomains adds s to the "domains" field.
func (m *ProviderMutation) AppendDomains(s []string) {
	m.appenddomains = append(m.appenddomains, s...)
}

// AppendedDomains returns the list of values that were appended to the "domains" field in this mutation.
func (m *ProviderMutation) AppendedDomains() ([]string, bool) {
	if len(m.appenddomains) == 0 {
		return nil, false
	}
	return m.appenddomains, true
}

// ResetDomains resets all changes to the "domains" field.
func (m *ProviderMutation) ResetDomains() {
	m.domains = nil
	m.appenddomains = nil
}

// SetAttributeMapping sets the "attribute_mapping" field.
func (m *ProviderMutation) SetAttributeMapping(value map[string]string) {
	m.attribute_mapping = &value
}

// AttributeMapping returns the value of the "attribute_mapping" field in the mutation.
func (m *ProviderMutation) AttributeMapping() (r map[string]string, exists bool) {
	v := m.attribute_mapping
	if v == nil {
		return
	}
	return *v, true
}

// OldAttributeMapping returns the old "attribute_mapping" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldAttributeMapping(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttributeMapping is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttributeMapping requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttributeMapping: %w", err)
	}
	return oldValue.AttributeMapping, nil
}

// ClearAttributeMapping clears the value of the "attribute_mapping" field.
func (m *ProviderMutation) ClearAttributeMapping() {
	m.attribute_mapping = nil
	m.clearedFields[provider.FieldAttributeMapping] = struct{}{}
}

// AttributeMappingCleared returns if the "attribute_mapping" field was cleared in this mutation.
func (m *ProviderMutation) AttributeMappingCleared() bool {
	_, ok := m.clearedFields[provider.FieldAttributeMapping]
	return ok
}

// ResetAttributeMapping resets all changes to the "attribute_mapping" field.
func (m *ProviderMutation) ResetAttributeMapping() {
	m.attribute_mapping = nil
	delete(m.clearedFields, provider.FieldAttributeMapping)
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *ProviderMutation) SetOrganizationID(id int) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *ProviderMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *ProviderMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *ProviderMutation) OrganizationID() (id int, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *ProviderMutation) OrganizationIDs() (ids []int) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *ProviderMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the ProviderMutation builder.
func (m *ProviderMutation) Where(ps ...predicate.Provider) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProviderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProviderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Provider, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProviderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProviderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Provider).
func (m *ProviderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProviderMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._type != nil {
		fields = append(fields, provider.FieldType)
	}
	if m.metadata_xml != nil {
		fields = append(fields, provider.FieldMetadataXML)
	}
	if m.metadata_url != nil {
		fields = append(fields, provider.FieldMetadataURL)
	}
	if m.domains != nil {
		fields = append(fields, provider.FieldDomains)
	}
	if m.attribute_mapping != nil {
		fields = append(fields, provider.FieldAttributeMapping)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProviderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case provider.FieldType:
		return m.GetType()
	case provider.FieldMetadataXML:
		return m.MetadataXML()
	case provider.FieldMetadataURL:
		return m.MetadataURL()
	case provider.FieldDomains:
		return m.Domains()
	case provider.FieldAttributeMapping:
		return m.AttributeMapping()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProviderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case provider.FieldType:
		return m.OldType(ctx)
	case provider.FieldMetadataXML:
		return m.OldMetadataXML(ctx)
	case provider.FieldMetadataURL:
		return m.OldMetadataURL(ctx)
	case provider.FieldDomains:
		return m.OldDomains(ctx)
	case provider.FieldAttributeMapping:
		return m.OldAttributeMapping(ctx)
	}
	return nil, fmt.Errorf("unknown Provider field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProviderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case provider.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case provider.FieldMetadataXML:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadataXML(v)
		return nil
	case provider.FieldMetadataURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadataURL(v)
		return nil
	case provider.FieldDomains:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomains(v)
		return nil
	case provider.FieldAttributeMapping:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttributeMapping(v)
		return nil
	}
	return fmt.Errorf("unknown Provider field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProviderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProviderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProviderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Provider numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProviderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(provider.FieldMetadataXML) {
		fields = append(fields, provider.FieldMetadataXML)
	}
	if m.FieldCleared(provider.FieldMetadataURL) {
		fields = append(fields, provider.FieldMetadataURL)
	}
	if m.FieldCleared(provider.FieldAttributeMapping) {
		fields = append(fields, provider.FieldAttributeMapping)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProviderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProviderMutation) ClearField(name string) error {
	switch name {
	case provider.FieldMetadataXML:
		m.ClearMetadataXML()
		return nil
	case provider.FieldMetadataURL:
		m.ClearMetadataURL()
		return nil
	case provider.FieldAttributeMapping:
		m.ClearAttributeMapping()
		return nil
	}
	return fmt.Errorf("unknown Provider nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProviderMutation) ResetField(name string) error {
	switch name {
	case provider.FieldType:
		m.ResetType()
		return nil
	case provider.FieldMetadataXML:
		m.ResetMetadataXML()
		return nil
	case provider.FieldMetadataURL:
		m.ResetMetadataURL()
		return nil
	case provider.FieldDomains:
		m.ResetDomains()
		return nil
	case provider.FieldAttributeMapping:
		m.ResetAttributeMapping()
		return nil
	}
	return fmt.Errorf("unknown Provider field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProviderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.organization != nil {
		edges = append(edges, provider.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProviderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case provider.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProviderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProviderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProviderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedorganization {
		edges = append(edges, provider.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProviderMutation) EdgeCleared(name string) bool {
	switch name {
	case provider.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProviderMutation) ClearEdge(name string) error {
	switch name {
	case provider.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown Provider unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProviderMutation) ResetEdge(name string) error {
	switch name {
	case provider.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown Provider edge %s", name)
}

// SecretMutation represents an operation that mutates the Secret nodes in the graph.
type SecretMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	name           *string
	value          *string
	clearedFields  map[string]struct{}
	project        *uuid.UUID
	clearedproject bool
	done           bool
	oldValue       func(context.Context) (*Secret, error)
	predicates     []predicate.Secret
}

var _ ent.Mutation = (*SecretMutation)(nil)

// secretOption allows management of the mutation configuration using functional options.
type secretOption func(*SecretMutation)

// newSecretMutation creates new mutation for the Secret entity.
func newSecretMutation(c config, op Op, opts ...secretOption) *SecretMutation {
	m := &SecretMutation{
		config:        c,
		op:            op,
		typ:           TypeSecret,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSecretID sets the ID field of the mutation.
func withSecretID(id uuid.UUID) secretOption {
	return func(m *SecretMutation) {
		var (
			err   error
			once  sync.Once
			value *Secret
		)
		m.oldValue = func(ctx context.Context) (*Secret, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Secret.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSecret sets the old Secret of the mutation.
func withSecret(node *Secret) secretOption {
	return func(m *SecretMutation) {
		m.oldValue = func(context.Context) (*Secret, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SecretMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SecretMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Secret entities.
func (m *SecretMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SecretMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SecretMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Secret.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProjectID sets the "project_id" field.
func (m *SecretMutation) SetProjectID(u uuid.UUID) {
	m.project = &u
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *SecretMutation) ProjectID() (r uuid.UUID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Secret entity.
// If the Secret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretMutation) OldProjectID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *SecretMutation) ResetProjectID() {
	m.project = nil
}

// SetName sets the "name" field.
func (m *SecretMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SecretMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Secret entity.
// If the Secret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SecretMutation) ResetName() {
	m.name = nil
}

// SetValue sets the "value" field.
func (m *SecretMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SecretMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Secret entity.
// If the Secret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SecretMutation) ResetValue() {
	m.value = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *SecretMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[secret.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *SecretMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *SecretMutation) ProjectIDs() (ids []uuid.UUID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *SecretMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// Where appends a list predicates to the SecretMutation builder.
func (m *SecretMutation) Where(ps ...predicate.Secret) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SecretMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SecretMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Secret, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SecretMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SecretMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Secret).
func (m *SecretMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SecretMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.project != nil {
		fields = append(fields, secret.FieldProjectID)
	}
	if m.name != nil {
		fields = append(fields, secret.FieldName)
	}
	if m.value != nil {
		fields = append(fields, secret.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SecretMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case secret.FieldProjectID:
		return m.ProjectID()
	case secret.FieldName:
		return m.Name()
	case secret.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SecretMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case secret.FieldProjectID:
		return m.OldProjectID(ctx)
	case secret.FieldName:
		return m.OldName(ctx)
	case secret.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Secret field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SecretMutation) SetField(name string, value ent.Value) error {
	switch name {
	case secret.FieldProjectID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case secret.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case secret.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Secret field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SecretMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SecretMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SecretMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Secret numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SecretMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SecretMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SecretMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Secret nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SecretMutation) ResetField(name string) error {
	switch name {
	case secret.FieldProjectID:
		m.ResetProjectID()
		return nil
	case secret.FieldName:
		m.ResetName()
		return nil
	case secret.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Secret field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SecretMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.project != nil {
		edges = append(edges, secret.EdgeProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SecretMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case secret.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SecretMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SecretMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SecretMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproject {
		edges = append(edges, secret.EdgeProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SecretMutation) EdgeCleared(name string) bool {
	switch name {
	case secret.EdgeProject:
		return m.clearedproject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SecretMutation) ClearEdge(name string) error {
	switch name {
	case secret.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown Secret unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SecretMutation) ResetEdge(name string) error {
	switch name {
	case secret.EdgeProject:
		m.ResetProject()
		return nil
	}
	return fmt.Errorf("unknown Secret edge %s", name)
}

// ThirdPartyAuthMutation represents an operation that mutates the ThirdPartyAuth nodes in the graph.
type ThirdPartyAuthMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	oidc_issuer_url     *string
	jwks_url            *string
	custom_jwks         **api.CreateThirdPartyAuthBodyCustomJwks
	clearedFields       map[string]struct{}
	organization        *int
	clearedorganization bool
	done                bool
	oldValue            func(context.Context) (*ThirdPartyAuth, error)
	predicates          []predicate.ThirdPartyAuth
}

var _ ent.Mutation = (*ThirdPartyAuthMutation)(nil)

// thirdpartyauthOption allows management of the mutation configuration using functional options.
type thirdpartyauthOption func(*ThirdPartyAuthMutation)

// newThirdPartyAuthMutation creates new mutation for the ThirdPartyAuth entity.
func newThirdPartyAuthMutation(c config, op Op, opts ...thirdpartyauthOption) *ThirdPartyAuthMutation {
	m := &ThirdPartyAuthMutation{
		config:        c,
		op:            op,
		typ:           TypeThirdPartyAuth,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withThirdPartyAuthID sets the ID field of the mutation.
func withThirdPartyAuthID(id int) thirdpartyauthOption {
	return func(m *ThirdPartyAuthMutation) {
		var (
			err   error
			once  sync.Once
			value *ThirdPartyAuth
		)
		m.oldValue = func(ctx context.Context) (*ThirdPartyAuth, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ThirdPartyAuth.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withThirdPartyAuth sets the old ThirdPartyAuth of the mutation.
func withThirdPartyAuth(node *ThirdPartyAuth) thirdpartyauthOption {
	return func(m *ThirdPartyAuthMutation) {
		m.oldValue = func(context.Context) (*ThirdPartyAuth, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ThirdPartyAuthMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ThirdPartyAuthMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ThirdPartyAuthMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ThirdPartyAuthMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ThirdPartyAuth.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOidcIssuerURL sets the "oidc_issuer_url" field.
func (m *ThirdPartyAuthMutation) SetOidcIssuerURL(s string) {
	m.oidc_issuer_url = &s
}

// OidcIssuerURL returns the value of the "oidc_issuer_url" field in the mutation.
func (m *ThirdPartyAuthMutation) OidcIssuerURL() (r string, exists bool) {
	v := m.oidc_issuer_url
	if v == nil {
		return
	}
	return *v, true
}

// OldOidcIssuerURL returns the old "oidc_issuer_url" field's value of the ThirdPartyAuth entity.
// If the ThirdPartyAuth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThirdPartyAuthMutation) OldOidcIssuerURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOidcIssuerURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOidcIssuerURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOidcIssuerURL: %w", err)
	}
	return oldValue.OidcIssuerURL, nil
}

// ClearOidcIssuerURL clears the value of the "oidc_issuer_url" field.
func (m *ThirdPartyAuthMutation) ClearOidcIssuerURL() {
	m.oidc_issuer_url = nil
	m.clearedFields[thirdpartyauth.FieldOidcIssuerURL] = struct{}{}
}

// OidcIssuerURLCleared returns if the "oidc_issuer_url" field was cleared in this mutation.
func (m *ThirdPartyAuthMutation) OidcIssuerURLCleared() bool {
	_, ok := m.clearedFields[thirdpartyauth.FieldOidcIssuerURL]
	return ok
}

// ResetOidcIssuerURL resets all changes to the "oidc_issuer_url" field.
func (m *ThirdPartyAuthMutation) ResetOidcIssuerURL() {
	m.oidc_issuer_url = nil
	delete(m.clearedFields, thirdpartyauth.FieldOidcIssuerURL)
}

// SetJwksURL sets the "jwks_url" field.
func (m *ThirdPartyAuthMutation) SetJwksURL(s string) {
	m.jwks_url = &s
}

// JwksURL returns the value of the "jwks_url" field in the mutation.
func (m *ThirdPartyAuthMutation) JwksURL() (r string, exists bool) {
	v := m.jwks_url
	if v == nil {
		return
	}
	return *v, true
}

// OldJwksURL returns the old "jwks_url" field's value of the ThirdPartyAuth entity.
// If the ThirdPartyAuth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThirdPartyAuthMutation) OldJwksURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJwksURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJwksURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJwksURL: %w", err)
	}
	return oldValue.JwksURL, nil
}

// ClearJwksURL clears the value of the "jwks_url" field.
func (m *ThirdPartyAuthMutation) ClearJwksURL() {
	m.jwks_url = nil
	m.clearedFields[thirdpartyauth.FieldJwksURL] = struct{}{}
}

// JwksURLCleared returns if the "jwks_url" field was cleared in this mutation.
func (m *ThirdPartyAuthMutation) JwksURLCleared() bool {
	_, ok := m.clearedFields[thirdpartyauth.FieldJwksURL]
	return ok
}

// ResetJwksURL resets all changes to the "jwks_url" field.
func (m *ThirdPartyAuthMutation) ResetJwksURL() {
	m.jwks_url = nil
	delete(m.clearedFields, thirdpartyauth.FieldJwksURL)
}

// SetCustomJwks sets the "custom_jwks" field.
func (m *ThirdPartyAuthMutation) SetCustomJwks(atpabcj *api.CreateThirdPartyAuthBodyCustomJwks) {
	m.custom_jwks = &atpabcj
}

// CustomJwks returns the value of the "custom_jwks" field in the mutation.
func (m *ThirdPartyAuthMutation) CustomJwks() (r *api.CreateThirdPartyAuthBodyCustomJwks, exists bool) {
	v := m.custom_jwks
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomJwks returns the old "custom_jwks" field's value of the ThirdPartyAuth entity.
// If the ThirdPartyAuth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThirdPartyAuthMutation) OldCustomJwks(ctx context.Context) (v *api.CreateThirdPartyAuthBodyCustomJwks, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomJwks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomJwks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomJwks: %w", err)
	}
	return oldValue.CustomJwks, nil
}

// ClearCustomJwks clears the value of the "custom_jwks" field.
func (m *ThirdPartyAuthMutation) ClearCustomJwks() {
	m.custom_jwks = nil
	m.clearedFields[thirdpartyauth.FieldCustomJwks] = struct{}{}
}

// CustomJwksCleared returns if the "custom_jwks" field was cleared in this mutation.
func (m *ThirdPartyAuthMutation) CustomJwksCleared() bool {
	_, ok := m.clearedFields[thirdpartyauth.FieldCustomJwks]
	return ok
}

// ResetCustomJwks resets all changes to the "custom_jwks" field.
func (m *ThirdPartyAuthMutation) ResetCustomJwks() {
	m.custom_jwks = nil
	delete(m.clearedFields, thirdpartyauth.FieldCustomJwks)
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *ThirdPartyAuthMutation) SetOrganizationID(id int) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *ThirdPartyAuthMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *ThirdPartyAuthMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *ThirdPartyAuthMutation) OrganizationID() (id int, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *ThirdPartyAuthMutation) OrganizationIDs() (ids []int) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *ThirdPartyAuthMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the ThirdPartyAuthMutation builder.
func (m *ThirdPartyAuthMutation) Where(ps ...predicate.ThirdPartyAuth) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ThirdPartyAuthMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ThirdPartyAuthMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ThirdPartyAuth, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ThirdPartyAuthMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ThirdPartyAuthMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ThirdPartyAuth).
func (m *ThirdPartyAuthMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ThirdPartyAuthMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.oidc_issuer_url != nil {
		fields = append(fields, thirdpartyauth.FieldOidcIssuerURL)
	}
	if m.jwks_url != nil {
		fields = append(fields, thirdpartyauth.FieldJwksURL)
	}
	if m.custom_jwks != nil {
		fields = append(fields, thirdpartyauth.FieldCustomJwks)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ThirdPartyAuthMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case thirdpartyauth.FieldOidcIssuerURL:
		return m.OidcIssuerURL()
	case thirdpartyauth.FieldJwksURL:
		return m.JwksURL()
	case thirdpartyauth.FieldCustomJwks:
		return m.CustomJwks()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ThirdPartyAuthMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case thirdpartyauth.FieldOidcIssuerURL:
		return m.OldOidcIssuerURL(ctx)
	case thirdpartyauth.FieldJwksURL:
		return m.OldJwksURL(ctx)
	case thirdpartyauth.FieldCustomJwks:
		return m.OldCustomJwks(ctx)
	}
	return nil, fmt.Errorf("unknown ThirdPartyAuth field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThirdPartyAuthMutation) SetField(name string, value ent.Value) error {
	switch name {
	case thirdpartyauth.FieldOidcIssuerURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOidcIssuerURL(v)
		return nil
	case thirdpartyauth.FieldJwksURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJwksURL(v)
		return nil
	case thirdpartyauth.FieldCustomJwks:
		v, ok := value.(*api.CreateThirdPartyAuthBodyCustomJwks)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomJwks(v)
		return nil
	}
	return fmt.Errorf("unknown ThirdPartyAuth field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ThirdPartyAuthMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ThirdPartyAuthMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThirdPartyAuthMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ThirdPartyAuth numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ThirdPartyAuthMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(thirdpartyauth.FieldOidcIssuerURL) {
		fields = append(fields, thirdpartyauth.FieldOidcIssuerURL)
	}
	if m.FieldCleared(thirdpartyauth.FieldJwksURL) {
		fields = append(fields, thirdpartyauth.FieldJwksURL)
	}
	if m.FieldCleared(thirdpartyauth.FieldCustomJwks) {
		fields = append(fields, thirdpartyauth.FieldCustomJwks)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ThirdPartyAuthMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ThirdPartyAuthMutation) ClearField(name string) error {
	switch name {
	case thirdpartyauth.FieldOidcIssuerURL:
		m.ClearOidcIssuerURL()
		return nil
	case thirdpartyauth.FieldJwksURL:
		m.ClearJwksURL()
		return nil
	case thirdpartyauth.FieldCustomJwks:
		m.ClearCustomJwks()
		return nil
	}
	return fmt.Errorf("unknown ThirdPartyAuth nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ThirdPartyAuthMutation) ResetField(name string) error {
	switch name {
	case thirdpartyauth.FieldOidcIssuerURL:
		m.ResetOidcIssuerURL()
		return nil
	case thirdpartyauth.FieldJwksURL:
		m.ResetJwksURL()
		return nil
	case thirdpartyauth.FieldCustomJwks:
		m.ResetCustomJwks()
		return nil
	}
	return fmt.Errorf("unknown ThirdPartyAuth field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ThirdPartyAuthMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.organization != nil {
		edges = append(edges, thirdpartyauth.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ThirdPartyAuthMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case thirdpartyauth.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ThirdPartyAuthMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ThirdPartyAuthMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ThirdPartyAuthMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedorganization {
		edges = append(edges, thirdpartyauth.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ThirdPartyAuthMutation) EdgeCleared(name string) bool {
	switch name {
	case thirdpartyauth.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ThirdPartyAuthMutation) ClearEdge(name string) error {
	switch name {
	case thirdpartyauth.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown ThirdPartyAuth unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ThirdPartyAuthMutation) ResetEdge(name string) error {
	switch name {
	case thirdpartyauth.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown ThirdPartyAuth edge %s", name)
}

// TypeScriptTypeMutation represents an operation that mutates the TypeScriptType nodes in the graph.
type TypeScriptTypeMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	name           *string
	definition     *string
	clearedFields  map[string]struct{}
	project        *uuid.UUID
	clearedproject bool
	done           bool
	oldValue       func(context.Context) (*TypeScriptType, error)
	predicates     []predicate.TypeScriptType
}

var _ ent.Mutation = (*TypeScriptTypeMutation)(nil)

// typescripttypeOption allows management of the mutation configuration using functional options.
type typescripttypeOption func(*TypeScriptTypeMutation)

// newTypeScriptTypeMutation creates new mutation for the TypeScriptType entity.
func newTypeScriptTypeMutation(c config, op Op, opts ...typescripttypeOption) *TypeScriptTypeMutation {
	m := &TypeScriptTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeTypeScriptType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTypeScriptTypeID sets the ID field of the mutation.
func withTypeScriptTypeID(id uuid.UUID) typescripttypeOption {
	return func(m *TypeScriptTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *TypeScriptType
		)
		m.oldValue = func(ctx context.Context) (*TypeScriptType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TypeScriptType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTypeScriptType sets the old TypeScriptType of the mutation.
func withTypeScriptType(node *TypeScriptType) typescripttypeOption {
	return func(m *TypeScriptTypeMutation) {
		m.oldValue = func(context.Context) (*TypeScriptType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TypeScriptTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TypeScriptTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TypeScriptType entities.
func (m *TypeScriptTypeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TypeScriptTypeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TypeScriptTypeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TypeScriptType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProjectID sets the "project_id" field.
func (m *TypeScriptTypeMutation) SetProjectID(u uuid.UUID) {
	m.project = &u
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *TypeScriptTypeMutation) ProjectID() (r uuid.UUID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the TypeScriptType entity.
// If the TypeScriptType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TypeScriptTypeMutation) OldProjectID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *TypeScriptTypeMutation) ResetProjectID() {
	m.project = nil
}

// SetName sets the "name" field.
func (m *TypeScriptTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TypeScriptTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TypeScriptType entity.
// If the TypeScriptType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TypeScriptTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TypeScriptTypeMutation) ResetName() {
	m.name = nil
}

// SetDefinition sets the "definition" field.
func (m *TypeScriptTypeMutation) SetDefinition(s string) {
	m.definition = &s
}

// Definition returns the value of the "definition" field in the mutation.
func (m *TypeScriptTypeMutation) Definition() (r string, exists bool) {
	v := m.definition
	if v == nil {
		return
	}
	return *v, true
}

// OldDefinition returns the old "definition" field's value of the TypeScriptType entity.
// If the TypeScriptType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TypeScriptTypeMutation) OldDefinition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefinition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefinition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefinition: %w", err)
	}
	return oldValue.Definition, nil
}

// ResetDefinition resets all changes to the "definition" field.
func (m *TypeScriptTypeMutation) ResetDefinition() {
	m.definition = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *TypeScriptTypeMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[typescripttype.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *TypeScriptTypeMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *TypeScriptTypeMutation) ProjectIDs() (ids []uuid.UUID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *TypeScriptTypeMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// Where appends a list predicates to the TypeScriptTypeMutation builder.
func (m *TypeScriptTypeMutation) Where(ps ...predicate.TypeScriptType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TypeScriptTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TypeScriptTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TypeScriptType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TypeScriptTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TypeScriptTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TypeScriptType).
func (m *TypeScriptTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TypeScriptTypeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.project != nil {
		fields = append(fields, typescripttype.FieldProjectID)
	}
	if m.name != nil {
		fields = append(fields, typescripttype.FieldName)
	}
	if m.definition != nil {
		fields = append(fields, typescripttype.FieldDefinition)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TypeScriptTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case typescripttype.FieldProjectID:
		return m.ProjectID()
	case typescripttype.FieldName:
		return m.Name()
	case typescripttype.FieldDefinition:
		return m.Definition()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TypeScriptTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case typescripttype.FieldProjectID:
		return m.OldProjectID(ctx)
	case typescripttype.FieldName:
		return m.OldName(ctx)
	case typescripttype.FieldDefinition:
		return m.OldDefinition(ctx)
	}
	return nil, fmt.Errorf("unknown TypeScriptType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TypeScriptTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case typescripttype.FieldProjectID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case typescripttype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case typescripttype.FieldDefinition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefinition(v)
		return nil
	}
	return fmt.Errorf("unknown TypeScriptType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TypeScriptTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TypeScriptTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TypeScriptTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TypeScriptType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TypeScriptTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TypeScriptTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TypeScriptTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TypeScriptType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TypeScriptTypeMutation) ResetField(name string) error {
	switch name {
	case typescripttype.FieldProjectID:
		m.ResetProjectID()
		return nil
	case typescripttype.FieldName:
		m.ResetName()
		return nil
	case typescripttype.FieldDefinition:
		m.ResetDefinition()
		return nil
	}
	return fmt.Errorf("unknown TypeScriptType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TypeScriptTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.project != nil {
		edges = append(edges, typescripttype.EdgeProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TypeScriptTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case typescripttype.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TypeScriptTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TypeScriptTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TypeScriptTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproject {
		edges = append(edges, typescripttype.EdgeProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TypeScriptTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case typescripttype.EdgeProject:
		return m.clearedproject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TypeScriptTypeMutation) ClearEdge(name string) error {
	switch name {
	case typescripttype.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown TypeScriptType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TypeScriptTypeMutation) ResetEdge(name string) error {
	switch name {
	case typescripttype.EdgeProject:
		m.ResetProject()
		return nil
	}
	return fmt.Errorf("unknown TypeScriptType edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}
