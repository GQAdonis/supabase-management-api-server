// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/google/uuid"
	"tribemedia.io/m/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"tribemedia.io/m/ent/authconfig"
	"tribemedia.io/m/ent/branch"
	"tribemedia.io/m/ent/customhostname"
	"tribemedia.io/m/ent/function"
	"tribemedia.io/m/ent/networkban"
	"tribemedia.io/m/ent/organization"
	"tribemedia.io/m/ent/pgsodiumconfig"
	"tribemedia.io/m/ent/project"
	"tribemedia.io/m/ent/provider"
	"tribemedia.io/m/ent/secret"
	"tribemedia.io/m/ent/thirdpartyauth"
	"tribemedia.io/m/ent/typescripttype"
	"tribemedia.io/m/ent/user"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AuthConfig is the client for interacting with the AuthConfig builders.
	AuthConfig *AuthConfigClient
	// Branch is the client for interacting with the Branch builders.
	Branch *BranchClient
	// CustomHostname is the client for interacting with the CustomHostname builders.
	CustomHostname *CustomHostnameClient
	// Function is the client for interacting with the Function builders.
	Function *FunctionClient
	// NetworkBan is the client for interacting with the NetworkBan builders.
	NetworkBan *NetworkBanClient
	// Organization is the client for interacting with the Organization builders.
	Organization *OrganizationClient
	// PgsodiumConfig is the client for interacting with the PgsodiumConfig builders.
	PgsodiumConfig *PgsodiumConfigClient
	// Project is the client for interacting with the Project builders.
	Project *ProjectClient
	// Provider is the client for interacting with the Provider builders.
	Provider *ProviderClient
	// Secret is the client for interacting with the Secret builders.
	Secret *SecretClient
	// ThirdPartyAuth is the client for interacting with the ThirdPartyAuth builders.
	ThirdPartyAuth *ThirdPartyAuthClient
	// TypeScriptType is the client for interacting with the TypeScriptType builders.
	TypeScriptType *TypeScriptTypeClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AuthConfig = NewAuthConfigClient(c.config)
	c.Branch = NewBranchClient(c.config)
	c.CustomHostname = NewCustomHostnameClient(c.config)
	c.Function = NewFunctionClient(c.config)
	c.NetworkBan = NewNetworkBanClient(c.config)
	c.Organization = NewOrganizationClient(c.config)
	c.PgsodiumConfig = NewPgsodiumConfigClient(c.config)
	c.Project = NewProjectClient(c.config)
	c.Provider = NewProviderClient(c.config)
	c.Secret = NewSecretClient(c.config)
	c.ThirdPartyAuth = NewThirdPartyAuthClient(c.config)
	c.TypeScriptType = NewTypeScriptTypeClient(c.config)
	c.User = NewUserClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:            ctx,
		config:         cfg,
		AuthConfig:     NewAuthConfigClient(cfg),
		Branch:         NewBranchClient(cfg),
		CustomHostname: NewCustomHostnameClient(cfg),
		Function:       NewFunctionClient(cfg),
		NetworkBan:     NewNetworkBanClient(cfg),
		Organization:   NewOrganizationClient(cfg),
		PgsodiumConfig: NewPgsodiumConfigClient(cfg),
		Project:        NewProjectClient(cfg),
		Provider:       NewProviderClient(cfg),
		Secret:         NewSecretClient(cfg),
		ThirdPartyAuth: NewThirdPartyAuthClient(cfg),
		TypeScriptType: NewTypeScriptTypeClient(cfg),
		User:           NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:            ctx,
		config:         cfg,
		AuthConfig:     NewAuthConfigClient(cfg),
		Branch:         NewBranchClient(cfg),
		CustomHostname: NewCustomHostnameClient(cfg),
		Function:       NewFunctionClient(cfg),
		NetworkBan:     NewNetworkBanClient(cfg),
		Organization:   NewOrganizationClient(cfg),
		PgsodiumConfig: NewPgsodiumConfigClient(cfg),
		Project:        NewProjectClient(cfg),
		Provider:       NewProviderClient(cfg),
		Secret:         NewSecretClient(cfg),
		ThirdPartyAuth: NewThirdPartyAuthClient(cfg),
		TypeScriptType: NewTypeScriptTypeClient(cfg),
		User:           NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AuthConfig.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AuthConfig, c.Branch, c.CustomHostname, c.Function, c.NetworkBan,
		c.Organization, c.PgsodiumConfig, c.Project, c.Provider, c.Secret,
		c.ThirdPartyAuth, c.TypeScriptType, c.User,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AuthConfig, c.Branch, c.CustomHostname, c.Function, c.NetworkBan,
		c.Organization, c.PgsodiumConfig, c.Project, c.Provider, c.Secret,
		c.ThirdPartyAuth, c.TypeScriptType, c.User,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AuthConfigMutation:
		return c.AuthConfig.mutate(ctx, m)
	case *BranchMutation:
		return c.Branch.mutate(ctx, m)
	case *CustomHostnameMutation:
		return c.CustomHostname.mutate(ctx, m)
	case *FunctionMutation:
		return c.Function.mutate(ctx, m)
	case *NetworkBanMutation:
		return c.NetworkBan.mutate(ctx, m)
	case *OrganizationMutation:
		return c.Organization.mutate(ctx, m)
	case *PgsodiumConfigMutation:
		return c.PgsodiumConfig.mutate(ctx, m)
	case *ProjectMutation:
		return c.Project.mutate(ctx, m)
	case *ProviderMutation:
		return c.Provider.mutate(ctx, m)
	case *SecretMutation:
		return c.Secret.mutate(ctx, m)
	case *ThirdPartyAuthMutation:
		return c.ThirdPartyAuth.mutate(ctx, m)
	case *TypeScriptTypeMutation:
		return c.TypeScriptType.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AuthConfigClient is a client for the AuthConfig schema.
type AuthConfigClient struct {
	config
}

// NewAuthConfigClient returns a client for the AuthConfig from the given config.
func NewAuthConfigClient(c config) *AuthConfigClient {
	return &AuthConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authconfig.Hooks(f(g(h())))`.
func (c *AuthConfigClient) Use(hooks ...Hook) {
	c.hooks.AuthConfig = append(c.hooks.AuthConfig, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `authconfig.Intercept(f(g(h())))`.
func (c *AuthConfigClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuthConfig = append(c.inters.AuthConfig, interceptors...)
}

// Create returns a builder for creating a AuthConfig entity.
func (c *AuthConfigClient) Create() *AuthConfigCreate {
	mutation := newAuthConfigMutation(c.config, OpCreate)
	return &AuthConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthConfig entities.
func (c *AuthConfigClient) CreateBulk(builders ...*AuthConfigCreate) *AuthConfigCreateBulk {
	return &AuthConfigCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuthConfigClient) MapCreateBulk(slice any, setFunc func(*AuthConfigCreate, int)) *AuthConfigCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuthConfigCreateBulk{err: fmt.Errorf("calling to AuthConfigClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuthConfigCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuthConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthConfig.
func (c *AuthConfigClient) Update() *AuthConfigUpdate {
	mutation := newAuthConfigMutation(c.config, OpUpdate)
	return &AuthConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthConfigClient) UpdateOne(ac *AuthConfig) *AuthConfigUpdateOne {
	mutation := newAuthConfigMutation(c.config, OpUpdateOne, withAuthConfig(ac))
	return &AuthConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthConfigClient) UpdateOneID(id uuid.UUID) *AuthConfigUpdateOne {
	mutation := newAuthConfigMutation(c.config, OpUpdateOne, withAuthConfigID(id))
	return &AuthConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthConfig.
func (c *AuthConfigClient) Delete() *AuthConfigDelete {
	mutation := newAuthConfigMutation(c.config, OpDelete)
	return &AuthConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuthConfigClient) DeleteOne(ac *AuthConfig) *AuthConfigDeleteOne {
	return c.DeleteOneID(ac.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuthConfigClient) DeleteOneID(id uuid.UUID) *AuthConfigDeleteOne {
	builder := c.Delete().Where(authconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthConfigDeleteOne{builder}
}

// Query returns a query builder for AuthConfig.
func (c *AuthConfigClient) Query() *AuthConfigQuery {
	return &AuthConfigQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuthConfig},
		inters: c.Interceptors(),
	}
}

// Get returns a AuthConfig entity by its id.
func (c *AuthConfigClient) Get(ctx context.Context, id uuid.UUID) (*AuthConfig, error) {
	return c.Query().Where(authconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthConfigClient) GetX(ctx context.Context, id uuid.UUID) *AuthConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a AuthConfig.
func (c *AuthConfigClient) QueryProject(ac *AuthConfig) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ac.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(authconfig.Table, authconfig.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, authconfig.ProjectTable, authconfig.ProjectColumn),
		)
		fromV = sqlgraph.Neighbors(ac.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AuthConfigClient) Hooks() []Hook {
	return c.hooks.AuthConfig
}

// Interceptors returns the client interceptors.
func (c *AuthConfigClient) Interceptors() []Interceptor {
	return c.inters.AuthConfig
}

func (c *AuthConfigClient) mutate(ctx context.Context, m *AuthConfigMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuthConfigCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuthConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuthConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuthConfigDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuthConfig mutation op: %q", m.Op())
	}
}

// BranchClient is a client for the Branch schema.
type BranchClient struct {
	config
}

// NewBranchClient returns a client for the Branch from the given config.
func NewBranchClient(c config) *BranchClient {
	return &BranchClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `branch.Hooks(f(g(h())))`.
func (c *BranchClient) Use(hooks ...Hook) {
	c.hooks.Branch = append(c.hooks.Branch, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `branch.Intercept(f(g(h())))`.
func (c *BranchClient) Intercept(interceptors ...Interceptor) {
	c.inters.Branch = append(c.inters.Branch, interceptors...)
}

// Create returns a builder for creating a Branch entity.
func (c *BranchClient) Create() *BranchCreate {
	mutation := newBranchMutation(c.config, OpCreate)
	return &BranchCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Branch entities.
func (c *BranchClient) CreateBulk(builders ...*BranchCreate) *BranchCreateBulk {
	return &BranchCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BranchClient) MapCreateBulk(slice any, setFunc func(*BranchCreate, int)) *BranchCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BranchCreateBulk{err: fmt.Errorf("calling to BranchClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BranchCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BranchCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Branch.
func (c *BranchClient) Update() *BranchUpdate {
	mutation := newBranchMutation(c.config, OpUpdate)
	return &BranchUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BranchClient) UpdateOne(b *Branch) *BranchUpdateOne {
	mutation := newBranchMutation(c.config, OpUpdateOne, withBranch(b))
	return &BranchUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BranchClient) UpdateOneID(id uuid.UUID) *BranchUpdateOne {
	mutation := newBranchMutation(c.config, OpUpdateOne, withBranchID(id))
	return &BranchUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Branch.
func (c *BranchClient) Delete() *BranchDelete {
	mutation := newBranchMutation(c.config, OpDelete)
	return &BranchDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BranchClient) DeleteOne(b *Branch) *BranchDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BranchClient) DeleteOneID(id uuid.UUID) *BranchDeleteOne {
	builder := c.Delete().Where(branch.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BranchDeleteOne{builder}
}

// Query returns a query builder for Branch.
func (c *BranchClient) Query() *BranchQuery {
	return &BranchQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBranch},
		inters: c.Interceptors(),
	}
}

// Get returns a Branch entity by its id.
func (c *BranchClient) Get(ctx context.Context, id uuid.UUID) (*Branch, error) {
	return c.Query().Where(branch.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BranchClient) GetX(ctx context.Context, id uuid.UUID) *Branch {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a Branch.
func (c *BranchClient) QueryProject(b *Branch) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(branch.Table, branch.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, branch.ProjectTable, branch.ProjectColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParentProject queries the parentProject edge of a Branch.
func (c *BranchClient) QueryParentProject(b *Branch) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(branch.Table, branch.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, branch.ParentProjectTable, branch.ParentProjectColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BranchClient) Hooks() []Hook {
	return c.hooks.Branch
}

// Interceptors returns the client interceptors.
func (c *BranchClient) Interceptors() []Interceptor {
	return c.inters.Branch
}

func (c *BranchClient) mutate(ctx context.Context, m *BranchMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BranchCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BranchUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BranchUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BranchDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Branch mutation op: %q", m.Op())
	}
}

// CustomHostnameClient is a client for the CustomHostname schema.
type CustomHostnameClient struct {
	config
}

// NewCustomHostnameClient returns a client for the CustomHostname from the given config.
func NewCustomHostnameClient(c config) *CustomHostnameClient {
	return &CustomHostnameClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `customhostname.Hooks(f(g(h())))`.
func (c *CustomHostnameClient) Use(hooks ...Hook) {
	c.hooks.CustomHostname = append(c.hooks.CustomHostname, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `customhostname.Intercept(f(g(h())))`.
func (c *CustomHostnameClient) Intercept(interceptors ...Interceptor) {
	c.inters.CustomHostname = append(c.inters.CustomHostname, interceptors...)
}

// Create returns a builder for creating a CustomHostname entity.
func (c *CustomHostnameClient) Create() *CustomHostnameCreate {
	mutation := newCustomHostnameMutation(c.config, OpCreate)
	return &CustomHostnameCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CustomHostname entities.
func (c *CustomHostnameClient) CreateBulk(builders ...*CustomHostnameCreate) *CustomHostnameCreateBulk {
	return &CustomHostnameCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CustomHostnameClient) MapCreateBulk(slice any, setFunc func(*CustomHostnameCreate, int)) *CustomHostnameCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CustomHostnameCreateBulk{err: fmt.Errorf("calling to CustomHostnameClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CustomHostnameCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CustomHostnameCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CustomHostname.
func (c *CustomHostnameClient) Update() *CustomHostnameUpdate {
	mutation := newCustomHostnameMutation(c.config, OpUpdate)
	return &CustomHostnameUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CustomHostnameClient) UpdateOne(ch *CustomHostname) *CustomHostnameUpdateOne {
	mutation := newCustomHostnameMutation(c.config, OpUpdateOne, withCustomHostname(ch))
	return &CustomHostnameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CustomHostnameClient) UpdateOneID(id uuid.UUID) *CustomHostnameUpdateOne {
	mutation := newCustomHostnameMutation(c.config, OpUpdateOne, withCustomHostnameID(id))
	return &CustomHostnameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CustomHostname.
func (c *CustomHostnameClient) Delete() *CustomHostnameDelete {
	mutation := newCustomHostnameMutation(c.config, OpDelete)
	return &CustomHostnameDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CustomHostnameClient) DeleteOne(ch *CustomHostname) *CustomHostnameDeleteOne {
	return c.DeleteOneID(ch.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CustomHostnameClient) DeleteOneID(id uuid.UUID) *CustomHostnameDeleteOne {
	builder := c.Delete().Where(customhostname.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CustomHostnameDeleteOne{builder}
}

// Query returns a query builder for CustomHostname.
func (c *CustomHostnameClient) Query() *CustomHostnameQuery {
	return &CustomHostnameQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCustomHostname},
		inters: c.Interceptors(),
	}
}

// Get returns a CustomHostname entity by its id.
func (c *CustomHostnameClient) Get(ctx context.Context, id uuid.UUID) (*CustomHostname, error) {
	return c.Query().Where(customhostname.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CustomHostnameClient) GetX(ctx context.Context, id uuid.UUID) *CustomHostname {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a CustomHostname.
func (c *CustomHostnameClient) QueryProject(ch *CustomHostname) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ch.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customhostname.Table, customhostname.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, customhostname.ProjectTable, customhostname.ProjectColumn),
		)
		fromV = sqlgraph.Neighbors(ch.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CustomHostnameClient) Hooks() []Hook {
	return c.hooks.CustomHostname
}

// Interceptors returns the client interceptors.
func (c *CustomHostnameClient) Interceptors() []Interceptor {
	return c.inters.CustomHostname
}

func (c *CustomHostnameClient) mutate(ctx context.Context, m *CustomHostnameMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CustomHostnameCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CustomHostnameUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CustomHostnameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CustomHostnameDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CustomHostname mutation op: %q", m.Op())
	}
}

// FunctionClient is a client for the Function schema.
type FunctionClient struct {
	config
}

// NewFunctionClient returns a client for the Function from the given config.
func NewFunctionClient(c config) *FunctionClient {
	return &FunctionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `function.Hooks(f(g(h())))`.
func (c *FunctionClient) Use(hooks ...Hook) {
	c.hooks.Function = append(c.hooks.Function, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `function.Intercept(f(g(h())))`.
func (c *FunctionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Function = append(c.inters.Function, interceptors...)
}

// Create returns a builder for creating a Function entity.
func (c *FunctionClient) Create() *FunctionCreate {
	mutation := newFunctionMutation(c.config, OpCreate)
	return &FunctionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Function entities.
func (c *FunctionClient) CreateBulk(builders ...*FunctionCreate) *FunctionCreateBulk {
	return &FunctionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FunctionClient) MapCreateBulk(slice any, setFunc func(*FunctionCreate, int)) *FunctionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FunctionCreateBulk{err: fmt.Errorf("calling to FunctionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FunctionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FunctionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Function.
func (c *FunctionClient) Update() *FunctionUpdate {
	mutation := newFunctionMutation(c.config, OpUpdate)
	return &FunctionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FunctionClient) UpdateOne(f *Function) *FunctionUpdateOne {
	mutation := newFunctionMutation(c.config, OpUpdateOne, withFunction(f))
	return &FunctionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FunctionClient) UpdateOneID(id uuid.UUID) *FunctionUpdateOne {
	mutation := newFunctionMutation(c.config, OpUpdateOne, withFunctionID(id))
	return &FunctionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Function.
func (c *FunctionClient) Delete() *FunctionDelete {
	mutation := newFunctionMutation(c.config, OpDelete)
	return &FunctionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FunctionClient) DeleteOne(f *Function) *FunctionDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FunctionClient) DeleteOneID(id uuid.UUID) *FunctionDeleteOne {
	builder := c.Delete().Where(function.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FunctionDeleteOne{builder}
}

// Query returns a query builder for Function.
func (c *FunctionClient) Query() *FunctionQuery {
	return &FunctionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFunction},
		inters: c.Interceptors(),
	}
}

// Get returns a Function entity by its id.
func (c *FunctionClient) Get(ctx context.Context, id uuid.UUID) (*Function, error) {
	return c.Query().Where(function.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FunctionClient) GetX(ctx context.Context, id uuid.UUID) *Function {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a Function.
func (c *FunctionClient) QueryProject(f *Function) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(function.Table, function.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, function.ProjectTable, function.ProjectColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FunctionClient) Hooks() []Hook {
	return c.hooks.Function
}

// Interceptors returns the client interceptors.
func (c *FunctionClient) Interceptors() []Interceptor {
	return c.inters.Function
}

func (c *FunctionClient) mutate(ctx context.Context, m *FunctionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FunctionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FunctionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FunctionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FunctionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Function mutation op: %q", m.Op())
	}
}

// NetworkBanClient is a client for the NetworkBan schema.
type NetworkBanClient struct {
	config
}

// NewNetworkBanClient returns a client for the NetworkBan from the given config.
func NewNetworkBanClient(c config) *NetworkBanClient {
	return &NetworkBanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `networkban.Hooks(f(g(h())))`.
func (c *NetworkBanClient) Use(hooks ...Hook) {
	c.hooks.NetworkBan = append(c.hooks.NetworkBan, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `networkban.Intercept(f(g(h())))`.
func (c *NetworkBanClient) Intercept(interceptors ...Interceptor) {
	c.inters.NetworkBan = append(c.inters.NetworkBan, interceptors...)
}

// Create returns a builder for creating a NetworkBan entity.
func (c *NetworkBanClient) Create() *NetworkBanCreate {
	mutation := newNetworkBanMutation(c.config, OpCreate)
	return &NetworkBanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of NetworkBan entities.
func (c *NetworkBanClient) CreateBulk(builders ...*NetworkBanCreate) *NetworkBanCreateBulk {
	return &NetworkBanCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NetworkBanClient) MapCreateBulk(slice any, setFunc func(*NetworkBanCreate, int)) *NetworkBanCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NetworkBanCreateBulk{err: fmt.Errorf("calling to NetworkBanClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NetworkBanCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NetworkBanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for NetworkBan.
func (c *NetworkBanClient) Update() *NetworkBanUpdate {
	mutation := newNetworkBanMutation(c.config, OpUpdate)
	return &NetworkBanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NetworkBanClient) UpdateOne(nb *NetworkBan) *NetworkBanUpdateOne {
	mutation := newNetworkBanMutation(c.config, OpUpdateOne, withNetworkBan(nb))
	return &NetworkBanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NetworkBanClient) UpdateOneID(id uuid.UUID) *NetworkBanUpdateOne {
	mutation := newNetworkBanMutation(c.config, OpUpdateOne, withNetworkBanID(id))
	return &NetworkBanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for NetworkBan.
func (c *NetworkBanClient) Delete() *NetworkBanDelete {
	mutation := newNetworkBanMutation(c.config, OpDelete)
	return &NetworkBanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NetworkBanClient) DeleteOne(nb *NetworkBan) *NetworkBanDeleteOne {
	return c.DeleteOneID(nb.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NetworkBanClient) DeleteOneID(id uuid.UUID) *NetworkBanDeleteOne {
	builder := c.Delete().Where(networkban.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NetworkBanDeleteOne{builder}
}

// Query returns a query builder for NetworkBan.
func (c *NetworkBanClient) Query() *NetworkBanQuery {
	return &NetworkBanQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNetworkBan},
		inters: c.Interceptors(),
	}
}

// Get returns a NetworkBan entity by its id.
func (c *NetworkBanClient) Get(ctx context.Context, id uuid.UUID) (*NetworkBan, error) {
	return c.Query().Where(networkban.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NetworkBanClient) GetX(ctx context.Context, id uuid.UUID) *NetworkBan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a NetworkBan.
func (c *NetworkBanClient) QueryProject(nb *NetworkBan) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := nb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(networkban.Table, networkban.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, networkban.ProjectTable, networkban.ProjectColumn),
		)
		fromV = sqlgraph.Neighbors(nb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NetworkBanClient) Hooks() []Hook {
	return c.hooks.NetworkBan
}

// Interceptors returns the client interceptors.
func (c *NetworkBanClient) Interceptors() []Interceptor {
	return c.inters.NetworkBan
}

func (c *NetworkBanClient) mutate(ctx context.Context, m *NetworkBanMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NetworkBanCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NetworkBanUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NetworkBanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NetworkBanDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown NetworkBan mutation op: %q", m.Op())
	}
}

// OrganizationClient is a client for the Organization schema.
type OrganizationClient struct {
	config
}

// NewOrganizationClient returns a client for the Organization from the given config.
func NewOrganizationClient(c config) *OrganizationClient {
	return &OrganizationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `organization.Hooks(f(g(h())))`.
func (c *OrganizationClient) Use(hooks ...Hook) {
	c.hooks.Organization = append(c.hooks.Organization, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `organization.Intercept(f(g(h())))`.
func (c *OrganizationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Organization = append(c.inters.Organization, interceptors...)
}

// Create returns a builder for creating a Organization entity.
func (c *OrganizationClient) Create() *OrganizationCreate {
	mutation := newOrganizationMutation(c.config, OpCreate)
	return &OrganizationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Organization entities.
func (c *OrganizationClient) CreateBulk(builders ...*OrganizationCreate) *OrganizationCreateBulk {
	return &OrganizationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrganizationClient) MapCreateBulk(slice any, setFunc func(*OrganizationCreate, int)) *OrganizationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrganizationCreateBulk{err: fmt.Errorf("calling to OrganizationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrganizationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrganizationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Organization.
func (c *OrganizationClient) Update() *OrganizationUpdate {
	mutation := newOrganizationMutation(c.config, OpUpdate)
	return &OrganizationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrganizationClient) UpdateOne(o *Organization) *OrganizationUpdateOne {
	mutation := newOrganizationMutation(c.config, OpUpdateOne, withOrganization(o))
	return &OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrganizationClient) UpdateOneID(id int) *OrganizationUpdateOne {
	mutation := newOrganizationMutation(c.config, OpUpdateOne, withOrganizationID(id))
	return &OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Organization.
func (c *OrganizationClient) Delete() *OrganizationDelete {
	mutation := newOrganizationMutation(c.config, OpDelete)
	return &OrganizationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrganizationClient) DeleteOne(o *Organization) *OrganizationDeleteOne {
	return c.DeleteOneID(o.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrganizationClient) DeleteOneID(id int) *OrganizationDeleteOne {
	builder := c.Delete().Where(organization.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrganizationDeleteOne{builder}
}

// Query returns a query builder for Organization.
func (c *OrganizationClient) Query() *OrganizationQuery {
	return &OrganizationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrganization},
		inters: c.Interceptors(),
	}
}

// Get returns a Organization entity by its id.
func (c *OrganizationClient) Get(ctx context.Context, id int) (*Organization, error) {
	return c.Query().Where(organization.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrganizationClient) GetX(ctx context.Context, id int) *Organization {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProviders queries the providers edge of a Organization.
func (c *OrganizationClient) QueryProviders(o *Organization) *ProviderQuery {
	query := (&ProviderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(provider.Table, provider.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.ProvidersTable, organization.ProvidersColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryThirdPartyAuths queries the third_party_auths edge of a Organization.
func (c *OrganizationClient) QueryThirdPartyAuths(o *Organization) *ThirdPartyAuthQuery {
	query := (&ThirdPartyAuthClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(thirdpartyauth.Table, thirdpartyauth.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.ThirdPartyAuthsTable, organization.ThirdPartyAuthsColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrganizationClient) Hooks() []Hook {
	return c.hooks.Organization
}

// Interceptors returns the client interceptors.
func (c *OrganizationClient) Interceptors() []Interceptor {
	return c.inters.Organization
}

func (c *OrganizationClient) mutate(ctx context.Context, m *OrganizationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrganizationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrganizationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrganizationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Organization mutation op: %q", m.Op())
	}
}

// PgsodiumConfigClient is a client for the PgsodiumConfig schema.
type PgsodiumConfigClient struct {
	config
}

// NewPgsodiumConfigClient returns a client for the PgsodiumConfig from the given config.
func NewPgsodiumConfigClient(c config) *PgsodiumConfigClient {
	return &PgsodiumConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `pgsodiumconfig.Hooks(f(g(h())))`.
func (c *PgsodiumConfigClient) Use(hooks ...Hook) {
	c.hooks.PgsodiumConfig = append(c.hooks.PgsodiumConfig, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `pgsodiumconfig.Intercept(f(g(h())))`.
func (c *PgsodiumConfigClient) Intercept(interceptors ...Interceptor) {
	c.inters.PgsodiumConfig = append(c.inters.PgsodiumConfig, interceptors...)
}

// Create returns a builder for creating a PgsodiumConfig entity.
func (c *PgsodiumConfigClient) Create() *PgsodiumConfigCreate {
	mutation := newPgsodiumConfigMutation(c.config, OpCreate)
	return &PgsodiumConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PgsodiumConfig entities.
func (c *PgsodiumConfigClient) CreateBulk(builders ...*PgsodiumConfigCreate) *PgsodiumConfigCreateBulk {
	return &PgsodiumConfigCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PgsodiumConfigClient) MapCreateBulk(slice any, setFunc func(*PgsodiumConfigCreate, int)) *PgsodiumConfigCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PgsodiumConfigCreateBulk{err: fmt.Errorf("calling to PgsodiumConfigClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PgsodiumConfigCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PgsodiumConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PgsodiumConfig.
func (c *PgsodiumConfigClient) Update() *PgsodiumConfigUpdate {
	mutation := newPgsodiumConfigMutation(c.config, OpUpdate)
	return &PgsodiumConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PgsodiumConfigClient) UpdateOne(pc *PgsodiumConfig) *PgsodiumConfigUpdateOne {
	mutation := newPgsodiumConfigMutation(c.config, OpUpdateOne, withPgsodiumConfig(pc))
	return &PgsodiumConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PgsodiumConfigClient) UpdateOneID(id uuid.UUID) *PgsodiumConfigUpdateOne {
	mutation := newPgsodiumConfigMutation(c.config, OpUpdateOne, withPgsodiumConfigID(id))
	return &PgsodiumConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PgsodiumConfig.
func (c *PgsodiumConfigClient) Delete() *PgsodiumConfigDelete {
	mutation := newPgsodiumConfigMutation(c.config, OpDelete)
	return &PgsodiumConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PgsodiumConfigClient) DeleteOne(pc *PgsodiumConfig) *PgsodiumConfigDeleteOne {
	return c.DeleteOneID(pc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PgsodiumConfigClient) DeleteOneID(id uuid.UUID) *PgsodiumConfigDeleteOne {
	builder := c.Delete().Where(pgsodiumconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PgsodiumConfigDeleteOne{builder}
}

// Query returns a query builder for PgsodiumConfig.
func (c *PgsodiumConfigClient) Query() *PgsodiumConfigQuery {
	return &PgsodiumConfigQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePgsodiumConfig},
		inters: c.Interceptors(),
	}
}

// Get returns a PgsodiumConfig entity by its id.
func (c *PgsodiumConfigClient) Get(ctx context.Context, id uuid.UUID) (*PgsodiumConfig, error) {
	return c.Query().Where(pgsodiumconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PgsodiumConfigClient) GetX(ctx context.Context, id uuid.UUID) *PgsodiumConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a PgsodiumConfig.
func (c *PgsodiumConfigClient) QueryProject(pc *PgsodiumConfig) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(pgsodiumconfig.Table, pgsodiumconfig.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, pgsodiumconfig.ProjectTable, pgsodiumconfig.ProjectColumn),
		)
		fromV = sqlgraph.Neighbors(pc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PgsodiumConfigClient) Hooks() []Hook {
	return c.hooks.PgsodiumConfig
}

// Interceptors returns the client interceptors.
func (c *PgsodiumConfigClient) Interceptors() []Interceptor {
	return c.inters.PgsodiumConfig
}

func (c *PgsodiumConfigClient) mutate(ctx context.Context, m *PgsodiumConfigMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PgsodiumConfigCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PgsodiumConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PgsodiumConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PgsodiumConfigDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PgsodiumConfig mutation op: %q", m.Op())
	}
}

// ProjectClient is a client for the Project schema.
type ProjectClient struct {
	config
}

// NewProjectClient returns a client for the Project from the given config.
func NewProjectClient(c config) *ProjectClient {
	return &ProjectClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `project.Hooks(f(g(h())))`.
func (c *ProjectClient) Use(hooks ...Hook) {
	c.hooks.Project = append(c.hooks.Project, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `project.Intercept(f(g(h())))`.
func (c *ProjectClient) Intercept(interceptors ...Interceptor) {
	c.inters.Project = append(c.inters.Project, interceptors...)
}

// Create returns a builder for creating a Project entity.
func (c *ProjectClient) Create() *ProjectCreate {
	mutation := newProjectMutation(c.config, OpCreate)
	return &ProjectCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Project entities.
func (c *ProjectClient) CreateBulk(builders ...*ProjectCreate) *ProjectCreateBulk {
	return &ProjectCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProjectClient) MapCreateBulk(slice any, setFunc func(*ProjectCreate, int)) *ProjectCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProjectCreateBulk{err: fmt.Errorf("calling to ProjectClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProjectCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProjectCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Project.
func (c *ProjectClient) Update() *ProjectUpdate {
	mutation := newProjectMutation(c.config, OpUpdate)
	return &ProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProjectClient) UpdateOne(pr *Project) *ProjectUpdateOne {
	mutation := newProjectMutation(c.config, OpUpdateOne, withProject(pr))
	return &ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProjectClient) UpdateOneID(id uuid.UUID) *ProjectUpdateOne {
	mutation := newProjectMutation(c.config, OpUpdateOne, withProjectID(id))
	return &ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Project.
func (c *ProjectClient) Delete() *ProjectDelete {
	mutation := newProjectMutation(c.config, OpDelete)
	return &ProjectDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProjectClient) DeleteOne(pr *Project) *ProjectDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProjectClient) DeleteOneID(id uuid.UUID) *ProjectDeleteOne {
	builder := c.Delete().Where(project.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProjectDeleteOne{builder}
}

// Query returns a query builder for Project.
func (c *ProjectClient) Query() *ProjectQuery {
	return &ProjectQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProject},
		inters: c.Interceptors(),
	}
}

// Get returns a Project entity by its id.
func (c *ProjectClient) Get(ctx context.Context, id uuid.UUID) (*Project, error) {
	return c.Query().Where(project.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProjectClient) GetX(ctx context.Context, id uuid.UUID) *Project {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySecrets queries the secrets edge of a Project.
func (c *ProjectClient) QuerySecrets(pr *Project) *SecretQuery {
	query := (&SecretClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(secret.Table, secret.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.SecretsTable, project.SecretsColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTypescriptTypes queries the typescriptTypes edge of a Project.
func (c *ProjectClient) QueryTypescriptTypes(pr *Project) *TypeScriptTypeQuery {
	query := (&TypeScriptTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(typescripttype.Table, typescripttype.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.TypescriptTypesTable, project.TypescriptTypesColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFunctions queries the functions edge of a Project.
func (c *ProjectClient) QueryFunctions(pr *Project) *FunctionQuery {
	query := (&FunctionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(function.Table, function.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.FunctionsTable, project.FunctionsColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomHostnames queries the customHostnames edge of a Project.
func (c *ProjectClient) QueryCustomHostnames(pr *Project) *CustomHostnameQuery {
	query := (&CustomHostnameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(customhostname.Table, customhostname.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.CustomHostnamesTable, project.CustomHostnamesColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPgsodiumConfigs queries the pgsodiumConfigs edge of a Project.
func (c *ProjectClient) QueryPgsodiumConfigs(pr *Project) *PgsodiumConfigQuery {
	query := (&PgsodiumConfigClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(pgsodiumconfig.Table, pgsodiumconfig.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.PgsodiumConfigsTable, project.PgsodiumConfigsColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNetworkBans queries the networkBans edge of a Project.
func (c *ProjectClient) QueryNetworkBans(pr *Project) *NetworkBanQuery {
	query := (&NetworkBanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(networkban.Table, networkban.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.NetworkBansTable, project.NetworkBansColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBranches queries the branches edge of a Project.
func (c *ProjectClient) QueryBranches(pr *Project) *BranchQuery {
	query := (&BranchClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(branch.Table, branch.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.BranchesTable, project.BranchesColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildBranches queries the childBranches edge of a Project.
func (c *ProjectClient) QueryChildBranches(pr *Project) *BranchQuery {
	query := (&BranchClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(branch.Table, branch.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.ChildBranchesTable, project.ChildBranchesColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAuthConfig queries the auth_config edge of a Project.
func (c *ProjectClient) QueryAuthConfig(pr *Project) *AuthConfigQuery {
	query := (&AuthConfigClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(authconfig.Table, authconfig.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, project.AuthConfigTable, project.AuthConfigColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProjectClient) Hooks() []Hook {
	return c.hooks.Project
}

// Interceptors returns the client interceptors.
func (c *ProjectClient) Interceptors() []Interceptor {
	return c.inters.Project
}

func (c *ProjectClient) mutate(ctx context.Context, m *ProjectMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProjectCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProjectDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Project mutation op: %q", m.Op())
	}
}

// ProviderClient is a client for the Provider schema.
type ProviderClient struct {
	config
}

// NewProviderClient returns a client for the Provider from the given config.
func NewProviderClient(c config) *ProviderClient {
	return &ProviderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `provider.Hooks(f(g(h())))`.
func (c *ProviderClient) Use(hooks ...Hook) {
	c.hooks.Provider = append(c.hooks.Provider, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `provider.Intercept(f(g(h())))`.
func (c *ProviderClient) Intercept(interceptors ...Interceptor) {
	c.inters.Provider = append(c.inters.Provider, interceptors...)
}

// Create returns a builder for creating a Provider entity.
func (c *ProviderClient) Create() *ProviderCreate {
	mutation := newProviderMutation(c.config, OpCreate)
	return &ProviderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Provider entities.
func (c *ProviderClient) CreateBulk(builders ...*ProviderCreate) *ProviderCreateBulk {
	return &ProviderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProviderClient) MapCreateBulk(slice any, setFunc func(*ProviderCreate, int)) *ProviderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProviderCreateBulk{err: fmt.Errorf("calling to ProviderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProviderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProviderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Provider.
func (c *ProviderClient) Update() *ProviderUpdate {
	mutation := newProviderMutation(c.config, OpUpdate)
	return &ProviderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProviderClient) UpdateOne(pr *Provider) *ProviderUpdateOne {
	mutation := newProviderMutation(c.config, OpUpdateOne, withProvider(pr))
	return &ProviderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProviderClient) UpdateOneID(id int) *ProviderUpdateOne {
	mutation := newProviderMutation(c.config, OpUpdateOne, withProviderID(id))
	return &ProviderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Provider.
func (c *ProviderClient) Delete() *ProviderDelete {
	mutation := newProviderMutation(c.config, OpDelete)
	return &ProviderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProviderClient) DeleteOne(pr *Provider) *ProviderDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProviderClient) DeleteOneID(id int) *ProviderDeleteOne {
	builder := c.Delete().Where(provider.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProviderDeleteOne{builder}
}

// Query returns a query builder for Provider.
func (c *ProviderClient) Query() *ProviderQuery {
	return &ProviderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProvider},
		inters: c.Interceptors(),
	}
}

// Get returns a Provider entity by its id.
func (c *ProviderClient) Get(ctx context.Context, id int) (*Provider, error) {
	return c.Query().Where(provider.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProviderClient) GetX(ctx context.Context, id int) *Provider {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrganization queries the organization edge of a Provider.
func (c *ProviderClient) QueryOrganization(pr *Provider) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provider.Table, provider.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, provider.OrganizationTable, provider.OrganizationColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProviderClient) Hooks() []Hook {
	return c.hooks.Provider
}

// Interceptors returns the client interceptors.
func (c *ProviderClient) Interceptors() []Interceptor {
	return c.inters.Provider
}

func (c *ProviderClient) mutate(ctx context.Context, m *ProviderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProviderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProviderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProviderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProviderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Provider mutation op: %q", m.Op())
	}
}

// SecretClient is a client for the Secret schema.
type SecretClient struct {
	config
}

// NewSecretClient returns a client for the Secret from the given config.
func NewSecretClient(c config) *SecretClient {
	return &SecretClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `secret.Hooks(f(g(h())))`.
func (c *SecretClient) Use(hooks ...Hook) {
	c.hooks.Secret = append(c.hooks.Secret, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `secret.Intercept(f(g(h())))`.
func (c *SecretClient) Intercept(interceptors ...Interceptor) {
	c.inters.Secret = append(c.inters.Secret, interceptors...)
}

// Create returns a builder for creating a Secret entity.
func (c *SecretClient) Create() *SecretCreate {
	mutation := newSecretMutation(c.config, OpCreate)
	return &SecretCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Secret entities.
func (c *SecretClient) CreateBulk(builders ...*SecretCreate) *SecretCreateBulk {
	return &SecretCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SecretClient) MapCreateBulk(slice any, setFunc func(*SecretCreate, int)) *SecretCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SecretCreateBulk{err: fmt.Errorf("calling to SecretClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SecretCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SecretCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Secret.
func (c *SecretClient) Update() *SecretUpdate {
	mutation := newSecretMutation(c.config, OpUpdate)
	return &SecretUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SecretClient) UpdateOne(s *Secret) *SecretUpdateOne {
	mutation := newSecretMutation(c.config, OpUpdateOne, withSecret(s))
	return &SecretUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SecretClient) UpdateOneID(id uuid.UUID) *SecretUpdateOne {
	mutation := newSecretMutation(c.config, OpUpdateOne, withSecretID(id))
	return &SecretUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Secret.
func (c *SecretClient) Delete() *SecretDelete {
	mutation := newSecretMutation(c.config, OpDelete)
	return &SecretDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SecretClient) DeleteOne(s *Secret) *SecretDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SecretClient) DeleteOneID(id uuid.UUID) *SecretDeleteOne {
	builder := c.Delete().Where(secret.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SecretDeleteOne{builder}
}

// Query returns a query builder for Secret.
func (c *SecretClient) Query() *SecretQuery {
	return &SecretQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSecret},
		inters: c.Interceptors(),
	}
}

// Get returns a Secret entity by its id.
func (c *SecretClient) Get(ctx context.Context, id uuid.UUID) (*Secret, error) {
	return c.Query().Where(secret.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SecretClient) GetX(ctx context.Context, id uuid.UUID) *Secret {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a Secret.
func (c *SecretClient) QueryProject(s *Secret) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(secret.Table, secret.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, secret.ProjectTable, secret.ProjectColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SecretClient) Hooks() []Hook {
	return c.hooks.Secret
}

// Interceptors returns the client interceptors.
func (c *SecretClient) Interceptors() []Interceptor {
	return c.inters.Secret
}

func (c *SecretClient) mutate(ctx context.Context, m *SecretMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SecretCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SecretUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SecretUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SecretDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Secret mutation op: %q", m.Op())
	}
}

// ThirdPartyAuthClient is a client for the ThirdPartyAuth schema.
type ThirdPartyAuthClient struct {
	config
}

// NewThirdPartyAuthClient returns a client for the ThirdPartyAuth from the given config.
func NewThirdPartyAuthClient(c config) *ThirdPartyAuthClient {
	return &ThirdPartyAuthClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `thirdpartyauth.Hooks(f(g(h())))`.
func (c *ThirdPartyAuthClient) Use(hooks ...Hook) {
	c.hooks.ThirdPartyAuth = append(c.hooks.ThirdPartyAuth, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `thirdpartyauth.Intercept(f(g(h())))`.
func (c *ThirdPartyAuthClient) Intercept(interceptors ...Interceptor) {
	c.inters.ThirdPartyAuth = append(c.inters.ThirdPartyAuth, interceptors...)
}

// Create returns a builder for creating a ThirdPartyAuth entity.
func (c *ThirdPartyAuthClient) Create() *ThirdPartyAuthCreate {
	mutation := newThirdPartyAuthMutation(c.config, OpCreate)
	return &ThirdPartyAuthCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ThirdPartyAuth entities.
func (c *ThirdPartyAuthClient) CreateBulk(builders ...*ThirdPartyAuthCreate) *ThirdPartyAuthCreateBulk {
	return &ThirdPartyAuthCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ThirdPartyAuthClient) MapCreateBulk(slice any, setFunc func(*ThirdPartyAuthCreate, int)) *ThirdPartyAuthCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ThirdPartyAuthCreateBulk{err: fmt.Errorf("calling to ThirdPartyAuthClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ThirdPartyAuthCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ThirdPartyAuthCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ThirdPartyAuth.
func (c *ThirdPartyAuthClient) Update() *ThirdPartyAuthUpdate {
	mutation := newThirdPartyAuthMutation(c.config, OpUpdate)
	return &ThirdPartyAuthUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ThirdPartyAuthClient) UpdateOne(tpa *ThirdPartyAuth) *ThirdPartyAuthUpdateOne {
	mutation := newThirdPartyAuthMutation(c.config, OpUpdateOne, withThirdPartyAuth(tpa))
	return &ThirdPartyAuthUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ThirdPartyAuthClient) UpdateOneID(id int) *ThirdPartyAuthUpdateOne {
	mutation := newThirdPartyAuthMutation(c.config, OpUpdateOne, withThirdPartyAuthID(id))
	return &ThirdPartyAuthUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ThirdPartyAuth.
func (c *ThirdPartyAuthClient) Delete() *ThirdPartyAuthDelete {
	mutation := newThirdPartyAuthMutation(c.config, OpDelete)
	return &ThirdPartyAuthDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ThirdPartyAuthClient) DeleteOne(tpa *ThirdPartyAuth) *ThirdPartyAuthDeleteOne {
	return c.DeleteOneID(tpa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ThirdPartyAuthClient) DeleteOneID(id int) *ThirdPartyAuthDeleteOne {
	builder := c.Delete().Where(thirdpartyauth.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ThirdPartyAuthDeleteOne{builder}
}

// Query returns a query builder for ThirdPartyAuth.
func (c *ThirdPartyAuthClient) Query() *ThirdPartyAuthQuery {
	return &ThirdPartyAuthQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeThirdPartyAuth},
		inters: c.Interceptors(),
	}
}

// Get returns a ThirdPartyAuth entity by its id.
func (c *ThirdPartyAuthClient) Get(ctx context.Context, id int) (*ThirdPartyAuth, error) {
	return c.Query().Where(thirdpartyauth.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ThirdPartyAuthClient) GetX(ctx context.Context, id int) *ThirdPartyAuth {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrganization queries the organization edge of a ThirdPartyAuth.
func (c *ThirdPartyAuthClient) QueryOrganization(tpa *ThirdPartyAuth) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tpa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(thirdpartyauth.Table, thirdpartyauth.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, thirdpartyauth.OrganizationTable, thirdpartyauth.OrganizationColumn),
		)
		fromV = sqlgraph.Neighbors(tpa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ThirdPartyAuthClient) Hooks() []Hook {
	return c.hooks.ThirdPartyAuth
}

// Interceptors returns the client interceptors.
func (c *ThirdPartyAuthClient) Interceptors() []Interceptor {
	return c.inters.ThirdPartyAuth
}

func (c *ThirdPartyAuthClient) mutate(ctx context.Context, m *ThirdPartyAuthMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ThirdPartyAuthCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ThirdPartyAuthUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ThirdPartyAuthUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ThirdPartyAuthDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ThirdPartyAuth mutation op: %q", m.Op())
	}
}

// TypeScriptTypeClient is a client for the TypeScriptType schema.
type TypeScriptTypeClient struct {
	config
}

// NewTypeScriptTypeClient returns a client for the TypeScriptType from the given config.
func NewTypeScriptTypeClient(c config) *TypeScriptTypeClient {
	return &TypeScriptTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `typescripttype.Hooks(f(g(h())))`.
func (c *TypeScriptTypeClient) Use(hooks ...Hook) {
	c.hooks.TypeScriptType = append(c.hooks.TypeScriptType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `typescripttype.Intercept(f(g(h())))`.
func (c *TypeScriptTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.TypeScriptType = append(c.inters.TypeScriptType, interceptors...)
}

// Create returns a builder for creating a TypeScriptType entity.
func (c *TypeScriptTypeClient) Create() *TypeScriptTypeCreate {
	mutation := newTypeScriptTypeMutation(c.config, OpCreate)
	return &TypeScriptTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TypeScriptType entities.
func (c *TypeScriptTypeClient) CreateBulk(builders ...*TypeScriptTypeCreate) *TypeScriptTypeCreateBulk {
	return &TypeScriptTypeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TypeScriptTypeClient) MapCreateBulk(slice any, setFunc func(*TypeScriptTypeCreate, int)) *TypeScriptTypeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TypeScriptTypeCreateBulk{err: fmt.Errorf("calling to TypeScriptTypeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TypeScriptTypeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TypeScriptTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TypeScriptType.
func (c *TypeScriptTypeClient) Update() *TypeScriptTypeUpdate {
	mutation := newTypeScriptTypeMutation(c.config, OpUpdate)
	return &TypeScriptTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TypeScriptTypeClient) UpdateOne(tst *TypeScriptType) *TypeScriptTypeUpdateOne {
	mutation := newTypeScriptTypeMutation(c.config, OpUpdateOne, withTypeScriptType(tst))
	return &TypeScriptTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TypeScriptTypeClient) UpdateOneID(id uuid.UUID) *TypeScriptTypeUpdateOne {
	mutation := newTypeScriptTypeMutation(c.config, OpUpdateOne, withTypeScriptTypeID(id))
	return &TypeScriptTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TypeScriptType.
func (c *TypeScriptTypeClient) Delete() *TypeScriptTypeDelete {
	mutation := newTypeScriptTypeMutation(c.config, OpDelete)
	return &TypeScriptTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TypeScriptTypeClient) DeleteOne(tst *TypeScriptType) *TypeScriptTypeDeleteOne {
	return c.DeleteOneID(tst.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TypeScriptTypeClient) DeleteOneID(id uuid.UUID) *TypeScriptTypeDeleteOne {
	builder := c.Delete().Where(typescripttype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TypeScriptTypeDeleteOne{builder}
}

// Query returns a query builder for TypeScriptType.
func (c *TypeScriptTypeClient) Query() *TypeScriptTypeQuery {
	return &TypeScriptTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTypeScriptType},
		inters: c.Interceptors(),
	}
}

// Get returns a TypeScriptType entity by its id.
func (c *TypeScriptTypeClient) Get(ctx context.Context, id uuid.UUID) (*TypeScriptType, error) {
	return c.Query().Where(typescripttype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TypeScriptTypeClient) GetX(ctx context.Context, id uuid.UUID) *TypeScriptType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a TypeScriptType.
func (c *TypeScriptTypeClient) QueryProject(tst *TypeScriptType) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tst.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(typescripttype.Table, typescripttype.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, typescripttype.ProjectTable, typescripttype.ProjectColumn),
		)
		fromV = sqlgraph.Neighbors(tst.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TypeScriptTypeClient) Hooks() []Hook {
	return c.hooks.TypeScriptType
}

// Interceptors returns the client interceptors.
func (c *TypeScriptTypeClient) Interceptors() []Interceptor {
	return c.inters.TypeScriptType
}

func (c *TypeScriptTypeClient) mutate(ctx context.Context, m *TypeScriptTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TypeScriptTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TypeScriptTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TypeScriptTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TypeScriptTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TypeScriptType mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uuid.UUID) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id uuid.UUID) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uuid.UUID) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uuid.UUID) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AuthConfig, Branch, CustomHostname, Function, NetworkBan, Organization,
		PgsodiumConfig, Project, Provider, Secret, ThirdPartyAuth, TypeScriptType,
		User []ent.Hook
	}
	inters struct {
		AuthConfig, Branch, CustomHostname, Function, NetworkBan, Organization,
		PgsodiumConfig, Project, Provider, Secret, ThirdPartyAuth, TypeScriptType,
		User []ent.Interceptor
	}
)
