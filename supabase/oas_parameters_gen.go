// Code generated by ogen, DO NOT EDIT.

package api

import (
	"fmt"
	"net/http"
	"net/url"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

// ActivateParams is parameters of activate operation.
type ActivateParams struct {
	// Project ref.
	Ref string
}

func unpackActivateParams(packed middleware.Parameters) (params ActivateParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeActivateParams(args [1]string, argsEscaped bool, r *http.Request) (params ActivateParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ActivateVanitySubdomainPleaseParams is parameters of activateVanitySubdomainPlease operation.
type ActivateVanitySubdomainPleaseParams struct {
	// Project ref.
	Ref string
}

func unpackActivateVanitySubdomainPleaseParams(packed middleware.Parameters) (params ActivateVanitySubdomainPleaseParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeActivateVanitySubdomainPleaseParams(args [1]string, argsEscaped bool, r *http.Request) (params ActivateVanitySubdomainPleaseParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ApplyNetworkRestrictionsParams is parameters of applyNetworkRestrictions operation.
type ApplyNetworkRestrictionsParams struct {
	// Project ref.
	Ref string
}

func unpackApplyNetworkRestrictionsParams(packed middleware.Parameters) (params ApplyNetworkRestrictionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeApplyNetworkRestrictionsParams(args [1]string, argsEscaped bool, r *http.Request) (params ApplyNetworkRestrictionsParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// AuthorizeParams is parameters of authorize operation.
type AuthorizeParams struct {
	ClientID            string
	ResponseType        AuthorizeResponseType
	RedirectURI         string
	Scope               OptString
	State               OptString
	ResponseMode        OptString
	CodeChallenge       OptString
	CodeChallengeMethod OptAuthorizeCodeChallengeMethod
}

func unpackAuthorizeParams(packed middleware.Parameters) (params AuthorizeParams) {
	{
		key := middleware.ParameterKey{
			Name: "client_id",
			In:   "query",
		}
		params.ClientID = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "response_type",
			In:   "query",
		}
		params.ResponseType = packed[key].(AuthorizeResponseType)
	}
	{
		key := middleware.ParameterKey{
			Name: "redirect_uri",
			In:   "query",
		}
		params.RedirectURI = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "scope",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Scope = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "state",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.State = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "response_mode",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ResponseMode = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "code_challenge",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.CodeChallenge = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "code_challenge_method",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.CodeChallengeMethod = v.(OptAuthorizeCodeChallengeMethod)
		}
	}
	return params
}

func decodeAuthorizeParams(args [0]string, argsEscaped bool, r *http.Request) (params AuthorizeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: client_id.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "client_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ClientID = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "client_id",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: response_type.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "response_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ResponseType = AuthorizeResponseType(c)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if err := params.ResponseType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "response_type",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: redirect_uri.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "redirect_uri",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.RedirectURI = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "redirect_uri",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: scope.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "scope",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotScopeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotScopeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Scope.SetTo(paramsDotScopeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "scope",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: state.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStateVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsDotStateVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "state",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: response_mode.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "response_mode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotResponseModeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotResponseModeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ResponseMode.SetTo(paramsDotResponseModeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "response_mode",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: code_challenge.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "code_challenge",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCodeChallengeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCodeChallengeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.CodeChallenge.SetTo(paramsDotCodeChallengeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "code_challenge",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: code_challenge_method.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "code_challenge_method",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCodeChallengeMethodVal AuthorizeCodeChallengeMethod
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCodeChallengeMethodVal = AuthorizeCodeChallengeMethod(c)
					return nil
				}(); err != nil {
					return err
				}
				params.CodeChallengeMethod.SetTo(paramsDotCodeChallengeMethodVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.CodeChallengeMethod.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "code_challenge_method",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// CheckServiceHealthParams is parameters of checkServiceHealth operation.
type CheckServiceHealthParams struct {
	// Project ref.
	Ref       string
	TimeoutMs OptInt
	Services  []CheckServiceHealthServicesItem
}

func unpackCheckServiceHealthParams(packed middleware.Parameters) (params CheckServiceHealthParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "timeout_ms",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.TimeoutMs = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "services",
			In:   "query",
		}
		params.Services = packed[key].([]CheckServiceHealthServicesItem)
	}
	return params
}

func decodeCheckServiceHealthParams(args [1]string, argsEscaped bool, r *http.Request) (params CheckServiceHealthParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: timeout_ms.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "timeout_ms",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTimeoutMsVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotTimeoutMsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.TimeoutMs.SetTo(paramsDotTimeoutMsVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.TimeoutMs.Get(); ok {
					if err := func() error {
						if err := (validate.Int{
							MinSet:        true,
							Min:           0,
							MaxSet:        true,
							Max:           10000,
							MinExclusive:  false,
							MaxExclusive:  false,
							MultipleOfSet: false,
							MultipleOf:    0,
						}).Validate(int64(value)); err != nil {
							return errors.Wrap(err, "int")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "timeout_ms",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: services.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "services",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotServicesVal CheckServiceHealthServicesItem
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotServicesVal = CheckServiceHealthServicesItem(c)
						return nil
					}(); err != nil {
						return err
					}
					params.Services = append(params.Services, paramsDotServicesVal)
					return nil
				})
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.Services == nil {
					return errors.New("nil is invalid value")
				}
				var failures []validate.FieldError
				for i, elem := range params.Services {
					if err := func() error {
						if err := elem.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						failures = append(failures, validate.FieldError{
							Name:  fmt.Sprintf("[%d]", i),
							Error: err,
						})
					}
				}
				if len(failures) > 0 {
					return &validate.Error{Fields: failures}
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "services",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// CheckVanitySubdomainAvailabilityParams is parameters of checkVanitySubdomainAvailability operation.
type CheckVanitySubdomainAvailabilityParams struct {
	// Project ref.
	Ref string
}

func unpackCheckVanitySubdomainAvailabilityParams(packed middleware.Parameters) (params CheckVanitySubdomainAvailabilityParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeCheckVanitySubdomainAvailabilityParams(args [1]string, argsEscaped bool, r *http.Request) (params CheckVanitySubdomainAvailabilityParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// CreateBranchParams is parameters of createBranch operation.
type CreateBranchParams struct {
	// Project ref.
	Ref string
}

func unpackCreateBranchParams(packed middleware.Parameters) (params CreateBranchParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeCreateBranchParams(args [1]string, argsEscaped bool, r *http.Request) (params CreateBranchParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// CreateCustomHostnameConfigParams is parameters of createCustomHostnameConfig operation.
type CreateCustomHostnameConfigParams struct {
	// Project ref.
	Ref string
}

func unpackCreateCustomHostnameConfigParams(packed middleware.Parameters) (params CreateCustomHostnameConfigParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeCreateCustomHostnameConfigParams(args [1]string, argsEscaped bool, r *http.Request) (params CreateCustomHostnameConfigParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// CreateFunctionParams is parameters of createFunction operation.
type CreateFunctionParams struct {
	// Project ref.
	Ref            string
	Slug           OptString
	Name           OptString
	VerifyJwt      OptBool
	ImportMap      OptBool
	EntrypointPath OptString
	ImportMapPath  OptString
}

func unpackCreateFunctionParams(packed middleware.Parameters) (params CreateFunctionParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "slug",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Slug = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "name",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Name = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "verify_jwt",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.VerifyJwt = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "import_map",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ImportMap = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "entrypoint_path",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EntrypointPath = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "import_map_path",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ImportMapPath = v.(OptString)
		}
	}
	return params
}

func decodeCreateFunctionParams(args [1]string, argsEscaped bool, r *http.Request) (params CreateFunctionParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: slug.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "slug",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSlugVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSlugVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Slug.SetTo(paramsDotSlugVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Slug.Get(); ok {
					if err := func() error {
						if err := (validate.String{
							MinLength:    0,
							MinLengthSet: false,
							MaxLength:    0,
							MaxLengthSet: false,
							Email:        false,
							Hostname:     false,
							Regex:        regexMap["/^[A-Za-z0-9_-]+$/"],
						}).Validate(string(value)); err != nil {
							return errors.Wrap(err, "string")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "slug",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: name.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotNameVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Name.SetTo(paramsDotNameVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "name",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: verify_jwt.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "verify_jwt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotVerifyJwtVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotVerifyJwtVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.VerifyJwt.SetTo(paramsDotVerifyJwtVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "verify_jwt",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: import_map.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "import_map",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotImportMapVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotImportMapVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ImportMap.SetTo(paramsDotImportMapVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "import_map",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: entrypoint_path.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "entrypoint_path",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEntrypointPathVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotEntrypointPathVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EntrypointPath.SetTo(paramsDotEntrypointPathVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "entrypoint_path",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: import_map_path.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "import_map_path",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotImportMapPathVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotImportMapPathVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ImportMapPath.SetTo(paramsDotImportMapPathVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "import_map_path",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// CreateProviderForProjectParams is parameters of createProviderForProject operation.
type CreateProviderForProjectParams struct {
	// Project ref.
	Ref string
}

func unpackCreateProviderForProjectParams(packed middleware.Parameters) (params CreateProviderForProjectParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeCreateProviderForProjectParams(args [1]string, argsEscaped bool, r *http.Request) (params CreateProviderForProjectParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// CreateSecretsParams is parameters of createSecrets operation.
type CreateSecretsParams struct {
	// Project ref.
	Ref string
}

func unpackCreateSecretsParams(packed middleware.Parameters) (params CreateSecretsParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeCreateSecretsParams(args [1]string, argsEscaped bool, r *http.Request) (params CreateSecretsParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// CreateTPAForProjectParams is parameters of createTPAForProject operation.
type CreateTPAForProjectParams struct {
	// Project ref.
	Ref string
}

func unpackCreateTPAForProjectParams(packed middleware.Parameters) (params CreateTPAForProjectParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeCreateTPAForProjectParams(args [1]string, argsEscaped bool, r *http.Request) (params CreateTPAForProjectParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteBranchParams is parameters of deleteBranch operation.
type DeleteBranchParams struct {
	// Branch ID.
	BranchID string
}

func unpackDeleteBranchParams(packed middleware.Parameters) (params DeleteBranchParams) {
	{
		key := middleware.ParameterKey{
			Name: "branch_id",
			In:   "path",
		}
		params.BranchID = packed[key].(string)
	}
	return params
}

func decodeDeleteBranchParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteBranchParams, _ error) {
	// Decode path: branch_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.BranchID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "branch_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteFunctionParams is parameters of deleteFunction operation.
type DeleteFunctionParams struct {
	// Project ref.
	Ref string
	// Function slug.
	FunctionSlug string
}

func unpackDeleteFunctionParams(packed middleware.Parameters) (params DeleteFunctionParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "function_slug",
			In:   "path",
		}
		params.FunctionSlug = packed[key].(string)
	}
	return params
}

func decodeDeleteFunctionParams(args [2]string, argsEscaped bool, r *http.Request) (params DeleteFunctionParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: function_slug.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "function_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.FunctionSlug = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    0,
					MinLengthSet: false,
					MaxLength:    0,
					MaxLengthSet: false,
					Email:        false,
					Hostname:     false,
					Regex:        regexMap["/^[A-Za-z0-9_-]+$/"],
				}).Validate(string(params.FunctionSlug)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "function_slug",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteProjectParams is parameters of deleteProject operation.
type DeleteProjectParams struct {
	// Project ref.
	Ref string
}

func unpackDeleteProjectParams(packed middleware.Parameters) (params DeleteProjectParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeDeleteProjectParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteProjectParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteSecretsParams is parameters of deleteSecrets operation.
type DeleteSecretsParams struct {
	// Project ref.
	Ref string
}

func unpackDeleteSecretsParams(packed middleware.Parameters) (params DeleteSecretsParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeDeleteSecretsParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteSecretsParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteTPAForProjectParams is parameters of deleteTPAForProject operation.
type DeleteTPAForProjectParams struct {
	// Project ref.
	Ref   string
	TpaID string
}

func unpackDeleteTPAForProjectParams(packed middleware.Parameters) (params DeleteTPAForProjectParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "tpa_id",
			In:   "path",
		}
		params.TpaID = packed[key].(string)
	}
	return params
}

func decodeDeleteTPAForProjectParams(args [2]string, argsEscaped bool, r *http.Request) (params DeleteTPAForProjectParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: tpa_id.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tpa_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TpaID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tpa_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DisableBranchParams is parameters of disableBranch operation.
type DisableBranchParams struct {
	// Project ref.
	Ref string
}

func unpackDisableBranchParams(packed middleware.Parameters) (params DisableBranchParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeDisableBranchParams(args [1]string, argsEscaped bool, r *http.Request) (params DisableBranchParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetBackupsParams is parameters of getBackups operation.
type GetBackupsParams struct {
	// Project ref.
	Ref string
}

func unpackGetBackupsParams(packed middleware.Parameters) (params GetBackupsParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeGetBackupsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetBackupsParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetBranchDetailsParams is parameters of getBranchDetails operation.
type GetBranchDetailsParams struct {
	// Branch ID.
	BranchID string
}

func unpackGetBranchDetailsParams(packed middleware.Parameters) (params GetBranchDetailsParams) {
	{
		key := middleware.ParameterKey{
			Name: "branch_id",
			In:   "path",
		}
		params.BranchID = packed[key].(string)
	}
	return params
}

func decodeGetBranchDetailsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetBranchDetailsParams, _ error) {
	// Decode path: branch_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.BranchID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "branch_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetBranchesParams is parameters of getBranches operation.
type GetBranchesParams struct {
	// Project ref.
	Ref string
}

func unpackGetBranchesParams(packed middleware.Parameters) (params GetBranchesParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeGetBranchesParams(args [1]string, argsEscaped bool, r *http.Request) (params GetBranchesParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetBucketsParams is parameters of getBuckets operation.
type GetBucketsParams struct {
	// Project ref.
	Ref string
}

func unpackGetBucketsParams(packed middleware.Parameters) (params GetBucketsParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeGetBucketsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetBucketsParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetConfigParams is parameters of getConfig operation.
type GetConfigParams struct {
	// Project ref.
	Ref string
}

func unpackGetConfigParams(packed middleware.Parameters) (params GetConfigParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeGetConfigParams(args [1]string, argsEscaped bool, r *http.Request) (params GetConfigParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetCustomHostnameConfigParams is parameters of getCustomHostnameConfig operation.
type GetCustomHostnameConfigParams struct {
	// Project ref.
	Ref string
}

func unpackGetCustomHostnameConfigParams(packed middleware.Parameters) (params GetCustomHostnameConfigParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeGetCustomHostnameConfigParams(args [1]string, argsEscaped bool, r *http.Request) (params GetCustomHostnameConfigParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetFunctionParams is parameters of getFunction operation.
type GetFunctionParams struct {
	// Project ref.
	Ref string
	// Function slug.
	FunctionSlug string
}

func unpackGetFunctionParams(packed middleware.Parameters) (params GetFunctionParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "function_slug",
			In:   "path",
		}
		params.FunctionSlug = packed[key].(string)
	}
	return params
}

func decodeGetFunctionParams(args [2]string, argsEscaped bool, r *http.Request) (params GetFunctionParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: function_slug.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "function_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.FunctionSlug = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    0,
					MinLengthSet: false,
					MaxLength:    0,
					MaxLengthSet: false,
					Email:        false,
					Hostname:     false,
					Regex:        regexMap["/^[A-Za-z0-9_-]+$/"],
				}).Validate(string(params.FunctionSlug)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "function_slug",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetFunctionBodyParams is parameters of getFunctionBody operation.
type GetFunctionBodyParams struct {
	// Project ref.
	Ref string
	// Function slug.
	FunctionSlug string
}

func unpackGetFunctionBodyParams(packed middleware.Parameters) (params GetFunctionBodyParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "function_slug",
			In:   "path",
		}
		params.FunctionSlug = packed[key].(string)
	}
	return params
}

func decodeGetFunctionBodyParams(args [2]string, argsEscaped bool, r *http.Request) (params GetFunctionBodyParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: function_slug.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "function_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.FunctionSlug = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    0,
					MinLengthSet: false,
					MaxLength:    0,
					MaxLengthSet: false,
					Email:        false,
					Hostname:     false,
					Regex:        regexMap["/^[A-Za-z0-9_-]+$/"],
				}).Validate(string(params.FunctionSlug)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "function_slug",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetFunctionsParams is parameters of getFunctions operation.
type GetFunctionsParams struct {
	// Project ref.
	Ref string
}

func unpackGetFunctionsParams(packed middleware.Parameters) (params GetFunctionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeGetFunctionsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetFunctionsParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetNetworkBansParams is parameters of getNetworkBans operation.
type GetNetworkBansParams struct {
	// Project ref.
	Ref string
}

func unpackGetNetworkBansParams(packed middleware.Parameters) (params GetNetworkBansParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeGetNetworkBansParams(args [1]string, argsEscaped bool, r *http.Request) (params GetNetworkBansParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetNetworkRestrictionsParams is parameters of getNetworkRestrictions operation.
type GetNetworkRestrictionsParams struct {
	// Project ref.
	Ref string
}

func unpackGetNetworkRestrictionsParams(packed middleware.Parameters) (params GetNetworkRestrictionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeGetNetworkRestrictionsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetNetworkRestrictionsParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetOrganizationParams is parameters of getOrganization operation.
type GetOrganizationParams struct {
	Slug string
}

func unpackGetOrganizationParams(packed middleware.Parameters) (params GetOrganizationParams) {
	{
		key := middleware.ParameterKey{
			Name: "slug",
			In:   "path",
		}
		params.Slug = packed[key].(string)
	}
	return params
}

func decodeGetOrganizationParams(args [1]string, argsEscaped bool, r *http.Request) (params GetOrganizationParams, _ error) {
	// Decode path: slug.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Slug = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "slug",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetPgsodiumConfigParams is parameters of getPgsodiumConfig operation.
type GetPgsodiumConfigParams struct {
	// Project ref.
	Ref string
}

func unpackGetPgsodiumConfigParams(packed middleware.Parameters) (params GetPgsodiumConfigParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeGetPgsodiumConfigParams(args [1]string, argsEscaped bool, r *http.Request) (params GetPgsodiumConfigParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetPostgRESTConfigParams is parameters of getPostgRESTConfig operation.
type GetPostgRESTConfigParams struct {
	// Project ref.
	Ref string
}

func unpackGetPostgRESTConfigParams(packed middleware.Parameters) (params GetPostgRESTConfigParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeGetPostgRESTConfigParams(args [1]string, argsEscaped bool, r *http.Request) (params GetPostgRESTConfigParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetProjectApiKeysParams is parameters of getProjectApiKeys operation.
type GetProjectApiKeysParams struct {
	// Project ref.
	Ref string
}

func unpackGetProjectApiKeysParams(packed middleware.Parameters) (params GetProjectApiKeysParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeGetProjectApiKeysParams(args [1]string, argsEscaped bool, r *http.Request) (params GetProjectApiKeysParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetProviderByIdParams is parameters of getProviderById operation.
type GetProviderByIdParams struct {
	// Project ref.
	Ref        string
	ProviderID string
}

func unpackGetProviderByIdParams(packed middleware.Parameters) (params GetProviderByIdParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "provider_id",
			In:   "path",
		}
		params.ProviderID = packed[key].(string)
	}
	return params
}

func decodeGetProviderByIdParams(args [2]string, argsEscaped bool, r *http.Request) (params GetProviderByIdParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: provider_id.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "provider_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ProviderID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "provider_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetReadOnlyModeStatusParams is parameters of getReadOnlyModeStatus operation.
type GetReadOnlyModeStatusParams struct {
	// Project ref.
	Ref string
}

func unpackGetReadOnlyModeStatusParams(packed middleware.Parameters) (params GetReadOnlyModeStatusParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeGetReadOnlyModeStatusParams(args [1]string, argsEscaped bool, r *http.Request) (params GetReadOnlyModeStatusParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetSecretsParams is parameters of getSecrets operation.
type GetSecretsParams struct {
	// Project ref.
	Ref string
}

func unpackGetSecretsParams(packed middleware.Parameters) (params GetSecretsParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeGetSecretsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetSecretsParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetSnippetParams is parameters of getSnippet operation.
type GetSnippetParams struct {
	ID string
}

func unpackGetSnippetParams(packed middleware.Parameters) (params GetSnippetParams) {
	{
		key := middleware.ParameterKey{
			Name: "id",
			In:   "path",
		}
		params.ID = packed[key].(string)
	}
	return params
}

func decodeGetSnippetParams(args [1]string, argsEscaped bool, r *http.Request) (params GetSnippetParams, _ error) {
	// Decode path: id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetSslEnforcementConfigParams is parameters of getSslEnforcementConfig operation.
type GetSslEnforcementConfigParams struct {
	// Project ref.
	Ref string
}

func unpackGetSslEnforcementConfigParams(packed middleware.Parameters) (params GetSslEnforcementConfigParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeGetSslEnforcementConfigParams(args [1]string, argsEscaped bool, r *http.Request) (params GetSslEnforcementConfigParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetTPAForProjectParams is parameters of getTPAForProject operation.
type GetTPAForProjectParams struct {
	// Project ref.
	Ref   string
	TpaID string
}

func unpackGetTPAForProjectParams(packed middleware.Parameters) (params GetTPAForProjectParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "tpa_id",
			In:   "path",
		}
		params.TpaID = packed[key].(string)
	}
	return params
}

func decodeGetTPAForProjectParams(args [2]string, argsEscaped bool, r *http.Request) (params GetTPAForProjectParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: tpa_id.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tpa_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TpaID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tpa_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetTypescriptTypesParams is parameters of getTypescriptTypes operation.
type GetTypescriptTypesParams struct {
	IncludedSchemas OptString
	// Project ref.
	Ref string
}

func unpackGetTypescriptTypesParams(packed middleware.Parameters) (params GetTypescriptTypesParams) {
	{
		key := middleware.ParameterKey{
			Name: "included_schemas",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.IncludedSchemas = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeGetTypescriptTypesParams(args [1]string, argsEscaped bool, r *http.Request) (params GetTypescriptTypesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: included_schemas.
	{
		val := string("public")
		params.IncludedSchemas.SetTo(val)
	}
	// Decode query: included_schemas.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "included_schemas",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIncludedSchemasVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotIncludedSchemasVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.IncludedSchemas.SetTo(paramsDotIncludedSchemasVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "included_schemas",
			In:   "query",
			Err:  err,
		}
	}
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetUpgradeStatusParams is parameters of getUpgradeStatus operation.
type GetUpgradeStatusParams struct {
	// Project ref.
	Ref string
}

func unpackGetUpgradeStatusParams(packed middleware.Parameters) (params GetUpgradeStatusParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeGetUpgradeStatusParams(args [1]string, argsEscaped bool, r *http.Request) (params GetUpgradeStatusParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetV1AuthConfigParams is parameters of getV1AuthConfig operation.
type GetV1AuthConfigParams struct {
	// Project ref.
	Ref string
}

func unpackGetV1AuthConfigParams(packed middleware.Parameters) (params GetV1AuthConfigParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeGetV1AuthConfigParams(args [1]string, argsEscaped bool, r *http.Request) (params GetV1AuthConfigParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetVanitySubdomainConfigParams is parameters of getVanitySubdomainConfig operation.
type GetVanitySubdomainConfigParams struct {
	// Project ref.
	Ref string
}

func unpackGetVanitySubdomainConfigParams(packed middleware.Parameters) (params GetVanitySubdomainConfigParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeGetVanitySubdomainConfigParams(args [1]string, argsEscaped bool, r *http.Request) (params GetVanitySubdomainConfigParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ListAllProvidersParams is parameters of listAllProviders operation.
type ListAllProvidersParams struct {
	// Project ref.
	Ref string
}

func unpackListAllProvidersParams(packed middleware.Parameters) (params ListAllProvidersParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeListAllProvidersParams(args [1]string, argsEscaped bool, r *http.Request) (params ListAllProvidersParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ListSnippetsParams is parameters of listSnippets operation.
type ListSnippetsParams struct {
	ProjectRef OptString
}

func unpackListSnippetsParams(packed middleware.Parameters) (params ListSnippetsParams) {
	{
		key := middleware.ParameterKey{
			Name: "project_ref",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ProjectRef = v.(OptString)
		}
	}
	return params
}

func decodeListSnippetsParams(args [0]string, argsEscaped bool, r *http.Request) (params ListSnippetsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: project_ref.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "project_ref",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotProjectRefVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotProjectRefVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ProjectRef.SetTo(paramsDotProjectRefVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "project_ref",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ListTPAForProjectParams is parameters of listTPAForProject operation.
type ListTPAForProjectParams struct {
	// Project ref.
	Ref string
}

func unpackListTPAForProjectParams(packed middleware.Parameters) (params ListTPAForProjectParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeListTPAForProjectParams(args [1]string, argsEscaped bool, r *http.Request) (params ListTPAForProjectParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RemoveCustomHostnameConfigParams is parameters of removeCustomHostnameConfig operation.
type RemoveCustomHostnameConfigParams struct {
	// Project ref.
	Ref string
}

func unpackRemoveCustomHostnameConfigParams(packed middleware.Parameters) (params RemoveCustomHostnameConfigParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeRemoveCustomHostnameConfigParams(args [1]string, argsEscaped bool, r *http.Request) (params RemoveCustomHostnameConfigParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RemoveNetworkBanParams is parameters of removeNetworkBan operation.
type RemoveNetworkBanParams struct {
	// Project ref.
	Ref string
}

func unpackRemoveNetworkBanParams(packed middleware.Parameters) (params RemoveNetworkBanParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeRemoveNetworkBanParams(args [1]string, argsEscaped bool, r *http.Request) (params RemoveNetworkBanParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RemoveProviderByIdParams is parameters of removeProviderById operation.
type RemoveProviderByIdParams struct {
	// Project ref.
	Ref        string
	ProviderID string
}

func unpackRemoveProviderByIdParams(packed middleware.Parameters) (params RemoveProviderByIdParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "provider_id",
			In:   "path",
		}
		params.ProviderID = packed[key].(string)
	}
	return params
}

func decodeRemoveProviderByIdParams(args [2]string, argsEscaped bool, r *http.Request) (params RemoveProviderByIdParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: provider_id.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "provider_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ProviderID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "provider_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RemoveReadReplicaParams is parameters of removeReadReplica operation.
type RemoveReadReplicaParams struct {
	// Project ref.
	Ref string
}

func unpackRemoveReadReplicaParams(packed middleware.Parameters) (params RemoveReadReplicaParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeRemoveReadReplicaParams(args [1]string, argsEscaped bool, r *http.Request) (params RemoveReadReplicaParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RemoveVanitySubdomainConfigParams is parameters of removeVanitySubdomainConfig operation.
type RemoveVanitySubdomainConfigParams struct {
	// Project ref.
	Ref string
}

func unpackRemoveVanitySubdomainConfigParams(packed middleware.Parameters) (params RemoveVanitySubdomainConfigParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeRemoveVanitySubdomainConfigParams(args [1]string, argsEscaped bool, r *http.Request) (params RemoveVanitySubdomainConfigParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ResetBranchParams is parameters of resetBranch operation.
type ResetBranchParams struct {
	// Branch ID.
	BranchID string
}

func unpackResetBranchParams(packed middleware.Parameters) (params ResetBranchParams) {
	{
		key := middleware.ParameterKey{
			Name: "branch_id",
			In:   "path",
		}
		params.BranchID = packed[key].(string)
	}
	return params
}

func decodeResetBranchParams(args [1]string, argsEscaped bool, r *http.Request) (params ResetBranchParams, _ error) {
	// Decode path: branch_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.BranchID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "branch_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ReverifyParams is parameters of reverify operation.
type ReverifyParams struct {
	// Project ref.
	Ref string
}

func unpackReverifyParams(packed middleware.Parameters) (params ReverifyParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeReverifyParams(args [1]string, argsEscaped bool, r *http.Request) (params ReverifyParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// SetUpReadReplicaParams is parameters of setUpReadReplica operation.
type SetUpReadReplicaParams struct {
	// Project ref.
	Ref string
}

func unpackSetUpReadReplicaParams(packed middleware.Parameters) (params SetUpReadReplicaParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeSetUpReadReplicaParams(args [1]string, argsEscaped bool, r *http.Request) (params SetUpReadReplicaParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// TemporarilyDisableReadonlyModeParams is parameters of temporarilyDisableReadonlyMode operation.
type TemporarilyDisableReadonlyModeParams struct {
	// Project ref.
	Ref string
}

func unpackTemporarilyDisableReadonlyModeParams(packed middleware.Parameters) (params TemporarilyDisableReadonlyModeParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeTemporarilyDisableReadonlyModeParams(args [1]string, argsEscaped bool, r *http.Request) (params TemporarilyDisableReadonlyModeParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateBranchParams is parameters of updateBranch operation.
type UpdateBranchParams struct {
	// Branch ID.
	BranchID string
}

func unpackUpdateBranchParams(packed middleware.Parameters) (params UpdateBranchParams) {
	{
		key := middleware.ParameterKey{
			Name: "branch_id",
			In:   "path",
		}
		params.BranchID = packed[key].(string)
	}
	return params
}

func decodeUpdateBranchParams(args [1]string, argsEscaped bool, r *http.Request) (params UpdateBranchParams, _ error) {
	// Decode path: branch_id.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.BranchID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "branch_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateConfigParams is parameters of updateConfig operation.
type UpdateConfigParams struct {
	// Project ref.
	Ref string
}

func unpackUpdateConfigParams(packed middleware.Parameters) (params UpdateConfigParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeUpdateConfigParams(args [1]string, argsEscaped bool, r *http.Request) (params UpdateConfigParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateFunctionParams is parameters of updateFunction operation.
type UpdateFunctionParams struct {
	// Project ref.
	Ref string
	// Function slug.
	FunctionSlug   string
	Slug           OptString
	Name           OptString
	VerifyJwt      OptBool
	ImportMap      OptBool
	EntrypointPath OptString
	ImportMapPath  OptString
}

func unpackUpdateFunctionParams(packed middleware.Parameters) (params UpdateFunctionParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "function_slug",
			In:   "path",
		}
		params.FunctionSlug = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "slug",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Slug = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "name",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Name = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "verify_jwt",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.VerifyJwt = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "import_map",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ImportMap = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "entrypoint_path",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EntrypointPath = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "import_map_path",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ImportMapPath = v.(OptString)
		}
	}
	return params
}

func decodeUpdateFunctionParams(args [2]string, argsEscaped bool, r *http.Request) (params UpdateFunctionParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: function_slug.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "function_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.FunctionSlug = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    0,
					MinLengthSet: false,
					MaxLength:    0,
					MaxLengthSet: false,
					Email:        false,
					Hostname:     false,
					Regex:        regexMap["/^[A-Za-z0-9_-]+$/"],
				}).Validate(string(params.FunctionSlug)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "function_slug",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: slug.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "slug",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSlugVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSlugVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Slug.SetTo(paramsDotSlugVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Slug.Get(); ok {
					if err := func() error {
						if err := (validate.String{
							MinLength:    0,
							MinLengthSet: false,
							MaxLength:    0,
							MaxLengthSet: false,
							Email:        false,
							Hostname:     false,
							Regex:        regexMap["/^[A-Za-z0-9_-]+$/"],
						}).Validate(string(value)); err != nil {
							return errors.Wrap(err, "string")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "slug",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: name.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotNameVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Name.SetTo(paramsDotNameVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "name",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: verify_jwt.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "verify_jwt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotVerifyJwtVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotVerifyJwtVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.VerifyJwt.SetTo(paramsDotVerifyJwtVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "verify_jwt",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: import_map.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "import_map",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotImportMapVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotImportMapVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ImportMap.SetTo(paramsDotImportMapVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "import_map",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: entrypoint_path.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "entrypoint_path",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEntrypointPathVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotEntrypointPathVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EntrypointPath.SetTo(paramsDotEntrypointPathVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "entrypoint_path",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: import_map_path.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "import_map_path",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotImportMapPathVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotImportMapPathVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ImportMapPath.SetTo(paramsDotImportMapPathVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "import_map_path",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// UpdatePgsodiumConfigParams is parameters of updatePgsodiumConfig operation.
type UpdatePgsodiumConfigParams struct {
	// Project ref.
	Ref string
}

func unpackUpdatePgsodiumConfigParams(packed middleware.Parameters) (params UpdatePgsodiumConfigParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeUpdatePgsodiumConfigParams(args [1]string, argsEscaped bool, r *http.Request) (params UpdatePgsodiumConfigParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdatePostgRESTConfigParams is parameters of updatePostgRESTConfig operation.
type UpdatePostgRESTConfigParams struct {
	// Project ref.
	Ref string
}

func unpackUpdatePostgRESTConfigParams(packed middleware.Parameters) (params UpdatePostgRESTConfigParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeUpdatePostgRESTConfigParams(args [1]string, argsEscaped bool, r *http.Request) (params UpdatePostgRESTConfigParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateProviderByIdParams is parameters of updateProviderById operation.
type UpdateProviderByIdParams struct {
	// Project ref.
	Ref        string
	ProviderID string
}

func unpackUpdateProviderByIdParams(packed middleware.Parameters) (params UpdateProviderByIdParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "provider_id",
			In:   "path",
		}
		params.ProviderID = packed[key].(string)
	}
	return params
}

func decodeUpdateProviderByIdParams(args [2]string, argsEscaped bool, r *http.Request) (params UpdateProviderByIdParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: provider_id.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "provider_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ProviderID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "provider_id",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateSslEnforcementConfigParams is parameters of updateSslEnforcementConfig operation.
type UpdateSslEnforcementConfigParams struct {
	// Project ref.
	Ref string
}

func unpackUpdateSslEnforcementConfigParams(packed middleware.Parameters) (params UpdateSslEnforcementConfigParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeUpdateSslEnforcementConfigParams(args [1]string, argsEscaped bool, r *http.Request) (params UpdateSslEnforcementConfigParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateV1AuthConfigParams is parameters of updateV1AuthConfig operation.
type UpdateV1AuthConfigParams struct {
	// Project ref.
	Ref string
}

func unpackUpdateV1AuthConfigParams(packed middleware.Parameters) (params UpdateV1AuthConfigParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeUpdateV1AuthConfigParams(args [1]string, argsEscaped bool, r *http.Request) (params UpdateV1AuthConfigParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpgradeEligibilityInformationParams is parameters of upgradeEligibilityInformation operation.
type UpgradeEligibilityInformationParams struct {
	// Project ref.
	Ref string
}

func unpackUpgradeEligibilityInformationParams(packed middleware.Parameters) (params UpgradeEligibilityInformationParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeUpgradeEligibilityInformationParams(args [1]string, argsEscaped bool, r *http.Request) (params UpgradeEligibilityInformationParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpgradeProjectParams is parameters of upgradeProject operation.
type UpgradeProjectParams struct {
	// Project ref.
	Ref string
}

func unpackUpgradeProjectParams(packed middleware.Parameters) (params UpgradeProjectParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeUpgradeProjectParams(args [1]string, argsEscaped bool, r *http.Request) (params UpgradeProjectParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// V1EnableDatabaseWebhooksParams is parameters of v1EnableDatabaseWebhooks operation.
type V1EnableDatabaseWebhooksParams struct {
	// Project ref.
	Ref string
}

func unpackV1EnableDatabaseWebhooksParams(packed middleware.Parameters) (params V1EnableDatabaseWebhooksParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeV1EnableDatabaseWebhooksParams(args [1]string, argsEscaped bool, r *http.Request) (params V1EnableDatabaseWebhooksParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// V1GetPgbouncerConfigParams is parameters of v1GetPgbouncerConfig operation.
type V1GetPgbouncerConfigParams struct {
	// Project ref.
	Ref string
}

func unpackV1GetPgbouncerConfigParams(packed middleware.Parameters) (params V1GetPgbouncerConfigParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeV1GetPgbouncerConfigParams(args [1]string, argsEscaped bool, r *http.Request) (params V1GetPgbouncerConfigParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// V1ListOrganizationMembersParams is parameters of v1ListOrganizationMembers operation.
type V1ListOrganizationMembersParams struct {
	Slug string
}

func unpackV1ListOrganizationMembersParams(packed middleware.Parameters) (params V1ListOrganizationMembersParams) {
	{
		key := middleware.ParameterKey{
			Name: "slug",
			In:   "path",
		}
		params.Slug = packed[key].(string)
	}
	return params
}

func decodeV1ListOrganizationMembersParams(args [1]string, argsEscaped bool, r *http.Request) (params V1ListOrganizationMembersParams, _ error) {
	// Decode path: slug.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Slug = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "slug",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// V1RestorePitrParams is parameters of v1RestorePitr operation.
type V1RestorePitrParams struct {
	// Project ref.
	Ref string
}

func unpackV1RestorePitrParams(packed middleware.Parameters) (params V1RestorePitrParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeV1RestorePitrParams(args [1]string, argsEscaped bool, r *http.Request) (params V1RestorePitrParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// V1RunQueryParams is parameters of v1RunQuery operation.
type V1RunQueryParams struct {
	// Project ref.
	Ref string
}

func unpackV1RunQueryParams(packed middleware.Parameters) (params V1RunQueryParams) {
	{
		key := middleware.ParameterKey{
			Name: "ref",
			In:   "path",
		}
		params.Ref = packed[key].(string)
	}
	return params
}

func decodeV1RunQueryParams(args [1]string, argsEscaped bool, r *http.Request) (params V1RunQueryParams, _ error) {
	// Decode path: ref.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := (validate.String{
					MinLength:    20,
					MinLengthSet: true,
					MaxLength:    20,
					MaxLengthSet: true,
					Email:        false,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(params.Ref)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ref",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}
