// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *ActivateVanitySubdomainResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActivateVanitySubdomainResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("custom_domain")
		e.Str(s.CustomDomain)
	}
}

var jsonFieldsNameOfActivateVanitySubdomainResponse = [1]string{
	0: "custom_domain",
}

// Decode decodes ActivateVanitySubdomainResponse from json.
func (s *ActivateVanitySubdomainResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivateVanitySubdomainResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "custom_domain":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CustomDomain = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_domain\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActivateVanitySubdomainResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActivateVanitySubdomainResponse) {
					name = jsonFieldsNameOfActivateVanitySubdomainResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivateVanitySubdomainResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivateVanitySubdomainResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApiKeyResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApiKeyResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("api_key")
		e.Str(s.APIKey)
	}
}

var jsonFieldsNameOfApiKeyResponse = [2]string{
	0: "name",
	1: "api_key",
}

// Decode decodes ApiKeyResponse from json.
func (s *ApiKeyResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApiKeyResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "api_key":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.APIKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api_key\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApiKeyResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfApiKeyResponse) {
					name = jsonFieldsNameOfApiKeyResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApiKeyResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApiKeyResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AttributeMapping) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AttributeMapping) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("keys")
		s.Keys.Encode(e)
	}
}

var jsonFieldsNameOfAttributeMapping = [1]string{
	0: "keys",
}

// Decode decodes AttributeMapping from json.
func (s *AttributeMapping) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AttributeMapping to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "keys":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Keys.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keys\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AttributeMapping")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAttributeMapping) {
					name = jsonFieldsNameOfAttributeMapping[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AttributeMapping) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AttributeMapping) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s AttributeMappingKeys) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s AttributeMappingKeys) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes AttributeMappingKeys from json.
func (s *AttributeMappingKeys) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AttributeMappingKeys to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem AttributeValue
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AttributeMappingKeys")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AttributeMappingKeys) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AttributeMappingKeys) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AttributeValue) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AttributeValue) encodeFields(e *jx.Encoder) {
	{
		if s.Default.Set {
			e.FieldStart("default")
			s.Default.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Names != nil {
			e.FieldStart("names")
			e.ArrStart()
			for _, elem := range s.Names {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAttributeValue = [3]string{
	0: "default",
	1: "name",
	2: "names",
}

// Decode decodes AttributeValue from json.
func (s *AttributeValue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AttributeValue to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "default":
			if err := func() error {
				s.Default.Reset()
				if err := s.Default.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "names":
			if err := func() error {
				s.Names = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Names = append(s.Names, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"names\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AttributeValue")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AttributeValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AttributeValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AttributeValueDefault as json.
func (s AttributeValueDefault) Encode(e *jx.Encoder) {
	switch s.Type {
	case AttributeValueDefault0AttributeValueDefault:
		s.AttributeValueDefault0.Encode(e)
	case Float64AttributeValueDefault:
		e.Float64(s.Float64)
	case StringAttributeValueDefault:
		e.Str(s.String)
	case BoolAttributeValueDefault:
		e.Bool(s.Bool)
	}
}

// Decode decodes AttributeValueDefault from json.
func (s *AttributeValueDefault) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AttributeValueDefault to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Bool:
		v, err := d.Bool()
		s.Bool = bool(v)
		if err != nil {
			return err
		}
		s.Type = BoolAttributeValueDefault
	case jx.Number:
		v, err := d.Float64()
		s.Float64 = float64(v)
		if err != nil {
			return err
		}
		s.Type = Float64AttributeValueDefault
	case jx.Object:
		if err := s.AttributeValueDefault0.Decode(d); err != nil {
			return err
		}
		s.Type = AttributeValueDefault0AttributeValueDefault
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringAttributeValueDefault
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AttributeValueDefault) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AttributeValueDefault) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AttributeValueDefault0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AttributeValueDefault0) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfAttributeValueDefault0 = [0]string{}

// Decode decodes AttributeValueDefault0 from json.
func (s *AttributeValueDefault0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AttributeValueDefault0 to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode AttributeValueDefault0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AttributeValueDefault0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AttributeValueDefault0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthConfigResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthConfigResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("disable_signup")
		s.DisableSignup.Encode(e)
	}
	{
		e.FieldStart("external_anonymous_users_enabled")
		s.ExternalAnonymousUsersEnabled.Encode(e)
	}
	{
		e.FieldStart("external_apple_additional_client_ids")
		s.ExternalAppleAdditionalClientIds.Encode(e)
	}
	{
		e.FieldStart("external_apple_client_id")
		s.ExternalAppleClientID.Encode(e)
	}
	{
		e.FieldStart("external_apple_enabled")
		s.ExternalAppleEnabled.Encode(e)
	}
	{
		e.FieldStart("external_apple_secret")
		s.ExternalAppleSecret.Encode(e)
	}
	{
		e.FieldStart("external_azure_client_id")
		s.ExternalAzureClientID.Encode(e)
	}
	{
		e.FieldStart("external_azure_enabled")
		s.ExternalAzureEnabled.Encode(e)
	}
	{
		e.FieldStart("external_azure_secret")
		s.ExternalAzureSecret.Encode(e)
	}
	{
		e.FieldStart("external_azure_url")
		s.ExternalAzureURL.Encode(e)
	}
	{
		e.FieldStart("external_bitbucket_client_id")
		s.ExternalBitbucketClientID.Encode(e)
	}
	{
		e.FieldStart("external_bitbucket_enabled")
		s.ExternalBitbucketEnabled.Encode(e)
	}
	{
		e.FieldStart("external_bitbucket_secret")
		s.ExternalBitbucketSecret.Encode(e)
	}
	{
		e.FieldStart("external_discord_client_id")
		s.ExternalDiscordClientID.Encode(e)
	}
	{
		e.FieldStart("external_discord_enabled")
		s.ExternalDiscordEnabled.Encode(e)
	}
	{
		e.FieldStart("external_discord_secret")
		s.ExternalDiscordSecret.Encode(e)
	}
	{
		e.FieldStart("external_email_enabled")
		s.ExternalEmailEnabled.Encode(e)
	}
	{
		e.FieldStart("external_facebook_client_id")
		s.ExternalFacebookClientID.Encode(e)
	}
	{
		e.FieldStart("external_facebook_enabled")
		s.ExternalFacebookEnabled.Encode(e)
	}
	{
		e.FieldStart("external_facebook_secret")
		s.ExternalFacebookSecret.Encode(e)
	}
	{
		e.FieldStart("external_figma_client_id")
		s.ExternalFigmaClientID.Encode(e)
	}
	{
		e.FieldStart("external_figma_enabled")
		s.ExternalFigmaEnabled.Encode(e)
	}
	{
		e.FieldStart("external_figma_secret")
		s.ExternalFigmaSecret.Encode(e)
	}
	{
		e.FieldStart("external_github_client_id")
		s.ExternalGithubClientID.Encode(e)
	}
	{
		e.FieldStart("external_github_enabled")
		s.ExternalGithubEnabled.Encode(e)
	}
	{
		e.FieldStart("external_github_secret")
		s.ExternalGithubSecret.Encode(e)
	}
	{
		e.FieldStart("external_gitlab_client_id")
		s.ExternalGitlabClientID.Encode(e)
	}
	{
		e.FieldStart("external_gitlab_enabled")
		s.ExternalGitlabEnabled.Encode(e)
	}
	{
		e.FieldStart("external_gitlab_secret")
		s.ExternalGitlabSecret.Encode(e)
	}
	{
		e.FieldStart("external_gitlab_url")
		s.ExternalGitlabURL.Encode(e)
	}
	{
		e.FieldStart("external_google_additional_client_ids")
		s.ExternalGoogleAdditionalClientIds.Encode(e)
	}
	{
		e.FieldStart("external_google_client_id")
		s.ExternalGoogleClientID.Encode(e)
	}
	{
		e.FieldStart("external_google_enabled")
		s.ExternalGoogleEnabled.Encode(e)
	}
	{
		e.FieldStart("external_google_secret")
		s.ExternalGoogleSecret.Encode(e)
	}
	{
		e.FieldStart("external_google_skip_nonce_check")
		s.ExternalGoogleSkipNonceCheck.Encode(e)
	}
	{
		e.FieldStart("external_kakao_client_id")
		s.ExternalKakaoClientID.Encode(e)
	}
	{
		e.FieldStart("external_kakao_enabled")
		s.ExternalKakaoEnabled.Encode(e)
	}
	{
		e.FieldStart("external_kakao_secret")
		s.ExternalKakaoSecret.Encode(e)
	}
	{
		e.FieldStart("external_keycloak_client_id")
		s.ExternalKeycloakClientID.Encode(e)
	}
	{
		e.FieldStart("external_keycloak_enabled")
		s.ExternalKeycloakEnabled.Encode(e)
	}
	{
		e.FieldStart("external_keycloak_secret")
		s.ExternalKeycloakSecret.Encode(e)
	}
	{
		e.FieldStart("external_keycloak_url")
		s.ExternalKeycloakURL.Encode(e)
	}
	{
		e.FieldStart("external_linkedin_oidc_client_id")
		s.ExternalLinkedinOidcClientID.Encode(e)
	}
	{
		e.FieldStart("external_linkedin_oidc_enabled")
		s.ExternalLinkedinOidcEnabled.Encode(e)
	}
	{
		e.FieldStart("external_linkedin_oidc_secret")
		s.ExternalLinkedinOidcSecret.Encode(e)
	}
	{
		e.FieldStart("external_notion_client_id")
		s.ExternalNotionClientID.Encode(e)
	}
	{
		e.FieldStart("external_notion_enabled")
		s.ExternalNotionEnabled.Encode(e)
	}
	{
		e.FieldStart("external_notion_secret")
		s.ExternalNotionSecret.Encode(e)
	}
	{
		e.FieldStart("external_phone_enabled")
		s.ExternalPhoneEnabled.Encode(e)
	}
	{
		e.FieldStart("external_slack_client_id")
		s.ExternalSlackClientID.Encode(e)
	}
	{
		e.FieldStart("external_slack_enabled")
		s.ExternalSlackEnabled.Encode(e)
	}
	{
		e.FieldStart("external_slack_secret")
		s.ExternalSlackSecret.Encode(e)
	}
	{
		e.FieldStart("external_spotify_client_id")
		s.ExternalSpotifyClientID.Encode(e)
	}
	{
		e.FieldStart("external_spotify_enabled")
		s.ExternalSpotifyEnabled.Encode(e)
	}
	{
		e.FieldStart("external_spotify_secret")
		s.ExternalSpotifySecret.Encode(e)
	}
	{
		e.FieldStart("external_twitch_client_id")
		s.ExternalTwitchClientID.Encode(e)
	}
	{
		e.FieldStart("external_twitch_enabled")
		s.ExternalTwitchEnabled.Encode(e)
	}
	{
		e.FieldStart("external_twitch_secret")
		s.ExternalTwitchSecret.Encode(e)
	}
	{
		e.FieldStart("external_twitter_client_id")
		s.ExternalTwitterClientID.Encode(e)
	}
	{
		e.FieldStart("external_twitter_enabled")
		s.ExternalTwitterEnabled.Encode(e)
	}
	{
		e.FieldStart("external_twitter_secret")
		s.ExternalTwitterSecret.Encode(e)
	}
	{
		e.FieldStart("external_workos_client_id")
		s.ExternalWorkosClientID.Encode(e)
	}
	{
		e.FieldStart("external_workos_enabled")
		s.ExternalWorkosEnabled.Encode(e)
	}
	{
		e.FieldStart("external_workos_secret")
		s.ExternalWorkosSecret.Encode(e)
	}
	{
		e.FieldStart("external_workos_url")
		s.ExternalWorkosURL.Encode(e)
	}
	{
		e.FieldStart("external_zoom_client_id")
		s.ExternalZoomClientID.Encode(e)
	}
	{
		e.FieldStart("external_zoom_enabled")
		s.ExternalZoomEnabled.Encode(e)
	}
	{
		e.FieldStart("external_zoom_secret")
		s.ExternalZoomSecret.Encode(e)
	}
	{
		e.FieldStart("hook_custom_access_token_enabled")
		s.HookCustomAccessTokenEnabled.Encode(e)
	}
	{
		e.FieldStart("hook_custom_access_token_uri")
		s.HookCustomAccessTokenURI.Encode(e)
	}
	{
		e.FieldStart("hook_mfa_verification_attempt_enabled")
		s.HookMfaVerificationAttemptEnabled.Encode(e)
	}
	{
		e.FieldStart("hook_mfa_verification_attempt_uri")
		s.HookMfaVerificationAttemptURI.Encode(e)
	}
	{
		e.FieldStart("hook_password_verification_attempt_enabled")
		s.HookPasswordVerificationAttemptEnabled.Encode(e)
	}
	{
		e.FieldStart("hook_password_verification_attempt_uri")
		s.HookPasswordVerificationAttemptURI.Encode(e)
	}
	{
		e.FieldStart("jwt_exp")
		s.JwtExp.Encode(e)
	}
	{
		e.FieldStart("mailer_allow_unverified_email_sign_ins")
		s.MailerAllowUnverifiedEmailSignIns.Encode(e)
	}
	{
		e.FieldStart("mailer_autoconfirm")
		s.MailerAutoconfirm.Encode(e)
	}
	{
		e.FieldStart("mailer_otp_exp")
		s.MailerOtpExp.Encode(e)
	}
	{
		e.FieldStart("mailer_secure_email_change_enabled")
		s.MailerSecureEmailChangeEnabled.Encode(e)
	}
	{
		e.FieldStart("mailer_subjects_confirmation")
		s.MailerSubjectsConfirmation.Encode(e)
	}
	{
		e.FieldStart("mailer_subjects_email_change")
		s.MailerSubjectsEmailChange.Encode(e)
	}
	{
		e.FieldStart("mailer_subjects_invite")
		s.MailerSubjectsInvite.Encode(e)
	}
	{
		e.FieldStart("mailer_subjects_magic_link")
		s.MailerSubjectsMagicLink.Encode(e)
	}
	{
		e.FieldStart("mailer_subjects_recovery")
		s.MailerSubjectsRecovery.Encode(e)
	}
	{
		e.FieldStart("mailer_subjects_reauthentication")
		s.MailerSubjectsReauthentication.Encode(e)
	}
	{
		e.FieldStart("mailer_templates_confirmation_content")
		s.MailerTemplatesConfirmationContent.Encode(e)
	}
	{
		e.FieldStart("mailer_templates_email_change_content")
		s.MailerTemplatesEmailChangeContent.Encode(e)
	}
	{
		e.FieldStart("mailer_templates_invite_content")
		s.MailerTemplatesInviteContent.Encode(e)
	}
	{
		e.FieldStart("mailer_templates_magic_link_content")
		s.MailerTemplatesMagicLinkContent.Encode(e)
	}
	{
		e.FieldStart("mailer_templates_recovery_content")
		s.MailerTemplatesRecoveryContent.Encode(e)
	}
	{
		e.FieldStart("mailer_templates_reauthentication_content")
		s.MailerTemplatesReauthenticationContent.Encode(e)
	}
	{
		e.FieldStart("mfa_max_enrolled_factors")
		s.MfaMaxEnrolledFactors.Encode(e)
	}
	{
		e.FieldStart("password_hibp_enabled")
		s.PasswordHibpEnabled.Encode(e)
	}
	{
		e.FieldStart("password_min_length")
		s.PasswordMinLength.Encode(e)
	}
	{
		e.FieldStart("password_required_characters")
		s.PasswordRequiredCharacters.Encode(e)
	}
	{
		e.FieldStart("rate_limit_anonymous_users")
		s.RateLimitAnonymousUsers.Encode(e)
	}
	{
		e.FieldStart("rate_limit_email_sent")
		s.RateLimitEmailSent.Encode(e)
	}
	{
		e.FieldStart("rate_limit_sms_sent")
		s.RateLimitSMSSent.Encode(e)
	}
	{
		e.FieldStart("rate_limit_token_refresh")
		s.RateLimitTokenRefresh.Encode(e)
	}
	{
		e.FieldStart("rate_limit_verify")
		s.RateLimitVerify.Encode(e)
	}
	{
		e.FieldStart("refresh_token_rotation_enabled")
		s.RefreshTokenRotationEnabled.Encode(e)
	}
	{
		e.FieldStart("saml_enabled")
		s.SamlEnabled.Encode(e)
	}
	{
		e.FieldStart("security_captcha_enabled")
		s.SecurityCaptchaEnabled.Encode(e)
	}
	{
		e.FieldStart("security_captcha_provider")
		s.SecurityCaptchaProvider.Encode(e)
	}
	{
		e.FieldStart("security_captcha_secret")
		s.SecurityCaptchaSecret.Encode(e)
	}
	{
		e.FieldStart("security_manual_linking_enabled")
		s.SecurityManualLinkingEnabled.Encode(e)
	}
	{
		e.FieldStart("security_refresh_token_reuse_interval")
		s.SecurityRefreshTokenReuseInterval.Encode(e)
	}
	{
		e.FieldStart("security_update_password_require_reauthentication")
		s.SecurityUpdatePasswordRequireReauthentication.Encode(e)
	}
	{
		e.FieldStart("sessions_inactivity_timeout")
		s.SessionsInactivityTimeout.Encode(e)
	}
	{
		e.FieldStart("sessions_single_per_user")
		s.SessionsSinglePerUser.Encode(e)
	}
	{
		e.FieldStart("sessions_tags")
		s.SessionsTags.Encode(e)
	}
	{
		e.FieldStart("sessions_timebox")
		s.SessionsTimebox.Encode(e)
	}
	{
		e.FieldStart("site_url")
		s.SiteURL.Encode(e)
	}
	{
		e.FieldStart("sms_autoconfirm")
		s.SMSAutoconfirm.Encode(e)
	}
	{
		e.FieldStart("sms_max_frequency")
		s.SMSMaxFrequency.Encode(e)
	}
	{
		e.FieldStart("sms_messagebird_access_key")
		s.SMSMessagebirdAccessKey.Encode(e)
	}
	{
		e.FieldStart("sms_messagebird_originator")
		s.SMSMessagebirdOriginator.Encode(e)
	}
	{
		e.FieldStart("sms_otp_exp")
		s.SMSOtpExp.Encode(e)
	}
	{
		e.FieldStart("sms_otp_length")
		s.SMSOtpLength.Encode(e)
	}
	{
		e.FieldStart("sms_provider")
		s.SMSProvider.Encode(e)
	}
	{
		e.FieldStart("sms_template")
		s.SMSTemplate.Encode(e)
	}
	{
		e.FieldStart("sms_test_otp")
		s.SMSTestOtp.Encode(e)
	}
	{
		e.FieldStart("sms_test_otp_valid_until")
		s.SMSTestOtpValidUntil.Encode(e)
	}
	{
		e.FieldStart("sms_textlocal_api_key")
		s.SMSTextlocalAPIKey.Encode(e)
	}
	{
		e.FieldStart("sms_textlocal_sender")
		s.SMSTextlocalSender.Encode(e)
	}
	{
		e.FieldStart("sms_twilio_account_sid")
		s.SMSTwilioAccountSid.Encode(e)
	}
	{
		e.FieldStart("sms_twilio_auth_token")
		s.SMSTwilioAuthToken.Encode(e)
	}
	{
		e.FieldStart("sms_twilio_content_sid")
		s.SMSTwilioContentSid.Encode(e)
	}
	{
		e.FieldStart("sms_twilio_message_service_sid")
		s.SMSTwilioMessageServiceSid.Encode(e)
	}
	{
		e.FieldStart("sms_twilio_verify_account_sid")
		s.SMSTwilioVerifyAccountSid.Encode(e)
	}
	{
		e.FieldStart("sms_twilio_verify_auth_token")
		s.SMSTwilioVerifyAuthToken.Encode(e)
	}
	{
		e.FieldStart("sms_twilio_verify_message_service_sid")
		s.SMSTwilioVerifyMessageServiceSid.Encode(e)
	}
	{
		e.FieldStart("sms_vonage_api_key")
		s.SMSVonageAPIKey.Encode(e)
	}
	{
		e.FieldStart("sms_vonage_api_secret")
		s.SMSVonageAPISecret.Encode(e)
	}
	{
		e.FieldStart("sms_vonage_from")
		s.SMSVonageFrom.Encode(e)
	}
	{
		e.FieldStart("smtp_admin_email")
		s.SMTPAdminEmail.Encode(e)
	}
	{
		e.FieldStart("smtp_host")
		s.SMTPHost.Encode(e)
	}
	{
		e.FieldStart("smtp_max_frequency")
		s.SMTPMaxFrequency.Encode(e)
	}
	{
		e.FieldStart("smtp_pass")
		s.SMTPPass.Encode(e)
	}
	{
		e.FieldStart("smtp_port")
		s.SMTPPort.Encode(e)
	}
	{
		e.FieldStart("smtp_sender_name")
		s.SMTPSenderName.Encode(e)
	}
	{
		e.FieldStart("smtp_user")
		s.SMTPUser.Encode(e)
	}
	{
		e.FieldStart("uri_allow_list")
		s.URIAllowList.Encode(e)
	}
}

var jsonFieldsNameOfAuthConfigResponse = [143]string{
	0:   "disable_signup",
	1:   "external_anonymous_users_enabled",
	2:   "external_apple_additional_client_ids",
	3:   "external_apple_client_id",
	4:   "external_apple_enabled",
	5:   "external_apple_secret",
	6:   "external_azure_client_id",
	7:   "external_azure_enabled",
	8:   "external_azure_secret",
	9:   "external_azure_url",
	10:  "external_bitbucket_client_id",
	11:  "external_bitbucket_enabled",
	12:  "external_bitbucket_secret",
	13:  "external_discord_client_id",
	14:  "external_discord_enabled",
	15:  "external_discord_secret",
	16:  "external_email_enabled",
	17:  "external_facebook_client_id",
	18:  "external_facebook_enabled",
	19:  "external_facebook_secret",
	20:  "external_figma_client_id",
	21:  "external_figma_enabled",
	22:  "external_figma_secret",
	23:  "external_github_client_id",
	24:  "external_github_enabled",
	25:  "external_github_secret",
	26:  "external_gitlab_client_id",
	27:  "external_gitlab_enabled",
	28:  "external_gitlab_secret",
	29:  "external_gitlab_url",
	30:  "external_google_additional_client_ids",
	31:  "external_google_client_id",
	32:  "external_google_enabled",
	33:  "external_google_secret",
	34:  "external_google_skip_nonce_check",
	35:  "external_kakao_client_id",
	36:  "external_kakao_enabled",
	37:  "external_kakao_secret",
	38:  "external_keycloak_client_id",
	39:  "external_keycloak_enabled",
	40:  "external_keycloak_secret",
	41:  "external_keycloak_url",
	42:  "external_linkedin_oidc_client_id",
	43:  "external_linkedin_oidc_enabled",
	44:  "external_linkedin_oidc_secret",
	45:  "external_notion_client_id",
	46:  "external_notion_enabled",
	47:  "external_notion_secret",
	48:  "external_phone_enabled",
	49:  "external_slack_client_id",
	50:  "external_slack_enabled",
	51:  "external_slack_secret",
	52:  "external_spotify_client_id",
	53:  "external_spotify_enabled",
	54:  "external_spotify_secret",
	55:  "external_twitch_client_id",
	56:  "external_twitch_enabled",
	57:  "external_twitch_secret",
	58:  "external_twitter_client_id",
	59:  "external_twitter_enabled",
	60:  "external_twitter_secret",
	61:  "external_workos_client_id",
	62:  "external_workos_enabled",
	63:  "external_workos_secret",
	64:  "external_workos_url",
	65:  "external_zoom_client_id",
	66:  "external_zoom_enabled",
	67:  "external_zoom_secret",
	68:  "hook_custom_access_token_enabled",
	69:  "hook_custom_access_token_uri",
	70:  "hook_mfa_verification_attempt_enabled",
	71:  "hook_mfa_verification_attempt_uri",
	72:  "hook_password_verification_attempt_enabled",
	73:  "hook_password_verification_attempt_uri",
	74:  "jwt_exp",
	75:  "mailer_allow_unverified_email_sign_ins",
	76:  "mailer_autoconfirm",
	77:  "mailer_otp_exp",
	78:  "mailer_secure_email_change_enabled",
	79:  "mailer_subjects_confirmation",
	80:  "mailer_subjects_email_change",
	81:  "mailer_subjects_invite",
	82:  "mailer_subjects_magic_link",
	83:  "mailer_subjects_recovery",
	84:  "mailer_subjects_reauthentication",
	85:  "mailer_templates_confirmation_content",
	86:  "mailer_templates_email_change_content",
	87:  "mailer_templates_invite_content",
	88:  "mailer_templates_magic_link_content",
	89:  "mailer_templates_recovery_content",
	90:  "mailer_templates_reauthentication_content",
	91:  "mfa_max_enrolled_factors",
	92:  "password_hibp_enabled",
	93:  "password_min_length",
	94:  "password_required_characters",
	95:  "rate_limit_anonymous_users",
	96:  "rate_limit_email_sent",
	97:  "rate_limit_sms_sent",
	98:  "rate_limit_token_refresh",
	99:  "rate_limit_verify",
	100: "refresh_token_rotation_enabled",
	101: "saml_enabled",
	102: "security_captcha_enabled",
	103: "security_captcha_provider",
	104: "security_captcha_secret",
	105: "security_manual_linking_enabled",
	106: "security_refresh_token_reuse_interval",
	107: "security_update_password_require_reauthentication",
	108: "sessions_inactivity_timeout",
	109: "sessions_single_per_user",
	110: "sessions_tags",
	111: "sessions_timebox",
	112: "site_url",
	113: "sms_autoconfirm",
	114: "sms_max_frequency",
	115: "sms_messagebird_access_key",
	116: "sms_messagebird_originator",
	117: "sms_otp_exp",
	118: "sms_otp_length",
	119: "sms_provider",
	120: "sms_template",
	121: "sms_test_otp",
	122: "sms_test_otp_valid_until",
	123: "sms_textlocal_api_key",
	124: "sms_textlocal_sender",
	125: "sms_twilio_account_sid",
	126: "sms_twilio_auth_token",
	127: "sms_twilio_content_sid",
	128: "sms_twilio_message_service_sid",
	129: "sms_twilio_verify_account_sid",
	130: "sms_twilio_verify_auth_token",
	131: "sms_twilio_verify_message_service_sid",
	132: "sms_vonage_api_key",
	133: "sms_vonage_api_secret",
	134: "sms_vonage_from",
	135: "smtp_admin_email",
	136: "smtp_host",
	137: "smtp_max_frequency",
	138: "smtp_pass",
	139: "smtp_port",
	140: "smtp_sender_name",
	141: "smtp_user",
	142: "uri_allow_list",
}

// Decode decodes AuthConfigResponse from json.
func (s *AuthConfigResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthConfigResponse to nil")
	}
	var requiredBitSet [18]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "disable_signup":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.DisableSignup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_signup\"")
			}
		case "external_anonymous_users_enabled":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ExternalAnonymousUsersEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_anonymous_users_enabled\"")
			}
		case "external_apple_additional_client_ids":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.ExternalAppleAdditionalClientIds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_apple_additional_client_ids\"")
			}
		case "external_apple_client_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.ExternalAppleClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_apple_client_id\"")
			}
		case "external_apple_enabled":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.ExternalAppleEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_apple_enabled\"")
			}
		case "external_apple_secret":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.ExternalAppleSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_apple_secret\"")
			}
		case "external_azure_client_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.ExternalAzureClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_azure_client_id\"")
			}
		case "external_azure_enabled":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.ExternalAzureEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_azure_enabled\"")
			}
		case "external_azure_secret":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.ExternalAzureSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_azure_secret\"")
			}
		case "external_azure_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.ExternalAzureURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_azure_url\"")
			}
		case "external_bitbucket_client_id":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.ExternalBitbucketClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_bitbucket_client_id\"")
			}
		case "external_bitbucket_enabled":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.ExternalBitbucketEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_bitbucket_enabled\"")
			}
		case "external_bitbucket_secret":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.ExternalBitbucketSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_bitbucket_secret\"")
			}
		case "external_discord_client_id":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.ExternalDiscordClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_discord_client_id\"")
			}
		case "external_discord_enabled":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.ExternalDiscordEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_discord_enabled\"")
			}
		case "external_discord_secret":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.ExternalDiscordSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_discord_secret\"")
			}
		case "external_email_enabled":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.ExternalEmailEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_email_enabled\"")
			}
		case "external_facebook_client_id":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.ExternalFacebookClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_facebook_client_id\"")
			}
		case "external_facebook_enabled":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.ExternalFacebookEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_facebook_enabled\"")
			}
		case "external_facebook_secret":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.ExternalFacebookSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_facebook_secret\"")
			}
		case "external_figma_client_id":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.ExternalFigmaClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_figma_client_id\"")
			}
		case "external_figma_enabled":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.ExternalFigmaEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_figma_enabled\"")
			}
		case "external_figma_secret":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.ExternalFigmaSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_figma_secret\"")
			}
		case "external_github_client_id":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				if err := s.ExternalGithubClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_github_client_id\"")
			}
		case "external_github_enabled":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				if err := s.ExternalGithubEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_github_enabled\"")
			}
		case "external_github_secret":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				if err := s.ExternalGithubSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_github_secret\"")
			}
		case "external_gitlab_client_id":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				if err := s.ExternalGitlabClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_gitlab_client_id\"")
			}
		case "external_gitlab_enabled":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				if err := s.ExternalGitlabEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_gitlab_enabled\"")
			}
		case "external_gitlab_secret":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.ExternalGitlabSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_gitlab_secret\"")
			}
		case "external_gitlab_url":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.ExternalGitlabURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_gitlab_url\"")
			}
		case "external_google_additional_client_ids":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.ExternalGoogleAdditionalClientIds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_google_additional_client_ids\"")
			}
		case "external_google_client_id":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				if err := s.ExternalGoogleClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_google_client_id\"")
			}
		case "external_google_enabled":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				if err := s.ExternalGoogleEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_google_enabled\"")
			}
		case "external_google_secret":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				if err := s.ExternalGoogleSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_google_secret\"")
			}
		case "external_google_skip_nonce_check":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				if err := s.ExternalGoogleSkipNonceCheck.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_google_skip_nonce_check\"")
			}
		case "external_kakao_client_id":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				if err := s.ExternalKakaoClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_kakao_client_id\"")
			}
		case "external_kakao_enabled":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				if err := s.ExternalKakaoEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_kakao_enabled\"")
			}
		case "external_kakao_secret":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				if err := s.ExternalKakaoSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_kakao_secret\"")
			}
		case "external_keycloak_client_id":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				if err := s.ExternalKeycloakClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_keycloak_client_id\"")
			}
		case "external_keycloak_enabled":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				if err := s.ExternalKeycloakEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_keycloak_enabled\"")
			}
		case "external_keycloak_secret":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				if err := s.ExternalKeycloakSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_keycloak_secret\"")
			}
		case "external_keycloak_url":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				if err := s.ExternalKeycloakURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_keycloak_url\"")
			}
		case "external_linkedin_oidc_client_id":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				if err := s.ExternalLinkedinOidcClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_linkedin_oidc_client_id\"")
			}
		case "external_linkedin_oidc_enabled":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				if err := s.ExternalLinkedinOidcEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_linkedin_oidc_enabled\"")
			}
		case "external_linkedin_oidc_secret":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				if err := s.ExternalLinkedinOidcSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_linkedin_oidc_secret\"")
			}
		case "external_notion_client_id":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				if err := s.ExternalNotionClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_notion_client_id\"")
			}
		case "external_notion_enabled":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				if err := s.ExternalNotionEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_notion_enabled\"")
			}
		case "external_notion_secret":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				if err := s.ExternalNotionSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_notion_secret\"")
			}
		case "external_phone_enabled":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				if err := s.ExternalPhoneEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_phone_enabled\"")
			}
		case "external_slack_client_id":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				if err := s.ExternalSlackClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_slack_client_id\"")
			}
		case "external_slack_enabled":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				if err := s.ExternalSlackEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_slack_enabled\"")
			}
		case "external_slack_secret":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				if err := s.ExternalSlackSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_slack_secret\"")
			}
		case "external_spotify_client_id":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				if err := s.ExternalSpotifyClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_spotify_client_id\"")
			}
		case "external_spotify_enabled":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				if err := s.ExternalSpotifyEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_spotify_enabled\"")
			}
		case "external_spotify_secret":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				if err := s.ExternalSpotifySecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_spotify_secret\"")
			}
		case "external_twitch_client_id":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				if err := s.ExternalTwitchClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_twitch_client_id\"")
			}
		case "external_twitch_enabled":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				if err := s.ExternalTwitchEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_twitch_enabled\"")
			}
		case "external_twitch_secret":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				if err := s.ExternalTwitchSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_twitch_secret\"")
			}
		case "external_twitter_client_id":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				if err := s.ExternalTwitterClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_twitter_client_id\"")
			}
		case "external_twitter_enabled":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				if err := s.ExternalTwitterEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_twitter_enabled\"")
			}
		case "external_twitter_secret":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				if err := s.ExternalTwitterSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_twitter_secret\"")
			}
		case "external_workos_client_id":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				if err := s.ExternalWorkosClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_workos_client_id\"")
			}
		case "external_workos_enabled":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				if err := s.ExternalWorkosEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_workos_enabled\"")
			}
		case "external_workos_secret":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				if err := s.ExternalWorkosSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_workos_secret\"")
			}
		case "external_workos_url":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				if err := s.ExternalWorkosURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_workos_url\"")
			}
		case "external_zoom_client_id":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				if err := s.ExternalZoomClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_zoom_client_id\"")
			}
		case "external_zoom_enabled":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				if err := s.ExternalZoomEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_zoom_enabled\"")
			}
		case "external_zoom_secret":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				if err := s.ExternalZoomSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_zoom_secret\"")
			}
		case "hook_custom_access_token_enabled":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				if err := s.HookCustomAccessTokenEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hook_custom_access_token_enabled\"")
			}
		case "hook_custom_access_token_uri":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				if err := s.HookCustomAccessTokenURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hook_custom_access_token_uri\"")
			}
		case "hook_mfa_verification_attempt_enabled":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				if err := s.HookMfaVerificationAttemptEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hook_mfa_verification_attempt_enabled\"")
			}
		case "hook_mfa_verification_attempt_uri":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				if err := s.HookMfaVerificationAttemptURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hook_mfa_verification_attempt_uri\"")
			}
		case "hook_password_verification_attempt_enabled":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				if err := s.HookPasswordVerificationAttemptEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hook_password_verification_attempt_enabled\"")
			}
		case "hook_password_verification_attempt_uri":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				if err := s.HookPasswordVerificationAttemptURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hook_password_verification_attempt_uri\"")
			}
		case "jwt_exp":
			requiredBitSet[9] |= 1 << 2
			if err := func() error {
				if err := s.JwtExp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jwt_exp\"")
			}
		case "mailer_allow_unverified_email_sign_ins":
			requiredBitSet[9] |= 1 << 3
			if err := func() error {
				if err := s.MailerAllowUnverifiedEmailSignIns.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mailer_allow_unverified_email_sign_ins\"")
			}
		case "mailer_autoconfirm":
			requiredBitSet[9] |= 1 << 4
			if err := func() error {
				if err := s.MailerAutoconfirm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mailer_autoconfirm\"")
			}
		case "mailer_otp_exp":
			requiredBitSet[9] |= 1 << 5
			if err := func() error {
				if err := s.MailerOtpExp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mailer_otp_exp\"")
			}
		case "mailer_secure_email_change_enabled":
			requiredBitSet[9] |= 1 << 6
			if err := func() error {
				if err := s.MailerSecureEmailChangeEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mailer_secure_email_change_enabled\"")
			}
		case "mailer_subjects_confirmation":
			requiredBitSet[9] |= 1 << 7
			if err := func() error {
				if err := s.MailerSubjectsConfirmation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mailer_subjects_confirmation\"")
			}
		case "mailer_subjects_email_change":
			requiredBitSet[10] |= 1 << 0
			if err := func() error {
				if err := s.MailerSubjectsEmailChange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mailer_subjects_email_change\"")
			}
		case "mailer_subjects_invite":
			requiredBitSet[10] |= 1 << 1
			if err := func() error {
				if err := s.MailerSubjectsInvite.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mailer_subjects_invite\"")
			}
		case "mailer_subjects_magic_link":
			requiredBitSet[10] |= 1 << 2
			if err := func() error {
				if err := s.MailerSubjectsMagicLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mailer_subjects_magic_link\"")
			}
		case "mailer_subjects_recovery":
			requiredBitSet[10] |= 1 << 3
			if err := func() error {
				if err := s.MailerSubjectsRecovery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mailer_subjects_recovery\"")
			}
		case "mailer_subjects_reauthentication":
			requiredBitSet[10] |= 1 << 4
			if err := func() error {
				if err := s.MailerSubjectsReauthentication.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mailer_subjects_reauthentication\"")
			}
		case "mailer_templates_confirmation_content":
			requiredBitSet[10] |= 1 << 5
			if err := func() error {
				if err := s.MailerTemplatesConfirmationContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mailer_templates_confirmation_content\"")
			}
		case "mailer_templates_email_change_content":
			requiredBitSet[10] |= 1 << 6
			if err := func() error {
				if err := s.MailerTemplatesEmailChangeContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mailer_templates_email_change_content\"")
			}
		case "mailer_templates_invite_content":
			requiredBitSet[10] |= 1 << 7
			if err := func() error {
				if err := s.MailerTemplatesInviteContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mailer_templates_invite_content\"")
			}
		case "mailer_templates_magic_link_content":
			requiredBitSet[11] |= 1 << 0
			if err := func() error {
				if err := s.MailerTemplatesMagicLinkContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mailer_templates_magic_link_content\"")
			}
		case "mailer_templates_recovery_content":
			requiredBitSet[11] |= 1 << 1
			if err := func() error {
				if err := s.MailerTemplatesRecoveryContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mailer_templates_recovery_content\"")
			}
		case "mailer_templates_reauthentication_content":
			requiredBitSet[11] |= 1 << 2
			if err := func() error {
				if err := s.MailerTemplatesReauthenticationContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mailer_templates_reauthentication_content\"")
			}
		case "mfa_max_enrolled_factors":
			requiredBitSet[11] |= 1 << 3
			if err := func() error {
				if err := s.MfaMaxEnrolledFactors.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mfa_max_enrolled_factors\"")
			}
		case "password_hibp_enabled":
			requiredBitSet[11] |= 1 << 4
			if err := func() error {
				if err := s.PasswordHibpEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password_hibp_enabled\"")
			}
		case "password_min_length":
			requiredBitSet[11] |= 1 << 5
			if err := func() error {
				if err := s.PasswordMinLength.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password_min_length\"")
			}
		case "password_required_characters":
			requiredBitSet[11] |= 1 << 6
			if err := func() error {
				if err := s.PasswordRequiredCharacters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password_required_characters\"")
			}
		case "rate_limit_anonymous_users":
			requiredBitSet[11] |= 1 << 7
			if err := func() error {
				if err := s.RateLimitAnonymousUsers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rate_limit_anonymous_users\"")
			}
		case "rate_limit_email_sent":
			requiredBitSet[12] |= 1 << 0
			if err := func() error {
				if err := s.RateLimitEmailSent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rate_limit_email_sent\"")
			}
		case "rate_limit_sms_sent":
			requiredBitSet[12] |= 1 << 1
			if err := func() error {
				if err := s.RateLimitSMSSent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rate_limit_sms_sent\"")
			}
		case "rate_limit_token_refresh":
			requiredBitSet[12] |= 1 << 2
			if err := func() error {
				if err := s.RateLimitTokenRefresh.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rate_limit_token_refresh\"")
			}
		case "rate_limit_verify":
			requiredBitSet[12] |= 1 << 3
			if err := func() error {
				if err := s.RateLimitVerify.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rate_limit_verify\"")
			}
		case "refresh_token_rotation_enabled":
			requiredBitSet[12] |= 1 << 4
			if err := func() error {
				if err := s.RefreshTokenRotationEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"refresh_token_rotation_enabled\"")
			}
		case "saml_enabled":
			requiredBitSet[12] |= 1 << 5
			if err := func() error {
				if err := s.SamlEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"saml_enabled\"")
			}
		case "security_captcha_enabled":
			requiredBitSet[12] |= 1 << 6
			if err := func() error {
				if err := s.SecurityCaptchaEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security_captcha_enabled\"")
			}
		case "security_captcha_provider":
			requiredBitSet[12] |= 1 << 7
			if err := func() error {
				if err := s.SecurityCaptchaProvider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security_captcha_provider\"")
			}
		case "security_captcha_secret":
			requiredBitSet[13] |= 1 << 0
			if err := func() error {
				if err := s.SecurityCaptchaSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security_captcha_secret\"")
			}
		case "security_manual_linking_enabled":
			requiredBitSet[13] |= 1 << 1
			if err := func() error {
				if err := s.SecurityManualLinkingEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security_manual_linking_enabled\"")
			}
		case "security_refresh_token_reuse_interval":
			requiredBitSet[13] |= 1 << 2
			if err := func() error {
				if err := s.SecurityRefreshTokenReuseInterval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security_refresh_token_reuse_interval\"")
			}
		case "security_update_password_require_reauthentication":
			requiredBitSet[13] |= 1 << 3
			if err := func() error {
				if err := s.SecurityUpdatePasswordRequireReauthentication.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security_update_password_require_reauthentication\"")
			}
		case "sessions_inactivity_timeout":
			requiredBitSet[13] |= 1 << 4
			if err := func() error {
				if err := s.SessionsInactivityTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sessions_inactivity_timeout\"")
			}
		case "sessions_single_per_user":
			requiredBitSet[13] |= 1 << 5
			if err := func() error {
				if err := s.SessionsSinglePerUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sessions_single_per_user\"")
			}
		case "sessions_tags":
			requiredBitSet[13] |= 1 << 6
			if err := func() error {
				if err := s.SessionsTags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sessions_tags\"")
			}
		case "sessions_timebox":
			requiredBitSet[13] |= 1 << 7
			if err := func() error {
				if err := s.SessionsTimebox.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sessions_timebox\"")
			}
		case "site_url":
			requiredBitSet[14] |= 1 << 0
			if err := func() error {
				if err := s.SiteURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"site_url\"")
			}
		case "sms_autoconfirm":
			requiredBitSet[14] |= 1 << 1
			if err := func() error {
				if err := s.SMSAutoconfirm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_autoconfirm\"")
			}
		case "sms_max_frequency":
			requiredBitSet[14] |= 1 << 2
			if err := func() error {
				if err := s.SMSMaxFrequency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_max_frequency\"")
			}
		case "sms_messagebird_access_key":
			requiredBitSet[14] |= 1 << 3
			if err := func() error {
				if err := s.SMSMessagebirdAccessKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_messagebird_access_key\"")
			}
		case "sms_messagebird_originator":
			requiredBitSet[14] |= 1 << 4
			if err := func() error {
				if err := s.SMSMessagebirdOriginator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_messagebird_originator\"")
			}
		case "sms_otp_exp":
			requiredBitSet[14] |= 1 << 5
			if err := func() error {
				if err := s.SMSOtpExp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_otp_exp\"")
			}
		case "sms_otp_length":
			requiredBitSet[14] |= 1 << 6
			if err := func() error {
				if err := s.SMSOtpLength.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_otp_length\"")
			}
		case "sms_provider":
			requiredBitSet[14] |= 1 << 7
			if err := func() error {
				if err := s.SMSProvider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_provider\"")
			}
		case "sms_template":
			requiredBitSet[15] |= 1 << 0
			if err := func() error {
				if err := s.SMSTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_template\"")
			}
		case "sms_test_otp":
			requiredBitSet[15] |= 1 << 1
			if err := func() error {
				if err := s.SMSTestOtp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_test_otp\"")
			}
		case "sms_test_otp_valid_until":
			requiredBitSet[15] |= 1 << 2
			if err := func() error {
				if err := s.SMSTestOtpValidUntil.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_test_otp_valid_until\"")
			}
		case "sms_textlocal_api_key":
			requiredBitSet[15] |= 1 << 3
			if err := func() error {
				if err := s.SMSTextlocalAPIKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_textlocal_api_key\"")
			}
		case "sms_textlocal_sender":
			requiredBitSet[15] |= 1 << 4
			if err := func() error {
				if err := s.SMSTextlocalSender.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_textlocal_sender\"")
			}
		case "sms_twilio_account_sid":
			requiredBitSet[15] |= 1 << 5
			if err := func() error {
				if err := s.SMSTwilioAccountSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_twilio_account_sid\"")
			}
		case "sms_twilio_auth_token":
			requiredBitSet[15] |= 1 << 6
			if err := func() error {
				if err := s.SMSTwilioAuthToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_twilio_auth_token\"")
			}
		case "sms_twilio_content_sid":
			requiredBitSet[15] |= 1 << 7
			if err := func() error {
				if err := s.SMSTwilioContentSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_twilio_content_sid\"")
			}
		case "sms_twilio_message_service_sid":
			requiredBitSet[16] |= 1 << 0
			if err := func() error {
				if err := s.SMSTwilioMessageServiceSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_twilio_message_service_sid\"")
			}
		case "sms_twilio_verify_account_sid":
			requiredBitSet[16] |= 1 << 1
			if err := func() error {
				if err := s.SMSTwilioVerifyAccountSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_twilio_verify_account_sid\"")
			}
		case "sms_twilio_verify_auth_token":
			requiredBitSet[16] |= 1 << 2
			if err := func() error {
				if err := s.SMSTwilioVerifyAuthToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_twilio_verify_auth_token\"")
			}
		case "sms_twilio_verify_message_service_sid":
			requiredBitSet[16] |= 1 << 3
			if err := func() error {
				if err := s.SMSTwilioVerifyMessageServiceSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_twilio_verify_message_service_sid\"")
			}
		case "sms_vonage_api_key":
			requiredBitSet[16] |= 1 << 4
			if err := func() error {
				if err := s.SMSVonageAPIKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_vonage_api_key\"")
			}
		case "sms_vonage_api_secret":
			requiredBitSet[16] |= 1 << 5
			if err := func() error {
				if err := s.SMSVonageAPISecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_vonage_api_secret\"")
			}
		case "sms_vonage_from":
			requiredBitSet[16] |= 1 << 6
			if err := func() error {
				if err := s.SMSVonageFrom.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_vonage_from\"")
			}
		case "smtp_admin_email":
			requiredBitSet[16] |= 1 << 7
			if err := func() error {
				if err := s.SMTPAdminEmail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"smtp_admin_email\"")
			}
		case "smtp_host":
			requiredBitSet[17] |= 1 << 0
			if err := func() error {
				if err := s.SMTPHost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"smtp_host\"")
			}
		case "smtp_max_frequency":
			requiredBitSet[17] |= 1 << 1
			if err := func() error {
				if err := s.SMTPMaxFrequency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"smtp_max_frequency\"")
			}
		case "smtp_pass":
			requiredBitSet[17] |= 1 << 2
			if err := func() error {
				if err := s.SMTPPass.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"smtp_pass\"")
			}
		case "smtp_port":
			requiredBitSet[17] |= 1 << 3
			if err := func() error {
				if err := s.SMTPPort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"smtp_port\"")
			}
		case "smtp_sender_name":
			requiredBitSet[17] |= 1 << 4
			if err := func() error {
				if err := s.SMTPSenderName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"smtp_sender_name\"")
			}
		case "smtp_user":
			requiredBitSet[17] |= 1 << 5
			if err := func() error {
				if err := s.SMTPUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"smtp_user\"")
			}
		case "uri_allow_list":
			requiredBitSet[17] |= 1 << 6
			if err := func() error {
				if err := s.URIAllowList.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri_allow_list\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthConfigResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [18]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAuthConfigResponse) {
					name = jsonFieldsNameOfAuthConfigResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthConfigResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthConfigResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthHealthResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthHealthResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
}

var jsonFieldsNameOfAuthHealthResponse = [3]string{
	0: "name",
	1: "version",
	2: "description",
}

// Decode decodes AuthHealthResponse from json.
func (s *AuthHealthResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthHealthResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthHealthResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAuthHealthResponse) {
					name = jsonFieldsNameOfAuthHealthResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthHealthResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthHealthResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BillingPlanId as json.
func (s BillingPlanId) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BillingPlanId from json.
func (s *BillingPlanId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BillingPlanId to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BillingPlanId(v) {
	case BillingPlanIdFree:
		*s = BillingPlanIdFree
	case BillingPlanIdPro:
		*s = BillingPlanIdPro
	case BillingPlanIdTeam:
		*s = BillingPlanIdTeam
	case BillingPlanIdEnterprise:
		*s = BillingPlanIdEnterprise
	default:
		*s = BillingPlanId(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BillingPlanId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BillingPlanId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BranchDeleteResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BranchDeleteResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfBranchDeleteResponse = [1]string{
	0: "message",
}

// Decode decodes BranchDeleteResponse from json.
func (s *BranchDeleteResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchDeleteResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchDeleteResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBranchDeleteResponse) {
					name = jsonFieldsNameOfBranchDeleteResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BranchDeleteResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BranchDeleteResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BranchDetailResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BranchDetailResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("db_port")
		e.Int(s.DbPort)
	}
	{
		e.FieldStart("ref")
		e.Str(s.Ref)
	}
	{
		e.FieldStart("postgres_version")
		e.Str(s.PostgresVersion)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("db_host")
		e.Str(s.DbHost)
	}
	{
		if s.DbUser.Set {
			e.FieldStart("db_user")
			s.DbUser.Encode(e)
		}
	}
	{
		if s.DbPass.Set {
			e.FieldStart("db_pass")
			s.DbPass.Encode(e)
		}
	}
	{
		if s.JwtSecret.Set {
			e.FieldStart("jwt_secret")
			s.JwtSecret.Encode(e)
		}
	}
}

var jsonFieldsNameOfBranchDetailResponse = [8]string{
	0: "db_port",
	1: "ref",
	2: "postgres_version",
	3: "status",
	4: "db_host",
	5: "db_user",
	6: "db_pass",
	7: "jwt_secret",
}

// Decode decodes BranchDetailResponse from json.
func (s *BranchDetailResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchDetailResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "db_port":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.DbPort = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"db_port\"")
			}
		case "ref":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Ref = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ref\"")
			}
		case "postgres_version":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.PostgresVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"postgres_version\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "db_host":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.DbHost = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"db_host\"")
			}
		case "db_user":
			if err := func() error {
				s.DbUser.Reset()
				if err := s.DbUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"db_user\"")
			}
		case "db_pass":
			if err := func() error {
				s.DbPass.Reset()
				if err := s.DbPass.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"db_pass\"")
			}
		case "jwt_secret":
			if err := func() error {
				s.JwtSecret.Reset()
				if err := s.JwtSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jwt_secret\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchDetailResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBranchDetailResponse) {
					name = jsonFieldsNameOfBranchDetailResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BranchDetailResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BranchDetailResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BranchDetailResponseStatus as json.
func (s BranchDetailResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BranchDetailResponseStatus from json.
func (s *BranchDetailResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchDetailResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BranchDetailResponseStatus(v) {
	case BranchDetailResponseStatusACTIVEHEALTHY:
		*s = BranchDetailResponseStatusACTIVEHEALTHY
	case BranchDetailResponseStatusACTIVEUNHEALTHY:
		*s = BranchDetailResponseStatusACTIVEUNHEALTHY
	case BranchDetailResponseStatusCOMINGUP:
		*s = BranchDetailResponseStatusCOMINGUP
	case BranchDetailResponseStatusGOINGDOWN:
		*s = BranchDetailResponseStatusGOINGDOWN
	case BranchDetailResponseStatusINACTIVE:
		*s = BranchDetailResponseStatusINACTIVE
	case BranchDetailResponseStatusINITFAILED:
		*s = BranchDetailResponseStatusINITFAILED
	case BranchDetailResponseStatusREMOVED:
		*s = BranchDetailResponseStatusREMOVED
	case BranchDetailResponseStatusRESTORING:
		*s = BranchDetailResponseStatusRESTORING
	case BranchDetailResponseStatusUNKNOWN:
		*s = BranchDetailResponseStatusUNKNOWN
	case BranchDetailResponseStatusUPGRADING:
		*s = BranchDetailResponseStatusUPGRADING
	case BranchDetailResponseStatusPAUSING:
		*s = BranchDetailResponseStatusPAUSING
	default:
		*s = BranchDetailResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BranchDetailResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BranchDetailResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BranchResetResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BranchResetResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfBranchResetResponse = [1]string{
	0: "message",
}

// Decode decodes BranchResetResponse from json.
func (s *BranchResetResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchResetResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchResetResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBranchResetResponse) {
					name = jsonFieldsNameOfBranchResetResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BranchResetResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BranchResetResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BranchResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BranchResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("project_ref")
		e.Str(s.ProjectRef)
	}
	{
		e.FieldStart("parent_project_ref")
		e.Str(s.ParentProjectRef)
	}
	{
		e.FieldStart("is_default")
		e.Bool(s.IsDefault)
	}
	{
		if s.GitBranch.Set {
			e.FieldStart("git_branch")
			s.GitBranch.Encode(e)
		}
	}
	{
		if s.PrNumber.Set {
			e.FieldStart("pr_number")
			s.PrNumber.Encode(e)
		}
	}
	{
		e.FieldStart("reset_on_push")
		e.Bool(s.ResetOnPush)
	}
	{
		e.FieldStart("persistent")
		e.Bool(s.Persistent)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("created_at")
		e.Str(s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		e.Str(s.UpdatedAt)
	}
}

var jsonFieldsNameOfBranchResponse = [12]string{
	0:  "id",
	1:  "name",
	2:  "project_ref",
	3:  "parent_project_ref",
	4:  "is_default",
	5:  "git_branch",
	6:  "pr_number",
	7:  "reset_on_push",
	8:  "persistent",
	9:  "status",
	10: "created_at",
	11: "updated_at",
}

// Decode decodes BranchResponse from json.
func (s *BranchResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchResponse to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "project_ref":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ProjectRef = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_ref\"")
			}
		case "parent_project_ref":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ParentProjectRef = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent_project_ref\"")
			}
		case "is_default":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsDefault = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_default\"")
			}
		case "git_branch":
			if err := func() error {
				s.GitBranch.Reset()
				if err := s.GitBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_branch\"")
			}
		case "pr_number":
			if err := func() error {
				s.PrNumber.Reset()
				if err := s.PrNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pr_number\"")
			}
		case "reset_on_push":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.ResetOnPush = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reset_on_push\"")
			}
		case "persistent":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Persistent = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"persistent\"")
			}
		case "status":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CreatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.UpdatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10011111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBranchResponse) {
					name = jsonFieldsNameOfBranchResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BranchResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BranchResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BranchResponseStatus as json.
func (s BranchResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BranchResponseStatus from json.
func (s *BranchResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BranchResponseStatus(v) {
	case BranchResponseStatusCREATINGPROJECT:
		*s = BranchResponseStatusCREATINGPROJECT
	case BranchResponseStatusRUNNINGMIGRATIONS:
		*s = BranchResponseStatusRUNNINGMIGRATIONS
	case BranchResponseStatusMIGRATIONSPASSED:
		*s = BranchResponseStatusMIGRATIONSPASSED
	case BranchResponseStatusMIGRATIONSFAILED:
		*s = BranchResponseStatusMIGRATIONSFAILED
	default:
		*s = BranchResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BranchResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BranchResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CheckServiceHealthOKApplicationJSON as json.
func (s CheckServiceHealthOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []V1ServiceHealthResponse(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes CheckServiceHealthOKApplicationJSON from json.
func (s *CheckServiceHealthOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckServiceHealthOKApplicationJSON to nil")
	}
	var unwrapped []V1ServiceHealthResponse
	if err := func() error {
		unwrapped = make([]V1ServiceHealthResponse, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem V1ServiceHealthResponse
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CheckServiceHealthOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CheckServiceHealthOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckServiceHealthOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateBranchBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateBranchBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("branch_name")
		e.Str(s.BranchName)
	}
	{
		if s.GitBranch.Set {
			e.FieldStart("git_branch")
			s.GitBranch.Encode(e)
		}
	}
	{
		if s.Region.Set {
			e.FieldStart("region")
			s.Region.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateBranchBody = [3]string{
	0: "branch_name",
	1: "git_branch",
	2: "region",
}

// Decode decodes CreateBranchBody from json.
func (s *CreateBranchBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateBranchBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "branch_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BranchName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branch_name\"")
			}
		case "git_branch":
			if err := func() error {
				s.GitBranch.Reset()
				if err := s.GitBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_branch\"")
			}
		case "region":
			if err := func() error {
				s.Region.Reset()
				if err := s.Region.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateBranchBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateBranchBody) {
					name = jsonFieldsNameOfCreateBranchBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateBranchBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateBranchBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateOrganizationBodyV1) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateOrganizationBodyV1) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfCreateOrganizationBodyV1 = [1]string{
	0: "name",
}

// Decode decodes CreateOrganizationBodyV1 from json.
func (s *CreateOrganizationBodyV1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateOrganizationBodyV1 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateOrganizationBodyV1")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateOrganizationBodyV1) {
					name = jsonFieldsNameOfCreateOrganizationBodyV1[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateOrganizationBodyV1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateOrganizationBodyV1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateProviderBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateProviderBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.MetadataXML.Set {
			e.FieldStart("metadata_xml")
			s.MetadataXML.Encode(e)
		}
	}
	{
		if s.MetadataURL.Set {
			e.FieldStart("metadata_url")
			s.MetadataURL.Encode(e)
		}
	}
	{
		if s.Domains != nil {
			e.FieldStart("domains")
			e.ArrStart()
			for _, elem := range s.Domains {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AttributeMapping.Set {
			e.FieldStart("attribute_mapping")
			s.AttributeMapping.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateProviderBody = [5]string{
	0: "type",
	1: "metadata_xml",
	2: "metadata_url",
	3: "domains",
	4: "attribute_mapping",
}

// Decode decodes CreateProviderBody from json.
func (s *CreateProviderBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateProviderBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "metadata_xml":
			if err := func() error {
				s.MetadataXML.Reset()
				if err := s.MetadataXML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata_xml\"")
			}
		case "metadata_url":
			if err := func() error {
				s.MetadataURL.Reset()
				if err := s.MetadataURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata_url\"")
			}
		case "domains":
			if err := func() error {
				s.Domains = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Domains = append(s.Domains, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domains\"")
			}
		case "attribute_mapping":
			if err := func() error {
				s.AttributeMapping.Reset()
				if err := s.AttributeMapping.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attribute_mapping\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateProviderBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateProviderBody) {
					name = jsonFieldsNameOfCreateProviderBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateProviderBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateProviderBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateProviderBodyType as json.
func (s CreateProviderBodyType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateProviderBodyType from json.
func (s *CreateProviderBodyType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateProviderBodyType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateProviderBodyType(v) {
	case CreateProviderBodyTypeSaml:
		*s = CreateProviderBodyTypeSaml
	default:
		*s = CreateProviderBodyType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateProviderBodyType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateProviderBodyType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateProviderResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateProviderResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.Saml.Set {
			e.FieldStart("saml")
			s.Saml.Encode(e)
		}
	}
	{
		if s.Domains != nil {
			e.FieldStart("domains")
			e.ArrStart()
			for _, elem := range s.Domains {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateProviderResponse = [5]string{
	0: "id",
	1: "saml",
	2: "domains",
	3: "created_at",
	4: "updated_at",
}

// Decode decodes CreateProviderResponse from json.
func (s *CreateProviderResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateProviderResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "saml":
			if err := func() error {
				s.Saml.Reset()
				if err := s.Saml.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"saml\"")
			}
		case "domains":
			if err := func() error {
				s.Domains = make([]Domain, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Domain
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Domains = append(s.Domains, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domains\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateProviderResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateProviderResponse) {
					name = jsonFieldsNameOfCreateProviderResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateProviderResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateProviderResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateSecretBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateSecretBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfCreateSecretBody = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes CreateSecretBody from json.
func (s *CreateSecretBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSecretBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateSecretBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateSecretBody) {
					name = jsonFieldsNameOfCreateSecretBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSecretBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSecretBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateThirdPartyAuthBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateThirdPartyAuthBody) encodeFields(e *jx.Encoder) {
	{
		if s.OidcIssuerURL.Set {
			e.FieldStart("oidc_issuer_url")
			s.OidcIssuerURL.Encode(e)
		}
	}
	{
		if s.JwksURL.Set {
			e.FieldStart("jwks_url")
			s.JwksURL.Encode(e)
		}
	}
	{
		if s.CustomJwks != nil {
			e.FieldStart("custom_jwks")
			s.CustomJwks.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateThirdPartyAuthBody = [3]string{
	0: "oidc_issuer_url",
	1: "jwks_url",
	2: "custom_jwks",
}

// Decode decodes CreateThirdPartyAuthBody from json.
func (s *CreateThirdPartyAuthBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateThirdPartyAuthBody to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "oidc_issuer_url":
			if err := func() error {
				s.OidcIssuerURL.Reset()
				if err := s.OidcIssuerURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oidc_issuer_url\"")
			}
		case "jwks_url":
			if err := func() error {
				s.JwksURL.Reset()
				if err := s.JwksURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jwks_url\"")
			}
		case "custom_jwks":
			if err := func() error {
				s.CustomJwks = nil
				var elem CreateThirdPartyAuthBodyCustomJwks
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CustomJwks = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_jwks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateThirdPartyAuthBody")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateThirdPartyAuthBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateThirdPartyAuthBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateThirdPartyAuthBodyCustomJwks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateThirdPartyAuthBodyCustomJwks) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateThirdPartyAuthBodyCustomJwks = [0]string{}

// Decode decodes CreateThirdPartyAuthBodyCustomJwks from json.
func (s *CreateThirdPartyAuthBodyCustomJwks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateThirdPartyAuthBodyCustomJwks to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CreateThirdPartyAuthBodyCustomJwks")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateThirdPartyAuthBodyCustomJwks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateThirdPartyAuthBodyCustomJwks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseUpgradeStatusResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseUpgradeStatusResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("databaseUpgradeStatus")
		s.DatabaseUpgradeStatus.Encode(e)
	}
}

var jsonFieldsNameOfDatabaseUpgradeStatusResponse = [1]string{
	0: "databaseUpgradeStatus",
}

// Decode decodes DatabaseUpgradeStatusResponse from json.
func (s *DatabaseUpgradeStatusResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseUpgradeStatusResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "databaseUpgradeStatus":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.DatabaseUpgradeStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"databaseUpgradeStatus\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseUpgradeStatusResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseUpgradeStatusResponse) {
					name = jsonFieldsNameOfDatabaseUpgradeStatusResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseUpgradeStatusResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseUpgradeStatusResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatabaseUpgradeStatusResponseDatabaseUpgradeStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatabaseUpgradeStatusResponseDatabaseUpgradeStatus) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("initiated_at")
		e.Str(s.InitiatedAt)
	}
	{
		e.FieldStart("target_version")
		e.Float64(s.TargetVersion)
	}
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		if s.Progress.Set {
			e.FieldStart("progress")
			s.Progress.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
}

var jsonFieldsNameOfDatabaseUpgradeStatusResponseDatabaseUpgradeStatus = [5]string{
	0: "initiated_at",
	1: "target_version",
	2: "error",
	3: "progress",
	4: "status",
}

// Decode decodes DatabaseUpgradeStatusResponseDatabaseUpgradeStatus from json.
func (s *DatabaseUpgradeStatusResponseDatabaseUpgradeStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseUpgradeStatusResponseDatabaseUpgradeStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "initiated_at":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.InitiatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initiated_at\"")
			}
		case "target_version":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.TargetVersion = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_version\"")
			}
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "progress":
			if err := func() error {
				s.Progress.Reset()
				if err := s.Progress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progress\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatabaseUpgradeStatusResponseDatabaseUpgradeStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatabaseUpgradeStatusResponseDatabaseUpgradeStatus) {
					name = jsonFieldsNameOfDatabaseUpgradeStatusResponseDatabaseUpgradeStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatabaseUpgradeStatusResponseDatabaseUpgradeStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseUpgradeStatusResponseDatabaseUpgradeStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseUpgradeStatusResponseDatabaseUpgradeStatusError as json.
func (s DatabaseUpgradeStatusResponseDatabaseUpgradeStatusError) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DatabaseUpgradeStatusResponseDatabaseUpgradeStatusError from json.
func (s *DatabaseUpgradeStatusResponseDatabaseUpgradeStatusError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseUpgradeStatusResponseDatabaseUpgradeStatusError to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DatabaseUpgradeStatusResponseDatabaseUpgradeStatusError(v) {
	case DatabaseUpgradeStatusResponseDatabaseUpgradeStatusError1UpgradedInstanceLaunchFailed:
		*s = DatabaseUpgradeStatusResponseDatabaseUpgradeStatusError1UpgradedInstanceLaunchFailed
	case DatabaseUpgradeStatusResponseDatabaseUpgradeStatusError2VolumeDetachchmentFromUpgradedInstanceFailed:
		*s = DatabaseUpgradeStatusResponseDatabaseUpgradeStatusError2VolumeDetachchmentFromUpgradedInstanceFailed
	case DatabaseUpgradeStatusResponseDatabaseUpgradeStatusError3VolumeAttachmentToOriginalInstanceFailed:
		*s = DatabaseUpgradeStatusResponseDatabaseUpgradeStatusError3VolumeAttachmentToOriginalInstanceFailed
	case DatabaseUpgradeStatusResponseDatabaseUpgradeStatusError4DataUpgradeInitiationFailed:
		*s = DatabaseUpgradeStatusResponseDatabaseUpgradeStatusError4DataUpgradeInitiationFailed
	case DatabaseUpgradeStatusResponseDatabaseUpgradeStatusError5DataUpgradeCompletionFailed:
		*s = DatabaseUpgradeStatusResponseDatabaseUpgradeStatusError5DataUpgradeCompletionFailed
	case DatabaseUpgradeStatusResponseDatabaseUpgradeStatusError6VolumeDetachchmentFromOriginalInstanceFailed:
		*s = DatabaseUpgradeStatusResponseDatabaseUpgradeStatusError6VolumeDetachchmentFromOriginalInstanceFailed
	case DatabaseUpgradeStatusResponseDatabaseUpgradeStatusError7VolumeAttachmentToUpgradedInstanceFailed:
		*s = DatabaseUpgradeStatusResponseDatabaseUpgradeStatusError7VolumeAttachmentToUpgradedInstanceFailed
	case DatabaseUpgradeStatusResponseDatabaseUpgradeStatusError8UpgradeCompletionFailed:
		*s = DatabaseUpgradeStatusResponseDatabaseUpgradeStatusError8UpgradeCompletionFailed
	default:
		*s = DatabaseUpgradeStatusResponseDatabaseUpgradeStatusError(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseUpgradeStatusResponseDatabaseUpgradeStatusError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseUpgradeStatusResponseDatabaseUpgradeStatusError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress as json.
func (s DatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress from json.
func (s *DatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress(v) {
	case DatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress0Requested:
		*s = DatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress0Requested
	case DatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress1Started:
		*s = DatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress1Started
	case DatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress2LaunchedUpgradedInstance:
		*s = DatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress2LaunchedUpgradedInstance
	case DatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress3DetachedVolumeFromUpgradedInstance:
		*s = DatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress3DetachedVolumeFromUpgradedInstance
	case DatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress4AttachedVolumeToOriginalInstance:
		*s = DatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress4AttachedVolumeToOriginalInstance
	case DatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress5InitiatedDataUpgrade:
		*s = DatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress5InitiatedDataUpgrade
	case DatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress6CompletedDataUpgrade:
		*s = DatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress6CompletedDataUpgrade
	case DatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress7DetachedVolumeFromOriginalInstance:
		*s = DatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress7DetachedVolumeFromOriginalInstance
	case DatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress8AttachedVolumeToUpgradedInstance:
		*s = DatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress8AttachedVolumeToUpgradedInstance
	case DatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress9CompletedUpgrade:
		*s = DatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress9CompletedUpgrade
	default:
		*s = DatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseUpgradeStatusResponseDatabaseUpgradeStatusStatus as json.
func (s DatabaseUpgradeStatusResponseDatabaseUpgradeStatusStatus) Encode(e *jx.Encoder) {
	e.Float64(float64(s))
}

// Decode decodes DatabaseUpgradeStatusResponseDatabaseUpgradeStatusStatus from json.
func (s *DatabaseUpgradeStatusResponseDatabaseUpgradeStatusStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatabaseUpgradeStatusResponseDatabaseUpgradeStatusStatus to nil")
	}
	v, err := d.Float64()
	if err != nil {
		return err
	}
	*s = DatabaseUpgradeStatusResponseDatabaseUpgradeStatusStatus(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatabaseUpgradeStatusResponseDatabaseUpgradeStatusStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatabaseUpgradeStatusResponseDatabaseUpgradeStatusStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteProviderResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteProviderResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.Saml.Set {
			e.FieldStart("saml")
			s.Saml.Encode(e)
		}
	}
	{
		if s.Domains != nil {
			e.FieldStart("domains")
			e.ArrStart()
			for _, elem := range s.Domains {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfDeleteProviderResponse = [5]string{
	0: "id",
	1: "saml",
	2: "domains",
	3: "created_at",
	4: "updated_at",
}

// Decode decodes DeleteProviderResponse from json.
func (s *DeleteProviderResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteProviderResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "saml":
			if err := func() error {
				s.Saml.Reset()
				if err := s.Saml.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"saml\"")
			}
		case "domains":
			if err := func() error {
				s.Domains = make([]Domain, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Domain
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Domains = append(s.Domains, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domains\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteProviderResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteProviderResponse) {
					name = jsonFieldsNameOfDeleteProviderResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteProviderResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteProviderResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteSecretsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteSecretsOK) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfDeleteSecretsOK = [0]string{}

// Decode decodes DeleteSecretsOK from json.
func (s *DeleteSecretsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteSecretsOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode DeleteSecretsOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteSecretsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteSecretsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DesiredInstanceSize as json.
func (s DesiredInstanceSize) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DesiredInstanceSize from json.
func (s *DesiredInstanceSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DesiredInstanceSize to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DesiredInstanceSize(v) {
	case DesiredInstanceSizeMicro:
		*s = DesiredInstanceSizeMicro
	case DesiredInstanceSizeSmall:
		*s = DesiredInstanceSizeSmall
	case DesiredInstanceSizeMedium:
		*s = DesiredInstanceSizeMedium
	case DesiredInstanceSizeLarge:
		*s = DesiredInstanceSizeLarge
	case DesiredInstanceSizeXlarge:
		*s = DesiredInstanceSizeXlarge
	case DesiredInstanceSize2xlarge:
		*s = DesiredInstanceSize2xlarge
	case DesiredInstanceSize4xlarge:
		*s = DesiredInstanceSize4xlarge
	case DesiredInstanceSize8xlarge:
		*s = DesiredInstanceSize8xlarge
	case DesiredInstanceSize12xlarge:
		*s = DesiredInstanceSize12xlarge
	case DesiredInstanceSize16xlarge:
		*s = DesiredInstanceSize16xlarge
	default:
		*s = DesiredInstanceSize(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DesiredInstanceSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DesiredInstanceSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Domain) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Domain) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfDomain = [4]string{
	0: "id",
	1: "domain",
	2: "created_at",
	3: "updated_at",
}

// Decode decodes Domain from json.
func (s *Domain) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Domain to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Domain")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomain) {
					name = jsonFieldsNameOfDomain[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Domain) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Domain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FunctionResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FunctionResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("slug")
		e.Str(s.Slug)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("version")
		e.Float64(s.Version)
	}
	{
		e.FieldStart("created_at")
		e.Float64(s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		e.Float64(s.UpdatedAt)
	}
	{
		if s.VerifyJwt.Set {
			e.FieldStart("verify_jwt")
			s.VerifyJwt.Encode(e)
		}
	}
	{
		if s.ImportMap.Set {
			e.FieldStart("import_map")
			s.ImportMap.Encode(e)
		}
	}
	{
		if s.EntrypointPath.Set {
			e.FieldStart("entrypoint_path")
			s.EntrypointPath.Encode(e)
		}
	}
	{
		if s.ImportMapPath.Set {
			e.FieldStart("import_map_path")
			s.ImportMapPath.Encode(e)
		}
	}
}

var jsonFieldsNameOfFunctionResponse = [11]string{
	0:  "id",
	1:  "slug",
	2:  "name",
	3:  "status",
	4:  "version",
	5:  "created_at",
	6:  "updated_at",
	7:  "verify_jwt",
	8:  "import_map",
	9:  "entrypoint_path",
	10: "import_map_path",
}

// Decode decodes FunctionResponse from json.
func (s *FunctionResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FunctionResponse to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "slug":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Slug = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.Version = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.CreatedAt = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.UpdatedAt = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "verify_jwt":
			if err := func() error {
				s.VerifyJwt.Reset()
				if err := s.VerifyJwt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verify_jwt\"")
			}
		case "import_map":
			if err := func() error {
				s.ImportMap.Reset()
				if err := s.ImportMap.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"import_map\"")
			}
		case "entrypoint_path":
			if err := func() error {
				s.EntrypointPath.Reset()
				if err := s.EntrypointPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entrypoint_path\"")
			}
		case "import_map_path":
			if err := func() error {
				s.ImportMapPath.Reset()
				if err := s.ImportMapPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"import_map_path\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FunctionResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFunctionResponse) {
					name = jsonFieldsNameOfFunctionResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FunctionResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FunctionResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FunctionResponseStatus as json.
func (s FunctionResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FunctionResponseStatus from json.
func (s *FunctionResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FunctionResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FunctionResponseStatus(v) {
	case FunctionResponseStatusACTIVE:
		*s = FunctionResponseStatusACTIVE
	case FunctionResponseStatusREMOVED:
		*s = FunctionResponseStatusREMOVED
	case FunctionResponseStatusTHROTTLED:
		*s = FunctionResponseStatusTHROTTLED
	default:
		*s = FunctionResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FunctionResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FunctionResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FunctionSlugResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FunctionSlugResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("slug")
		e.Str(s.Slug)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("version")
		e.Float64(s.Version)
	}
	{
		e.FieldStart("created_at")
		e.Float64(s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		e.Float64(s.UpdatedAt)
	}
	{
		if s.VerifyJwt.Set {
			e.FieldStart("verify_jwt")
			s.VerifyJwt.Encode(e)
		}
	}
	{
		if s.ImportMap.Set {
			e.FieldStart("import_map")
			s.ImportMap.Encode(e)
		}
	}
	{
		if s.EntrypointPath.Set {
			e.FieldStart("entrypoint_path")
			s.EntrypointPath.Encode(e)
		}
	}
	{
		if s.ImportMapPath.Set {
			e.FieldStart("import_map_path")
			s.ImportMapPath.Encode(e)
		}
	}
}

var jsonFieldsNameOfFunctionSlugResponse = [11]string{
	0:  "id",
	1:  "slug",
	2:  "name",
	3:  "status",
	4:  "version",
	5:  "created_at",
	6:  "updated_at",
	7:  "verify_jwt",
	8:  "import_map",
	9:  "entrypoint_path",
	10: "import_map_path",
}

// Decode decodes FunctionSlugResponse from json.
func (s *FunctionSlugResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FunctionSlugResponse to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "slug":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Slug = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.Version = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.CreatedAt = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.UpdatedAt = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "verify_jwt":
			if err := func() error {
				s.VerifyJwt.Reset()
				if err := s.VerifyJwt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verify_jwt\"")
			}
		case "import_map":
			if err := func() error {
				s.ImportMap.Reset()
				if err := s.ImportMap.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"import_map\"")
			}
		case "entrypoint_path":
			if err := func() error {
				s.EntrypointPath.Reset()
				if err := s.EntrypointPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entrypoint_path\"")
			}
		case "import_map_path":
			if err := func() error {
				s.ImportMapPath.Reset()
				if err := s.ImportMapPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"import_map_path\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FunctionSlugResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFunctionSlugResponse) {
					name = jsonFieldsNameOfFunctionSlugResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FunctionSlugResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FunctionSlugResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FunctionSlugResponseStatus as json.
func (s FunctionSlugResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FunctionSlugResponseStatus from json.
func (s *FunctionSlugResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FunctionSlugResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FunctionSlugResponseStatus(v) {
	case FunctionSlugResponseStatusACTIVE:
		*s = FunctionSlugResponseStatusACTIVE
	case FunctionSlugResponseStatusREMOVED:
		*s = FunctionSlugResponseStatusREMOVED
	case FunctionSlugResponseStatusTHROTTLED:
		*s = FunctionSlugResponseStatusTHROTTLED
	default:
		*s = FunctionSlugResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FunctionSlugResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FunctionSlugResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBranchesOKApplicationJSON as json.
func (s GetBranchesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []BranchResponse(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetBranchesOKApplicationJSON from json.
func (s *GetBranchesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBranchesOKApplicationJSON to nil")
	}
	var unwrapped []BranchResponse
	if err := func() error {
		unwrapped = make([]BranchResponse, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem BranchResponse
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBranchesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetBranchesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBranchesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBucketsOKApplicationJSON as json.
func (s GetBucketsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []V1StorageBucketResponse(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetBucketsOKApplicationJSON from json.
func (s *GetBucketsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBucketsOKApplicationJSON to nil")
	}
	var unwrapped []V1StorageBucketResponse
	if err := func() error {
		unwrapped = make([]V1StorageBucketResponse, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem V1StorageBucketResponse
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetBucketsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetBucketsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBucketsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetFunctionsOKApplicationJSON as json.
func (s GetFunctionsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []FunctionResponse(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetFunctionsOKApplicationJSON from json.
func (s *GetFunctionsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetFunctionsOKApplicationJSON to nil")
	}
	var unwrapped []FunctionResponse
	if err := func() error {
		unwrapped = make([]FunctionResponse, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem FunctionResponse
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetFunctionsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetFunctionsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetFunctionsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetOrganizationsOKApplicationJSON as json.
func (s GetOrganizationsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []OrganizationResponseV1(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetOrganizationsOKApplicationJSON from json.
func (s *GetOrganizationsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOrganizationsOKApplicationJSON to nil")
	}
	var unwrapped []OrganizationResponseV1
	if err := func() error {
		unwrapped = make([]OrganizationResponseV1, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem OrganizationResponseV1
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetOrganizationsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetOrganizationsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOrganizationsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetProjectApiKeysOKApplicationJSON as json.
func (s GetProjectApiKeysOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []ApiKeyResponse(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetProjectApiKeysOKApplicationJSON from json.
func (s *GetProjectApiKeysOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetProjectApiKeysOKApplicationJSON to nil")
	}
	var unwrapped []ApiKeyResponse
	if err := func() error {
		unwrapped = make([]ApiKeyResponse, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ApiKeyResponse
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetProjectApiKeysOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetProjectApiKeysOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetProjectApiKeysOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetProviderResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetProviderResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.Saml.Set {
			e.FieldStart("saml")
			s.Saml.Encode(e)
		}
	}
	{
		if s.Domains != nil {
			e.FieldStart("domains")
			e.ArrStart()
			for _, elem := range s.Domains {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetProviderResponse = [5]string{
	0: "id",
	1: "saml",
	2: "domains",
	3: "created_at",
	4: "updated_at",
}

// Decode decodes GetProviderResponse from json.
func (s *GetProviderResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetProviderResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "saml":
			if err := func() error {
				s.Saml.Reset()
				if err := s.Saml.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"saml\"")
			}
		case "domains":
			if err := func() error {
				s.Domains = make([]Domain, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Domain
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Domains = append(s.Domains, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domains\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetProviderResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetProviderResponse) {
					name = jsonFieldsNameOfGetProviderResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetProviderResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetProviderResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSecretsOKApplicationJSON as json.
func (s GetSecretsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []SecretResponse(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetSecretsOKApplicationJSON from json.
func (s *GetSecretsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSecretsOKApplicationJSON to nil")
	}
	var unwrapped []SecretResponse
	if err := func() error {
		unwrapped = make([]SecretResponse, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SecretResponse
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSecretsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSecretsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSecretsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListProvidersResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListProvidersResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfListProvidersResponse = [1]string{
	0: "items",
}

// Decode decodes ListProvidersResponse from json.
func (s *ListProvidersResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListProvidersResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Items = make([]Provider, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Provider
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListProvidersResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListProvidersResponse) {
					name = jsonFieldsNameOfListProvidersResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListProvidersResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListProvidersResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListTPAForProjectOKApplicationJSON as json.
func (s ListTPAForProjectOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []ThirdPartyAuth(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListTPAForProjectOKApplicationJSON from json.
func (s *ListTPAForProjectOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListTPAForProjectOKApplicationJSON to nil")
	}
	var unwrapped []ThirdPartyAuth
	if err := func() error {
		unwrapped = make([]ThirdPartyAuth, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ThirdPartyAuth
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListTPAForProjectOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListTPAForProjectOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListTPAForProjectOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NetworkBanResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NetworkBanResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("banned_ipv4_addresses")
		e.ArrStart()
		for _, elem := range s.BannedIpv4Addresses {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfNetworkBanResponse = [1]string{
	0: "banned_ipv4_addresses",
}

// Decode decodes NetworkBanResponse from json.
func (s *NetworkBanResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NetworkBanResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "banned_ipv4_addresses":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.BannedIpv4Addresses = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.BannedIpv4Addresses = append(s.BannedIpv4Addresses, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"banned_ipv4_addresses\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NetworkBanResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNetworkBanResponse) {
					name = jsonFieldsNameOfNetworkBanResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NetworkBanResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NetworkBanResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NetworkRestrictionsRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NetworkRestrictionsRequest) encodeFields(e *jx.Encoder) {
	{
		if s.DbAllowedCidrs != nil {
			e.FieldStart("dbAllowedCidrs")
			e.ArrStart()
			for _, elem := range s.DbAllowedCidrs {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DbAllowedCidrsV6 != nil {
			e.FieldStart("dbAllowedCidrsV6")
			e.ArrStart()
			for _, elem := range s.DbAllowedCidrsV6 {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNetworkRestrictionsRequest = [2]string{
	0: "dbAllowedCidrs",
	1: "dbAllowedCidrsV6",
}

// Decode decodes NetworkRestrictionsRequest from json.
func (s *NetworkRestrictionsRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NetworkRestrictionsRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dbAllowedCidrs":
			if err := func() error {
				s.DbAllowedCidrs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.DbAllowedCidrs = append(s.DbAllowedCidrs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dbAllowedCidrs\"")
			}
		case "dbAllowedCidrsV6":
			if err := func() error {
				s.DbAllowedCidrsV6 = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.DbAllowedCidrsV6 = append(s.DbAllowedCidrsV6, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dbAllowedCidrsV6\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NetworkRestrictionsRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NetworkRestrictionsRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NetworkRestrictionsRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NetworkRestrictionsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NetworkRestrictionsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("entitlement")
		s.Entitlement.Encode(e)
	}
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		if s.OldConfig.Set {
			e.FieldStart("old_config")
			s.OldConfig.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
}

var jsonFieldsNameOfNetworkRestrictionsResponse = [4]string{
	0: "entitlement",
	1: "config",
	2: "old_config",
	3: "status",
}

// Decode decodes NetworkRestrictionsResponse from json.
func (s *NetworkRestrictionsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NetworkRestrictionsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "entitlement":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Entitlement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entitlement\"")
			}
		case "config":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "old_config":
			if err := func() error {
				s.OldConfig.Reset()
				if err := s.OldConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"old_config\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NetworkRestrictionsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNetworkRestrictionsResponse) {
					name = jsonFieldsNameOfNetworkRestrictionsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NetworkRestrictionsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NetworkRestrictionsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NetworkRestrictionsResponseEntitlement as json.
func (s NetworkRestrictionsResponseEntitlement) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NetworkRestrictionsResponseEntitlement from json.
func (s *NetworkRestrictionsResponseEntitlement) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NetworkRestrictionsResponseEntitlement to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NetworkRestrictionsResponseEntitlement(v) {
	case NetworkRestrictionsResponseEntitlementDisallowed:
		*s = NetworkRestrictionsResponseEntitlementDisallowed
	case NetworkRestrictionsResponseEntitlementAllowed:
		*s = NetworkRestrictionsResponseEntitlementAllowed
	default:
		*s = NetworkRestrictionsResponseEntitlement(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NetworkRestrictionsResponseEntitlement) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NetworkRestrictionsResponseEntitlement) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NetworkRestrictionsResponseStatus as json.
func (s NetworkRestrictionsResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NetworkRestrictionsResponseStatus from json.
func (s *NetworkRestrictionsResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NetworkRestrictionsResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NetworkRestrictionsResponseStatus(v) {
	case NetworkRestrictionsResponseStatusStored:
		*s = NetworkRestrictionsResponseStatusStored
	case NetworkRestrictionsResponseStatusApplied:
		*s = NetworkRestrictionsResponseStatusApplied
	default:
		*s = NetworkRestrictionsResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NetworkRestrictionsResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NetworkRestrictionsResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o NilBool) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *NilBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilBool to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v bool
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseUpgradeStatusResponseDatabaseUpgradeStatus as json.
func (o NilDatabaseUpgradeStatusResponseDatabaseUpgradeStatus) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatabaseUpgradeStatusResponseDatabaseUpgradeStatus from json.
func (o *NilDatabaseUpgradeStatusResponseDatabaseUpgradeStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilDatabaseUpgradeStatusResponseDatabaseUpgradeStatus to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v DatabaseUpgradeStatusResponseDatabaseUpgradeStatus
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilDatabaseUpgradeStatusResponseDatabaseUpgradeStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilDatabaseUpgradeStatusResponseDatabaseUpgradeStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o NilFloat64) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *NilFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilFloat64 to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v float64
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o NilInt) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *NilInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilInt to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v int
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o NilString) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *NilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OAuthTokenResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OAuthTokenResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("token_type")
		s.TokenType.Encode(e)
	}
	{
		e.FieldStart("access_token")
		e.Str(s.AccessToken)
	}
	{
		e.FieldStart("refresh_token")
		e.Str(s.RefreshToken)
	}
	{
		e.FieldStart("expires_in")
		e.Float64(s.ExpiresIn)
	}
}

var jsonFieldsNameOfOAuthTokenResponse = [4]string{
	0: "token_type",
	1: "access_token",
	2: "refresh_token",
	3: "expires_in",
}

// Decode decodes OAuthTokenResponse from json.
func (s *OAuthTokenResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthTokenResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "token_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.TokenType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token_type\"")
			}
		case "access_token":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AccessToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_token\"")
			}
		case "refresh_token":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.RefreshToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"refresh_token\"")
			}
		case "expires_in":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.ExpiresIn = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_in\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OAuthTokenResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOAuthTokenResponse) {
					name = jsonFieldsNameOfOAuthTokenResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuthTokenResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuthTokenResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OAuthTokenResponseTokenType as json.
func (s OAuthTokenResponseTokenType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OAuthTokenResponseTokenType from json.
func (s *OAuthTokenResponseTokenType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthTokenResponseTokenType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OAuthTokenResponseTokenType(v) {
	case OAuthTokenResponseTokenTypeBearer:
		*s = OAuthTokenResponseTokenTypeBearer
	default:
		*s = OAuthTokenResponseTokenType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OAuthTokenResponseTokenType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuthTokenResponseTokenType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AttributeMapping as json.
func (o OptAttributeMapping) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AttributeMapping from json.
func (o *OptAttributeMapping) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAttributeMapping to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAttributeMapping) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAttributeMapping) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AttributeValueDefault as json.
func (o OptAttributeValueDefault) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AttributeValueDefault from json.
func (o *OptAttributeValueDefault) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAttributeValueDefault to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAttributeValueDefault) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAttributeValueDefault) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BillingPlanId as json.
func (o OptBillingPlanId) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BillingPlanId from json.
func (o *OptBillingPlanId) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBillingPlanId to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBillingPlanId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBillingPlanId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseUpgradeStatusResponseDatabaseUpgradeStatusError as json.
func (o OptDatabaseUpgradeStatusResponseDatabaseUpgradeStatusError) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DatabaseUpgradeStatusResponseDatabaseUpgradeStatusError from json.
func (o *OptDatabaseUpgradeStatusResponseDatabaseUpgradeStatusError) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseUpgradeStatusResponseDatabaseUpgradeStatusError to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseUpgradeStatusResponseDatabaseUpgradeStatusError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseUpgradeStatusResponseDatabaseUpgradeStatusError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress as json.
func (o OptDatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress from json.
func (o *OptDatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatabaseUpgradeStatusResponseDatabaseUpgradeStatusProgress) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DesiredInstanceSize as json.
func (o OptDesiredInstanceSize) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DesiredInstanceSize from json.
func (o *OptDesiredInstanceSize) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDesiredInstanceSize to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDesiredInstanceSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDesiredInstanceSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NetworkRestrictionsRequest as json.
func (o OptNetworkRestrictionsRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NetworkRestrictionsRequest from json.
func (o *OptNetworkRestrictionsRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNetworkRestrictionsRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNetworkRestrictionsRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNetworkRestrictionsRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PostgresConfigResponseSessionReplicationRole as json.
func (o OptPostgresConfigResponseSessionReplicationRole) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PostgresConfigResponseSessionReplicationRole from json.
func (o *OptPostgresConfigResponseSessionReplicationRole) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPostgresConfigResponseSessionReplicationRole to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPostgresConfigResponseSessionReplicationRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPostgresConfigResponseSessionReplicationRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SamlDescriptor as json.
func (o OptSamlDescriptor) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SamlDescriptor from json.
func (o *OptSamlDescriptor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSamlDescriptor to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSamlDescriptor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSamlDescriptor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes *ThirdPartyAuthCustomJwks as json.
func (o OptThirdPartyAuthCustomJwks) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes *ThirdPartyAuthCustomJwks from json.
func (o *OptThirdPartyAuthCustomJwks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptThirdPartyAuthCustomJwks to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptThirdPartyAuthCustomJwks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptThirdPartyAuthCustomJwks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes *ThirdPartyAuthResolvedJwks as json.
func (o OptThirdPartyAuthResolvedJwks) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes *ThirdPartyAuthResolvedJwks from json.
func (o *OptThirdPartyAuthResolvedJwks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptThirdPartyAuthResolvedJwks to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptThirdPartyAuthResolvedJwks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptThirdPartyAuthResolvedJwks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateAuthConfigBodyPasswordRequiredCharacters as json.
func (o OptUpdateAuthConfigBodyPasswordRequiredCharacters) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateAuthConfigBodyPasswordRequiredCharacters from json.
func (o *OptUpdateAuthConfigBodyPasswordRequiredCharacters) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateAuthConfigBodyPasswordRequiredCharacters to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateAuthConfigBodyPasswordRequiredCharacters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateAuthConfigBodyPasswordRequiredCharacters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdatePostgresConfigBodySessionReplicationRole as json.
func (o OptUpdatePostgresConfigBodySessionReplicationRole) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdatePostgresConfigBodySessionReplicationRole from json.
func (o *OptUpdatePostgresConfigBodySessionReplicationRole) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdatePostgresConfigBodySessionReplicationRole to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdatePostgresConfigBodySessionReplicationRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdatePostgresConfigBodySessionReplicationRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1CreateProjectBodyPlan as json.
func (o OptV1CreateProjectBodyPlan) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes V1CreateProjectBodyPlan from json.
func (o *OptV1CreateProjectBodyPlan) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1CreateProjectBodyPlan to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1CreateProjectBodyPlan) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1CreateProjectBodyPlan) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1DatabaseResponse as json.
func (o OptV1DatabaseResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes V1DatabaseResponse from json.
func (o *OptV1DatabaseResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1DatabaseResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1DatabaseResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1DatabaseResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1PgbouncerConfigResponsePoolMode as json.
func (o OptV1PgbouncerConfigResponsePoolMode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes V1PgbouncerConfigResponsePoolMode from json.
func (o *OptV1PgbouncerConfigResponsePoolMode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1PgbouncerConfigResponsePoolMode to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1PgbouncerConfigResponsePoolMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1PgbouncerConfigResponsePoolMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1ServiceHealthResponseInfo as json.
func (o OptV1ServiceHealthResponseInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes V1ServiceHealthResponseInfo from json.
func (o *OptV1ServiceHealthResponseInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1ServiceHealthResponseInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1ServiceHealthResponseInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1ServiceHealthResponseInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrganizationResponseV1) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrganizationResponseV1) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfOrganizationResponseV1 = [2]string{
	0: "id",
	1: "name",
}

// Decode decodes OrganizationResponseV1 from json.
func (s *OrganizationResponseV1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrganizationResponseV1 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrganizationResponseV1")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrganizationResponseV1) {
					name = jsonFieldsNameOfOrganizationResponseV1[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrganizationResponseV1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrganizationResponseV1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PgsodiumConfigResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PgsodiumConfigResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("root_key")
		e.Str(s.RootKey)
	}
}

var jsonFieldsNameOfPgsodiumConfigResponse = [1]string{
	0: "root_key",
}

// Decode decodes PgsodiumConfigResponse from json.
func (s *PgsodiumConfigResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PgsodiumConfigResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "root_key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.RootKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"root_key\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PgsodiumConfigResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPgsodiumConfigResponse) {
					name = jsonFieldsNameOfPgsodiumConfigResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PgsodiumConfigResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PgsodiumConfigResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PostgresConfigResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PostgresConfigResponse) encodeFields(e *jx.Encoder) {
	{
		if s.StatementTimeout.Set {
			e.FieldStart("statement_timeout")
			s.StatementTimeout.Encode(e)
		}
	}
	{
		if s.EffectiveCacheSize.Set {
			e.FieldStart("effective_cache_size")
			s.EffectiveCacheSize.Encode(e)
		}
	}
	{
		if s.MaintenanceWorkMem.Set {
			e.FieldStart("maintenance_work_mem")
			s.MaintenanceWorkMem.Encode(e)
		}
	}
	{
		if s.MaxConnections.Set {
			e.FieldStart("max_connections")
			s.MaxConnections.Encode(e)
		}
	}
	{
		if s.MaxLocksPerTransaction.Set {
			e.FieldStart("max_locks_per_transaction")
			s.MaxLocksPerTransaction.Encode(e)
		}
	}
	{
		if s.MaxParallelMaintenanceWorkers.Set {
			e.FieldStart("max_parallel_maintenance_workers")
			s.MaxParallelMaintenanceWorkers.Encode(e)
		}
	}
	{
		if s.MaxParallelWorkers.Set {
			e.FieldStart("max_parallel_workers")
			s.MaxParallelWorkers.Encode(e)
		}
	}
	{
		if s.MaxParallelWorkersPerGather.Set {
			e.FieldStart("max_parallel_workers_per_gather")
			s.MaxParallelWorkersPerGather.Encode(e)
		}
	}
	{
		if s.MaxStandbyArchiveDelay.Set {
			e.FieldStart("max_standby_archive_delay")
			s.MaxStandbyArchiveDelay.Encode(e)
		}
	}
	{
		if s.MaxStandbyStreamingDelay.Set {
			e.FieldStart("max_standby_streaming_delay")
			s.MaxStandbyStreamingDelay.Encode(e)
		}
	}
	{
		if s.MaxWorkerProcesses.Set {
			e.FieldStart("max_worker_processes")
			s.MaxWorkerProcesses.Encode(e)
		}
	}
	{
		if s.SharedBuffers.Set {
			e.FieldStart("shared_buffers")
			s.SharedBuffers.Encode(e)
		}
	}
	{
		if s.WorkMem.Set {
			e.FieldStart("work_mem")
			s.WorkMem.Encode(e)
		}
	}
	{
		if s.SessionReplicationRole.Set {
			e.FieldStart("session_replication_role")
			s.SessionReplicationRole.Encode(e)
		}
	}
}

var jsonFieldsNameOfPostgresConfigResponse = [14]string{
	0:  "statement_timeout",
	1:  "effective_cache_size",
	2:  "maintenance_work_mem",
	3:  "max_connections",
	4:  "max_locks_per_transaction",
	5:  "max_parallel_maintenance_workers",
	6:  "max_parallel_workers",
	7:  "max_parallel_workers_per_gather",
	8:  "max_standby_archive_delay",
	9:  "max_standby_streaming_delay",
	10: "max_worker_processes",
	11: "shared_buffers",
	12: "work_mem",
	13: "session_replication_role",
}

// Decode decodes PostgresConfigResponse from json.
func (s *PostgresConfigResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PostgresConfigResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "statement_timeout":
			if err := func() error {
				s.StatementTimeout.Reset()
				if err := s.StatementTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statement_timeout\"")
			}
		case "effective_cache_size":
			if err := func() error {
				s.EffectiveCacheSize.Reset()
				if err := s.EffectiveCacheSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effective_cache_size\"")
			}
		case "maintenance_work_mem":
			if err := func() error {
				s.MaintenanceWorkMem.Reset()
				if err := s.MaintenanceWorkMem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintenance_work_mem\"")
			}
		case "max_connections":
			if err := func() error {
				s.MaxConnections.Reset()
				if err := s.MaxConnections.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_connections\"")
			}
		case "max_locks_per_transaction":
			if err := func() error {
				s.MaxLocksPerTransaction.Reset()
				if err := s.MaxLocksPerTransaction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_locks_per_transaction\"")
			}
		case "max_parallel_maintenance_workers":
			if err := func() error {
				s.MaxParallelMaintenanceWorkers.Reset()
				if err := s.MaxParallelMaintenanceWorkers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_parallel_maintenance_workers\"")
			}
		case "max_parallel_workers":
			if err := func() error {
				s.MaxParallelWorkers.Reset()
				if err := s.MaxParallelWorkers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_parallel_workers\"")
			}
		case "max_parallel_workers_per_gather":
			if err := func() error {
				s.MaxParallelWorkersPerGather.Reset()
				if err := s.MaxParallelWorkersPerGather.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_parallel_workers_per_gather\"")
			}
		case "max_standby_archive_delay":
			if err := func() error {
				s.MaxStandbyArchiveDelay.Reset()
				if err := s.MaxStandbyArchiveDelay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_standby_archive_delay\"")
			}
		case "max_standby_streaming_delay":
			if err := func() error {
				s.MaxStandbyStreamingDelay.Reset()
				if err := s.MaxStandbyStreamingDelay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_standby_streaming_delay\"")
			}
		case "max_worker_processes":
			if err := func() error {
				s.MaxWorkerProcesses.Reset()
				if err := s.MaxWorkerProcesses.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_worker_processes\"")
			}
		case "shared_buffers":
			if err := func() error {
				s.SharedBuffers.Reset()
				if err := s.SharedBuffers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shared_buffers\"")
			}
		case "work_mem":
			if err := func() error {
				s.WorkMem.Reset()
				if err := s.WorkMem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"work_mem\"")
			}
		case "session_replication_role":
			if err := func() error {
				s.SessionReplicationRole.Reset()
				if err := s.SessionReplicationRole.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_replication_role\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PostgresConfigResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PostgresConfigResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PostgresConfigResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PostgresConfigResponseSessionReplicationRole as json.
func (s PostgresConfigResponseSessionReplicationRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PostgresConfigResponseSessionReplicationRole from json.
func (s *PostgresConfigResponseSessionReplicationRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PostgresConfigResponseSessionReplicationRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PostgresConfigResponseSessionReplicationRole(v) {
	case PostgresConfigResponseSessionReplicationRoleOrigin:
		*s = PostgresConfigResponseSessionReplicationRoleOrigin
	case PostgresConfigResponseSessionReplicationRoleReplica:
		*s = PostgresConfigResponseSessionReplicationRoleReplica
	case PostgresConfigResponseSessionReplicationRoleLocal:
		*s = PostgresConfigResponseSessionReplicationRoleLocal
	default:
		*s = PostgresConfigResponseSessionReplicationRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PostgresConfigResponseSessionReplicationRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PostgresConfigResponseSessionReplicationRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PostgrestConfigWithJWTSecretResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PostgrestConfigWithJWTSecretResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("max_rows")
		e.Int(s.MaxRows)
	}
	{
		e.FieldStart("db_pool")
		s.DbPool.Encode(e)
	}
	{
		e.FieldStart("db_schema")
		e.Str(s.DbSchema)
	}
	{
		e.FieldStart("db_extra_search_path")
		e.Str(s.DbExtraSearchPath)
	}
	{
		if s.JwtSecret.Set {
			e.FieldStart("jwt_secret")
			s.JwtSecret.Encode(e)
		}
	}
}

var jsonFieldsNameOfPostgrestConfigWithJWTSecretResponse = [5]string{
	0: "max_rows",
	1: "db_pool",
	2: "db_schema",
	3: "db_extra_search_path",
	4: "jwt_secret",
}

// Decode decodes PostgrestConfigWithJWTSecretResponse from json.
func (s *PostgrestConfigWithJWTSecretResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PostgrestConfigWithJWTSecretResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "max_rows":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MaxRows = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_rows\"")
			}
		case "db_pool":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.DbPool.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"db_pool\"")
			}
		case "db_schema":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DbSchema = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"db_schema\"")
			}
		case "db_extra_search_path":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.DbExtraSearchPath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"db_extra_search_path\"")
			}
		case "jwt_secret":
			if err := func() error {
				s.JwtSecret.Reset()
				if err := s.JwtSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jwt_secret\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PostgrestConfigWithJWTSecretResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPostgrestConfigWithJWTSecretResponse) {
					name = jsonFieldsNameOfPostgrestConfigWithJWTSecretResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PostgrestConfigWithJWTSecretResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PostgrestConfigWithJWTSecretResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectUpgradeEligibilityResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectUpgradeEligibilityResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("eligible")
		e.Bool(s.Eligible)
	}
	{
		e.FieldStart("current_app_version")
		e.Str(s.CurrentAppVersion)
	}
	{
		e.FieldStart("latest_app_version")
		e.Str(s.LatestAppVersion)
	}
	{
		e.FieldStart("target_upgrade_versions")
		e.ArrStart()
		for _, elem := range s.TargetUpgradeVersions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("potential_breaking_changes")
		e.ArrStart()
		for _, elem := range s.PotentialBreakingChanges {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("duration_estimate_hours")
		e.Float64(s.DurationEstimateHours)
	}
	{
		e.FieldStart("legacy_auth_custom_roles")
		e.ArrStart()
		for _, elem := range s.LegacyAuthCustomRoles {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("extension_dependent_objects")
		e.ArrStart()
		for _, elem := range s.ExtensionDependentObjects {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfProjectUpgradeEligibilityResponse = [8]string{
	0: "eligible",
	1: "current_app_version",
	2: "latest_app_version",
	3: "target_upgrade_versions",
	4: "potential_breaking_changes",
	5: "duration_estimate_hours",
	6: "legacy_auth_custom_roles",
	7: "extension_dependent_objects",
}

// Decode decodes ProjectUpgradeEligibilityResponse from json.
func (s *ProjectUpgradeEligibilityResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectUpgradeEligibilityResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "eligible":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Eligible = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eligible\"")
			}
		case "current_app_version":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CurrentAppVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_app_version\"")
			}
		case "latest_app_version":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.LatestAppVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latest_app_version\"")
			}
		case "target_upgrade_versions":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.TargetUpgradeVersions = make([]ProjectVersion, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ProjectVersion
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TargetUpgradeVersions = append(s.TargetUpgradeVersions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_upgrade_versions\"")
			}
		case "potential_breaking_changes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.PotentialBreakingChanges = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PotentialBreakingChanges = append(s.PotentialBreakingChanges, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"potential_breaking_changes\"")
			}
		case "duration_estimate_hours":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.DurationEstimateHours = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_estimate_hours\"")
			}
		case "legacy_auth_custom_roles":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				s.LegacyAuthCustomRoles = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.LegacyAuthCustomRoles = append(s.LegacyAuthCustomRoles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"legacy_auth_custom_roles\"")
			}
		case "extension_dependent_objects":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.ExtensionDependentObjects = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ExtensionDependentObjects = append(s.ExtensionDependentObjects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"extension_dependent_objects\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectUpgradeEligibilityResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectUpgradeEligibilityResponse) {
					name = jsonFieldsNameOfProjectUpgradeEligibilityResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectUpgradeEligibilityResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectUpgradeEligibilityResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectUpgradeInitiateResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectUpgradeInitiateResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("tracking_id")
		e.Str(s.TrackingID)
	}
}

var jsonFieldsNameOfProjectUpgradeInitiateResponse = [1]string{
	0: "tracking_id",
}

// Decode decodes ProjectUpgradeInitiateResponse from json.
func (s *ProjectUpgradeInitiateResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectUpgradeInitiateResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tracking_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TrackingID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tracking_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectUpgradeInitiateResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectUpgradeInitiateResponse) {
					name = jsonFieldsNameOfProjectUpgradeInitiateResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectUpgradeInitiateResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectUpgradeInitiateResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectVersion) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectVersion) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("postgres_version")
		e.Float64(s.PostgresVersion)
	}
	{
		e.FieldStart("app_version")
		e.Str(s.AppVersion)
	}
}

var jsonFieldsNameOfProjectVersion = [2]string{
	0: "postgres_version",
	1: "app_version",
}

// Decode decodes ProjectVersion from json.
func (s *ProjectVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectVersion to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "postgres_version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.PostgresVersion = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"postgres_version\"")
			}
		case "app_version":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AppVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"app_version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectVersion")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectVersion) {
					name = jsonFieldsNameOfProjectVersion[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Provider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Provider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.Saml.Set {
			e.FieldStart("saml")
			s.Saml.Encode(e)
		}
	}
	{
		if s.Domains != nil {
			e.FieldStart("domains")
			e.ArrStart()
			for _, elem := range s.Domains {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfProvider = [5]string{
	0: "id",
	1: "saml",
	2: "domains",
	3: "created_at",
	4: "updated_at",
}

// Decode decodes Provider from json.
func (s *Provider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Provider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "saml":
			if err := func() error {
				s.Saml.Reset()
				if err := s.Saml.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"saml\"")
			}
		case "domains":
			if err := func() error {
				s.Domains = make([]Domain, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Domain
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Domains = append(s.Domains, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domains\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Provider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProvider) {
					name = jsonFieldsNameOfProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Provider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Provider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReadOnlyStatusResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReadOnlyStatusResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("override_enabled")
		e.Bool(s.OverrideEnabled)
	}
	{
		e.FieldStart("override_active_until")
		e.Str(s.OverrideActiveUntil)
	}
}

var jsonFieldsNameOfReadOnlyStatusResponse = [3]string{
	0: "enabled",
	1: "override_enabled",
	2: "override_active_until",
}

// Decode decodes ReadOnlyStatusResponse from json.
func (s *ReadOnlyStatusResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReadOnlyStatusResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "override_enabled":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.OverrideEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"override_enabled\"")
			}
		case "override_active_until":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.OverrideActiveUntil = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"override_active_until\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReadOnlyStatusResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReadOnlyStatusResponse) {
					name = jsonFieldsNameOfReadOnlyStatusResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReadOnlyStatusResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReadOnlyStatusResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RealtimeHealthResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RealtimeHealthResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("healthy")
		e.Bool(s.Healthy)
	}
	{
		e.FieldStart("db_connected")
		e.Bool(s.DbConnected)
	}
	{
		e.FieldStart("connected_cluster")
		e.Float64(s.ConnectedCluster)
	}
}

var jsonFieldsNameOfRealtimeHealthResponse = [3]string{
	0: "healthy",
	1: "db_connected",
	2: "connected_cluster",
}

// Decode decodes RealtimeHealthResponse from json.
func (s *RealtimeHealthResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RealtimeHealthResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "healthy":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Healthy = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"healthy\"")
			}
		case "db_connected":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.DbConnected = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"db_connected\"")
			}
		case "connected_cluster":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.ConnectedCluster = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connected_cluster\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RealtimeHealthResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRealtimeHealthResponse) {
					name = jsonFieldsNameOfRealtimeHealthResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RealtimeHealthResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RealtimeHealthResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemoveNetworkBanRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemoveNetworkBanRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ipv4_addresses")
		e.ArrStart()
		for _, elem := range s.Ipv4Addresses {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfRemoveNetworkBanRequest = [1]string{
	0: "ipv4_addresses",
}

// Decode decodes RemoveNetworkBanRequest from json.
func (s *RemoveNetworkBanRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveNetworkBanRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ipv4_addresses":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Ipv4Addresses = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Ipv4Addresses = append(s.Ipv4Addresses, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipv4_addresses\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemoveNetworkBanRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRemoveNetworkBanRequest) {
					name = jsonFieldsNameOfRemoveNetworkBanRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveNetworkBanRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveNetworkBanRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemoveReadReplicaBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemoveReadReplicaBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("database_identifier")
		e.Str(s.DatabaseIdentifier)
	}
}

var jsonFieldsNameOfRemoveReadReplicaBody = [1]string{
	0: "database_identifier",
}

// Decode decodes RemoveReadReplicaBody from json.
func (s *RemoveReadReplicaBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveReadReplicaBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "database_identifier":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DatabaseIdentifier = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"database_identifier\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemoveReadReplicaBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRemoveReadReplicaBody) {
					name = jsonFieldsNameOfRemoveReadReplicaBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveReadReplicaBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveReadReplicaBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SamlDescriptor) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SamlDescriptor) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("entity_id")
		e.Str(s.EntityID)
	}
	{
		if s.MetadataURL.Set {
			e.FieldStart("metadata_url")
			s.MetadataURL.Encode(e)
		}
	}
	{
		if s.MetadataXML.Set {
			e.FieldStart("metadata_xml")
			s.MetadataXML.Encode(e)
		}
	}
	{
		if s.AttributeMapping.Set {
			e.FieldStart("attribute_mapping")
			s.AttributeMapping.Encode(e)
		}
	}
}

var jsonFieldsNameOfSamlDescriptor = [5]string{
	0: "id",
	1: "entity_id",
	2: "metadata_url",
	3: "metadata_xml",
	4: "attribute_mapping",
}

// Decode decodes SamlDescriptor from json.
func (s *SamlDescriptor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SamlDescriptor to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "entity_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.EntityID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entity_id\"")
			}
		case "metadata_url":
			if err := func() error {
				s.MetadataURL.Reset()
				if err := s.MetadataURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata_url\"")
			}
		case "metadata_xml":
			if err := func() error {
				s.MetadataXML.Reset()
				if err := s.MetadataXML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata_xml\"")
			}
		case "attribute_mapping":
			if err := func() error {
				s.AttributeMapping.Reset()
				if err := s.AttributeMapping.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attribute_mapping\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SamlDescriptor")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSamlDescriptor) {
					name = jsonFieldsNameOfSamlDescriptor[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SamlDescriptor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SamlDescriptor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SecretResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SecretResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfSecretResponse = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes SecretResponse from json.
func (s *SecretResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecretResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SecretResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSecretResponse) {
					name = jsonFieldsNameOfSecretResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SecretResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SecretResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetUpReadReplicaBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetUpReadReplicaBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("read_replica_region")
		s.ReadReplicaRegion.Encode(e)
	}
}

var jsonFieldsNameOfSetUpReadReplicaBody = [1]string{
	0: "read_replica_region",
}

// Decode decodes SetUpReadReplicaBody from json.
func (s *SetUpReadReplicaBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetUpReadReplicaBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "read_replica_region":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ReadReplicaRegion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"read_replica_region\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetUpReadReplicaBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetUpReadReplicaBody) {
					name = jsonFieldsNameOfSetUpReadReplicaBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetUpReadReplicaBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetUpReadReplicaBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SetUpReadReplicaBodyReadReplicaRegion as json.
func (s SetUpReadReplicaBodyReadReplicaRegion) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SetUpReadReplicaBodyReadReplicaRegion from json.
func (s *SetUpReadReplicaBodyReadReplicaRegion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetUpReadReplicaBodyReadReplicaRegion to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SetUpReadReplicaBodyReadReplicaRegion(v) {
	case SetUpReadReplicaBodyReadReplicaRegionUsEast1:
		*s = SetUpReadReplicaBodyReadReplicaRegionUsEast1
	case SetUpReadReplicaBodyReadReplicaRegionUsWest1:
		*s = SetUpReadReplicaBodyReadReplicaRegionUsWest1
	case SetUpReadReplicaBodyReadReplicaRegionUsWest2:
		*s = SetUpReadReplicaBodyReadReplicaRegionUsWest2
	case SetUpReadReplicaBodyReadReplicaRegionApEast1:
		*s = SetUpReadReplicaBodyReadReplicaRegionApEast1
	case SetUpReadReplicaBodyReadReplicaRegionApSoutheast1:
		*s = SetUpReadReplicaBodyReadReplicaRegionApSoutheast1
	case SetUpReadReplicaBodyReadReplicaRegionApNortheast1:
		*s = SetUpReadReplicaBodyReadReplicaRegionApNortheast1
	case SetUpReadReplicaBodyReadReplicaRegionApNortheast2:
		*s = SetUpReadReplicaBodyReadReplicaRegionApNortheast2
	case SetUpReadReplicaBodyReadReplicaRegionApSoutheast2:
		*s = SetUpReadReplicaBodyReadReplicaRegionApSoutheast2
	case SetUpReadReplicaBodyReadReplicaRegionEuWest1:
		*s = SetUpReadReplicaBodyReadReplicaRegionEuWest1
	case SetUpReadReplicaBodyReadReplicaRegionEuWest2:
		*s = SetUpReadReplicaBodyReadReplicaRegionEuWest2
	case SetUpReadReplicaBodyReadReplicaRegionEuWest3:
		*s = SetUpReadReplicaBodyReadReplicaRegionEuWest3
	case SetUpReadReplicaBodyReadReplicaRegionEuCentral1:
		*s = SetUpReadReplicaBodyReadReplicaRegionEuCentral1
	case SetUpReadReplicaBodyReadReplicaRegionCaCentral1:
		*s = SetUpReadReplicaBodyReadReplicaRegionCaCentral1
	case SetUpReadReplicaBodyReadReplicaRegionApSouth1:
		*s = SetUpReadReplicaBodyReadReplicaRegionApSouth1
	case SetUpReadReplicaBodyReadReplicaRegionSaEast1:
		*s = SetUpReadReplicaBodyReadReplicaRegionSaEast1
	default:
		*s = SetUpReadReplicaBodyReadReplicaRegion(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SetUpReadReplicaBodyReadReplicaRegion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetUpReadReplicaBodyReadReplicaRegion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SnippetContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SnippetContent) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("favorite")
		e.Bool(s.Favorite)
	}
	{
		e.FieldStart("schema_version")
		e.Str(s.SchemaVersion)
	}
	{
		e.FieldStart("sql")
		e.Str(s.SQL)
	}
}

var jsonFieldsNameOfSnippetContent = [3]string{
	0: "favorite",
	1: "schema_version",
	2: "sql",
}

// Decode decodes SnippetContent from json.
func (s *SnippetContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SnippetContent to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "favorite":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Favorite = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorite\"")
			}
		case "schema_version":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SchemaVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schema_version\"")
			}
		case "sql":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.SQL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sql\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SnippetContent")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSnippetContent) {
					name = jsonFieldsNameOfSnippetContent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SnippetContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SnippetContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SnippetList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SnippetList) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSnippetList = [1]string{
	0: "data",
}

// Decode decodes SnippetList from json.
func (s *SnippetList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SnippetList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]SnippetMeta, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SnippetMeta
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SnippetList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSnippetList) {
					name = jsonFieldsNameOfSnippetList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SnippetList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SnippetList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SnippetMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SnippetMeta) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("inserted_at")
		e.Str(s.InsertedAt)
	}
	{
		e.FieldStart("updated_at")
		e.Str(s.UpdatedAt)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("visibility")
		s.Visibility.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("project")
		s.Project.Encode(e)
	}
	{
		e.FieldStart("owner")
		s.Owner.Encode(e)
	}
	{
		e.FieldStart("updated_by")
		s.UpdatedBy.Encode(e)
	}
}

var jsonFieldsNameOfSnippetMeta = [10]string{
	0: "id",
	1: "inserted_at",
	2: "updated_at",
	3: "type",
	4: "visibility",
	5: "name",
	6: "description",
	7: "project",
	8: "owner",
	9: "updated_by",
}

// Decode decodes SnippetMeta from json.
func (s *SnippetMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SnippetMeta to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "inserted_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InsertedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inserted_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.UpdatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "visibility":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "project":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Project.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project\"")
			}
		case "owner":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "updated_by":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.UpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_by\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SnippetMeta")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSnippetMeta) {
					name = jsonFieldsNameOfSnippetMeta[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SnippetMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SnippetMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SnippetMetaType as json.
func (s SnippetMetaType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SnippetMetaType from json.
func (s *SnippetMetaType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SnippetMetaType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SnippetMetaType(v) {
	case SnippetMetaTypeSQL:
		*s = SnippetMetaTypeSQL
	default:
		*s = SnippetMetaType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SnippetMetaType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SnippetMetaType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SnippetMetaVisibility as json.
func (s SnippetMetaVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SnippetMetaVisibility from json.
func (s *SnippetMetaVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SnippetMetaVisibility to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SnippetMetaVisibility(v) {
	case SnippetMetaVisibilityUser:
		*s = SnippetMetaVisibilityUser
	case SnippetMetaVisibilityProject:
		*s = SnippetMetaVisibilityProject
	case SnippetMetaVisibilityOrg:
		*s = SnippetMetaVisibilityOrg
	case SnippetMetaVisibilityPublic:
		*s = SnippetMetaVisibilityPublic
	default:
		*s = SnippetMetaVisibility(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SnippetMetaVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SnippetMetaVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SnippetProject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SnippetProject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Float64(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfSnippetProject = [2]string{
	0: "id",
	1: "name",
}

// Decode decodes SnippetProject from json.
func (s *SnippetProject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SnippetProject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.ID = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SnippetProject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSnippetProject) {
					name = jsonFieldsNameOfSnippetProject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SnippetProject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SnippetProject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SnippetResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SnippetResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("inserted_at")
		e.Str(s.InsertedAt)
	}
	{
		e.FieldStart("updated_at")
		e.Str(s.UpdatedAt)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("visibility")
		s.Visibility.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("project")
		s.Project.Encode(e)
	}
	{
		e.FieldStart("owner")
		s.Owner.Encode(e)
	}
	{
		e.FieldStart("updated_by")
		s.UpdatedBy.Encode(e)
	}
	{
		e.FieldStart("content")
		s.Content.Encode(e)
	}
}

var jsonFieldsNameOfSnippetResponse = [11]string{
	0:  "id",
	1:  "inserted_at",
	2:  "updated_at",
	3:  "type",
	4:  "visibility",
	5:  "name",
	6:  "description",
	7:  "project",
	8:  "owner",
	9:  "updated_by",
	10: "content",
}

// Decode decodes SnippetResponse from json.
func (s *SnippetResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SnippetResponse to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "inserted_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InsertedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inserted_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.UpdatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "visibility":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "project":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Project.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project\"")
			}
		case "owner":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "updated_by":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.UpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_by\"")
			}
		case "content":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SnippetResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSnippetResponse) {
					name = jsonFieldsNameOfSnippetResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SnippetResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SnippetResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SnippetResponseType as json.
func (s SnippetResponseType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SnippetResponseType from json.
func (s *SnippetResponseType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SnippetResponseType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SnippetResponseType(v) {
	case SnippetResponseTypeSQL:
		*s = SnippetResponseTypeSQL
	default:
		*s = SnippetResponseType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SnippetResponseType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SnippetResponseType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SnippetResponseVisibility as json.
func (s SnippetResponseVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SnippetResponseVisibility from json.
func (s *SnippetResponseVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SnippetResponseVisibility to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SnippetResponseVisibility(v) {
	case SnippetResponseVisibilityUser:
		*s = SnippetResponseVisibilityUser
	case SnippetResponseVisibilityProject:
		*s = SnippetResponseVisibilityProject
	case SnippetResponseVisibilityOrg:
		*s = SnippetResponseVisibilityOrg
	case SnippetResponseVisibilityPublic:
		*s = SnippetResponseVisibilityPublic
	default:
		*s = SnippetResponseVisibility(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SnippetResponseVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SnippetResponseVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SnippetUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SnippetUser) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Float64(s.ID)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
}

var jsonFieldsNameOfSnippetUser = [2]string{
	0: "id",
	1: "username",
}

// Decode decodes SnippetUser from json.
func (s *SnippetUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SnippetUser to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.ID = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SnippetUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSnippetUser) {
					name = jsonFieldsNameOfSnippetUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SnippetUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SnippetUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SslEnforcementRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SslEnforcementRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("requestedConfig")
		s.RequestedConfig.Encode(e)
	}
}

var jsonFieldsNameOfSslEnforcementRequest = [1]string{
	0: "requestedConfig",
}

// Decode decodes SslEnforcementRequest from json.
func (s *SslEnforcementRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SslEnforcementRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "requestedConfig":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.RequestedConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestedConfig\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SslEnforcementRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSslEnforcementRequest) {
					name = jsonFieldsNameOfSslEnforcementRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SslEnforcementRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SslEnforcementRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SslEnforcementResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SslEnforcementResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("currentConfig")
		s.CurrentConfig.Encode(e)
	}
	{
		e.FieldStart("appliedSuccessfully")
		e.Bool(s.AppliedSuccessfully)
	}
}

var jsonFieldsNameOfSslEnforcementResponse = [2]string{
	0: "currentConfig",
	1: "appliedSuccessfully",
}

// Decode decodes SslEnforcementResponse from json.
func (s *SslEnforcementResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SslEnforcementResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currentConfig":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.CurrentConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentConfig\"")
			}
		case "appliedSuccessfully":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.AppliedSuccessfully = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"appliedSuccessfully\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SslEnforcementResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSslEnforcementResponse) {
					name = jsonFieldsNameOfSslEnforcementResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SslEnforcementResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SslEnforcementResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SslEnforcements) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SslEnforcements) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("database")
		e.Bool(s.Database)
	}
}

var jsonFieldsNameOfSslEnforcements = [1]string{
	0: "database",
}

// Decode decodes SslEnforcements from json.
func (s *SslEnforcements) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SslEnforcements to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "database":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Database = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"database\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SslEnforcements")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSslEnforcements) {
					name = jsonFieldsNameOfSslEnforcements[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SslEnforcements) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SslEnforcements) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubdomainAvailabilityResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubdomainAvailabilityResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("available")
		e.Bool(s.Available)
	}
}

var jsonFieldsNameOfSubdomainAvailabilityResponse = [1]string{
	0: "available",
}

// Decode decodes SubdomainAvailabilityResponse from json.
func (s *SubdomainAvailabilityResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubdomainAvailabilityResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "available":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Available = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"available\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubdomainAvailabilityResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSubdomainAvailabilityResponse) {
					name = jsonFieldsNameOfSubdomainAvailabilityResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubdomainAvailabilityResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubdomainAvailabilityResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ThirdPartyAuth) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ThirdPartyAuth) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		if s.OidcIssuerURL.Set {
			e.FieldStart("oidc_issuer_url")
			s.OidcIssuerURL.Encode(e)
		}
	}
	{
		if s.JwksURL.Set {
			e.FieldStart("jwks_url")
			s.JwksURL.Encode(e)
		}
	}
	{
		if s.CustomJwks.Set {
			e.FieldStart("custom_jwks")
			s.CustomJwks.Encode(e)
		}
	}
	{
		if s.ResolvedJwks.Set {
			e.FieldStart("resolved_jwks")
			s.ResolvedJwks.Encode(e)
		}
	}
	{
		e.FieldStart("inserted_at")
		e.Str(s.InsertedAt)
	}
	{
		e.FieldStart("updated_at")
		e.Str(s.UpdatedAt)
	}
	{
		if s.ResolvedAt.Set {
			e.FieldStart("resolved_at")
			s.ResolvedAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfThirdPartyAuth = [9]string{
	0: "id",
	1: "type",
	2: "oidc_issuer_url",
	3: "jwks_url",
	4: "custom_jwks",
	5: "resolved_jwks",
	6: "inserted_at",
	7: "updated_at",
	8: "resolved_at",
}

// Decode decodes ThirdPartyAuth from json.
func (s *ThirdPartyAuth) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ThirdPartyAuth to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "oidc_issuer_url":
			if err := func() error {
				s.OidcIssuerURL.Reset()
				if err := s.OidcIssuerURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oidc_issuer_url\"")
			}
		case "jwks_url":
			if err := func() error {
				s.JwksURL.Reset()
				if err := s.JwksURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jwks_url\"")
			}
		case "custom_jwks":
			if err := func() error {
				s.CustomJwks.Reset()
				if err := s.CustomJwks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_jwks\"")
			}
		case "resolved_jwks":
			if err := func() error {
				s.ResolvedJwks.Reset()
				if err := s.ResolvedJwks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resolved_jwks\"")
			}
		case "inserted_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.InsertedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inserted_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.UpdatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "resolved_at":
			if err := func() error {
				s.ResolvedAt.Reset()
				if err := s.ResolvedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resolved_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ThirdPartyAuth")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfThirdPartyAuth) {
					name = jsonFieldsNameOfThirdPartyAuth[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ThirdPartyAuth) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ThirdPartyAuth) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ThirdPartyAuthCustomJwks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ThirdPartyAuthCustomJwks) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfThirdPartyAuthCustomJwks = [0]string{}

// Decode decodes ThirdPartyAuthCustomJwks from json.
func (s *ThirdPartyAuthCustomJwks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ThirdPartyAuthCustomJwks to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ThirdPartyAuthCustomJwks")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ThirdPartyAuthCustomJwks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ThirdPartyAuthCustomJwks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ThirdPartyAuthResolvedJwks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ThirdPartyAuthResolvedJwks) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfThirdPartyAuthResolvedJwks = [0]string{}

// Decode decodes ThirdPartyAuthResolvedJwks from json.
func (s *ThirdPartyAuthResolvedJwks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ThirdPartyAuthResolvedJwks to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ThirdPartyAuthResolvedJwks")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ThirdPartyAuthResolvedJwks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ThirdPartyAuthResolvedJwks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TypescriptResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TypescriptResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("types")
		e.Str(s.Types)
	}
}

var jsonFieldsNameOfTypescriptResponse = [1]string{
	0: "types",
}

// Decode decodes TypescriptResponse from json.
func (s *TypescriptResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TypescriptResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "types":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Types = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"types\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TypescriptResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTypescriptResponse) {
					name = jsonFieldsNameOfTypescriptResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TypescriptResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TypescriptResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateAuthConfigBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateAuthConfigBody) encodeFields(e *jx.Encoder) {
	{
		if s.SiteURL.Set {
			e.FieldStart("site_url")
			s.SiteURL.Encode(e)
		}
	}
	{
		if s.DisableSignup.Set {
			e.FieldStart("disable_signup")
			s.DisableSignup.Encode(e)
		}
	}
	{
		if s.JwtExp.Set {
			e.FieldStart("jwt_exp")
			s.JwtExp.Encode(e)
		}
	}
	{
		if s.SMTPAdminEmail.Set {
			e.FieldStart("smtp_admin_email")
			s.SMTPAdminEmail.Encode(e)
		}
	}
	{
		if s.SMTPHost.Set {
			e.FieldStart("smtp_host")
			s.SMTPHost.Encode(e)
		}
	}
	{
		if s.SMTPPort.Set {
			e.FieldStart("smtp_port")
			s.SMTPPort.Encode(e)
		}
	}
	{
		if s.SMTPUser.Set {
			e.FieldStart("smtp_user")
			s.SMTPUser.Encode(e)
		}
	}
	{
		if s.SMTPPass.Set {
			e.FieldStart("smtp_pass")
			s.SMTPPass.Encode(e)
		}
	}
	{
		if s.SMTPMaxFrequency.Set {
			e.FieldStart("smtp_max_frequency")
			s.SMTPMaxFrequency.Encode(e)
		}
	}
	{
		if s.SMTPSenderName.Set {
			e.FieldStart("smtp_sender_name")
			s.SMTPSenderName.Encode(e)
		}
	}
	{
		if s.MailerAllowUnverifiedEmailSignIns.Set {
			e.FieldStart("mailer_allow_unverified_email_sign_ins")
			s.MailerAllowUnverifiedEmailSignIns.Encode(e)
		}
	}
	{
		if s.MailerAutoconfirm.Set {
			e.FieldStart("mailer_autoconfirm")
			s.MailerAutoconfirm.Encode(e)
		}
	}
	{
		if s.MailerSubjectsInvite.Set {
			e.FieldStart("mailer_subjects_invite")
			s.MailerSubjectsInvite.Encode(e)
		}
	}
	{
		if s.MailerSubjectsConfirmation.Set {
			e.FieldStart("mailer_subjects_confirmation")
			s.MailerSubjectsConfirmation.Encode(e)
		}
	}
	{
		if s.MailerSubjectsRecovery.Set {
			e.FieldStart("mailer_subjects_recovery")
			s.MailerSubjectsRecovery.Encode(e)
		}
	}
	{
		if s.MailerSubjectsEmailChange.Set {
			e.FieldStart("mailer_subjects_email_change")
			s.MailerSubjectsEmailChange.Encode(e)
		}
	}
	{
		if s.MailerSubjectsMagicLink.Set {
			e.FieldStart("mailer_subjects_magic_link")
			s.MailerSubjectsMagicLink.Encode(e)
		}
	}
	{
		if s.MailerSubjectsReauthentication.Set {
			e.FieldStart("mailer_subjects_reauthentication")
			s.MailerSubjectsReauthentication.Encode(e)
		}
	}
	{
		if s.MailerTemplatesInviteContent.Set {
			e.FieldStart("mailer_templates_invite_content")
			s.MailerTemplatesInviteContent.Encode(e)
		}
	}
	{
		if s.MailerTemplatesConfirmationContent.Set {
			e.FieldStart("mailer_templates_confirmation_content")
			s.MailerTemplatesConfirmationContent.Encode(e)
		}
	}
	{
		if s.MailerTemplatesRecoveryContent.Set {
			e.FieldStart("mailer_templates_recovery_content")
			s.MailerTemplatesRecoveryContent.Encode(e)
		}
	}
	{
		if s.MailerTemplatesEmailChangeContent.Set {
			e.FieldStart("mailer_templates_email_change_content")
			s.MailerTemplatesEmailChangeContent.Encode(e)
		}
	}
	{
		if s.MailerTemplatesMagicLinkContent.Set {
			e.FieldStart("mailer_templates_magic_link_content")
			s.MailerTemplatesMagicLinkContent.Encode(e)
		}
	}
	{
		if s.MailerTemplatesReauthenticationContent.Set {
			e.FieldStart("mailer_templates_reauthentication_content")
			s.MailerTemplatesReauthenticationContent.Encode(e)
		}
	}
	{
		if s.MfaMaxEnrolledFactors.Set {
			e.FieldStart("mfa_max_enrolled_factors")
			s.MfaMaxEnrolledFactors.Encode(e)
		}
	}
	{
		if s.URIAllowList.Set {
			e.FieldStart("uri_allow_list")
			s.URIAllowList.Encode(e)
		}
	}
	{
		if s.ExternalAnonymousUsersEnabled.Set {
			e.FieldStart("external_anonymous_users_enabled")
			s.ExternalAnonymousUsersEnabled.Encode(e)
		}
	}
	{
		if s.ExternalEmailEnabled.Set {
			e.FieldStart("external_email_enabled")
			s.ExternalEmailEnabled.Encode(e)
		}
	}
	{
		if s.ExternalPhoneEnabled.Set {
			e.FieldStart("external_phone_enabled")
			s.ExternalPhoneEnabled.Encode(e)
		}
	}
	{
		if s.SamlEnabled.Set {
			e.FieldStart("saml_enabled")
			s.SamlEnabled.Encode(e)
		}
	}
	{
		if s.SecurityCaptchaEnabled.Set {
			e.FieldStart("security_captcha_enabled")
			s.SecurityCaptchaEnabled.Encode(e)
		}
	}
	{
		if s.SecurityCaptchaProvider.Set {
			e.FieldStart("security_captcha_provider")
			s.SecurityCaptchaProvider.Encode(e)
		}
	}
	{
		if s.SecurityCaptchaSecret.Set {
			e.FieldStart("security_captcha_secret")
			s.SecurityCaptchaSecret.Encode(e)
		}
	}
	{
		if s.SessionsTimebox.Set {
			e.FieldStart("sessions_timebox")
			s.SessionsTimebox.Encode(e)
		}
	}
	{
		if s.SessionsInactivityTimeout.Set {
			e.FieldStart("sessions_inactivity_timeout")
			s.SessionsInactivityTimeout.Encode(e)
		}
	}
	{
		if s.SessionsSinglePerUser.Set {
			e.FieldStart("sessions_single_per_user")
			s.SessionsSinglePerUser.Encode(e)
		}
	}
	{
		if s.SessionsTags.Set {
			e.FieldStart("sessions_tags")
			s.SessionsTags.Encode(e)
		}
	}
	{
		if s.RateLimitAnonymousUsers.Set {
			e.FieldStart("rate_limit_anonymous_users")
			s.RateLimitAnonymousUsers.Encode(e)
		}
	}
	{
		if s.RateLimitEmailSent.Set {
			e.FieldStart("rate_limit_email_sent")
			s.RateLimitEmailSent.Encode(e)
		}
	}
	{
		if s.RateLimitSMSSent.Set {
			e.FieldStart("rate_limit_sms_sent")
			s.RateLimitSMSSent.Encode(e)
		}
	}
	{
		if s.RateLimitVerify.Set {
			e.FieldStart("rate_limit_verify")
			s.RateLimitVerify.Encode(e)
		}
	}
	{
		if s.RateLimitTokenRefresh.Set {
			e.FieldStart("rate_limit_token_refresh")
			s.RateLimitTokenRefresh.Encode(e)
		}
	}
	{
		if s.MailerSecureEmailChangeEnabled.Set {
			e.FieldStart("mailer_secure_email_change_enabled")
			s.MailerSecureEmailChangeEnabled.Encode(e)
		}
	}
	{
		if s.RefreshTokenRotationEnabled.Set {
			e.FieldStart("refresh_token_rotation_enabled")
			s.RefreshTokenRotationEnabled.Encode(e)
		}
	}
	{
		if s.PasswordHibpEnabled.Set {
			e.FieldStart("password_hibp_enabled")
			s.PasswordHibpEnabled.Encode(e)
		}
	}
	{
		if s.PasswordMinLength.Set {
			e.FieldStart("password_min_length")
			s.PasswordMinLength.Encode(e)
		}
	}
	{
		if s.PasswordRequiredCharacters.Set {
			e.FieldStart("password_required_characters")
			s.PasswordRequiredCharacters.Encode(e)
		}
	}
	{
		if s.SecurityManualLinkingEnabled.Set {
			e.FieldStart("security_manual_linking_enabled")
			s.SecurityManualLinkingEnabled.Encode(e)
		}
	}
	{
		if s.SecurityUpdatePasswordRequireReauthentication.Set {
			e.FieldStart("security_update_password_require_reauthentication")
			s.SecurityUpdatePasswordRequireReauthentication.Encode(e)
		}
	}
	{
		if s.SecurityRefreshTokenReuseInterval.Set {
			e.FieldStart("security_refresh_token_reuse_interval")
			s.SecurityRefreshTokenReuseInterval.Encode(e)
		}
	}
	{
		if s.MailerOtpExp.Set {
			e.FieldStart("mailer_otp_exp")
			s.MailerOtpExp.Encode(e)
		}
	}
	{
		if s.SMSAutoconfirm.Set {
			e.FieldStart("sms_autoconfirm")
			s.SMSAutoconfirm.Encode(e)
		}
	}
	{
		if s.SMSMaxFrequency.Set {
			e.FieldStart("sms_max_frequency")
			s.SMSMaxFrequency.Encode(e)
		}
	}
	{
		if s.SMSOtpExp.Set {
			e.FieldStart("sms_otp_exp")
			s.SMSOtpExp.Encode(e)
		}
	}
	{
		if s.SMSOtpLength.Set {
			e.FieldStart("sms_otp_length")
			s.SMSOtpLength.Encode(e)
		}
	}
	{
		if s.SMSProvider.Set {
			e.FieldStart("sms_provider")
			s.SMSProvider.Encode(e)
		}
	}
	{
		if s.SMSMessagebirdAccessKey.Set {
			e.FieldStart("sms_messagebird_access_key")
			s.SMSMessagebirdAccessKey.Encode(e)
		}
	}
	{
		if s.SMSMessagebirdOriginator.Set {
			e.FieldStart("sms_messagebird_originator")
			s.SMSMessagebirdOriginator.Encode(e)
		}
	}
	{
		if s.SMSTestOtp.Set {
			e.FieldStart("sms_test_otp")
			s.SMSTestOtp.Encode(e)
		}
	}
	{
		if s.SMSTestOtpValidUntil.Set {
			e.FieldStart("sms_test_otp_valid_until")
			s.SMSTestOtpValidUntil.Encode(e)
		}
	}
	{
		if s.SMSTextlocalAPIKey.Set {
			e.FieldStart("sms_textlocal_api_key")
			s.SMSTextlocalAPIKey.Encode(e)
		}
	}
	{
		if s.SMSTextlocalSender.Set {
			e.FieldStart("sms_textlocal_sender")
			s.SMSTextlocalSender.Encode(e)
		}
	}
	{
		if s.SMSTwilioAccountSid.Set {
			e.FieldStart("sms_twilio_account_sid")
			s.SMSTwilioAccountSid.Encode(e)
		}
	}
	{
		if s.SMSTwilioAuthToken.Set {
			e.FieldStart("sms_twilio_auth_token")
			s.SMSTwilioAuthToken.Encode(e)
		}
	}
	{
		if s.SMSTwilioContentSid.Set {
			e.FieldStart("sms_twilio_content_sid")
			s.SMSTwilioContentSid.Encode(e)
		}
	}
	{
		if s.SMSTwilioMessageServiceSid.Set {
			e.FieldStart("sms_twilio_message_service_sid")
			s.SMSTwilioMessageServiceSid.Encode(e)
		}
	}
	{
		if s.SMSTwilioVerifyAccountSid.Set {
			e.FieldStart("sms_twilio_verify_account_sid")
			s.SMSTwilioVerifyAccountSid.Encode(e)
		}
	}
	{
		if s.SMSTwilioVerifyAuthToken.Set {
			e.FieldStart("sms_twilio_verify_auth_token")
			s.SMSTwilioVerifyAuthToken.Encode(e)
		}
	}
	{
		if s.SMSTwilioVerifyMessageServiceSid.Set {
			e.FieldStart("sms_twilio_verify_message_service_sid")
			s.SMSTwilioVerifyMessageServiceSid.Encode(e)
		}
	}
	{
		if s.SMSVonageAPIKey.Set {
			e.FieldStart("sms_vonage_api_key")
			s.SMSVonageAPIKey.Encode(e)
		}
	}
	{
		if s.SMSVonageAPISecret.Set {
			e.FieldStart("sms_vonage_api_secret")
			s.SMSVonageAPISecret.Encode(e)
		}
	}
	{
		if s.SMSVonageFrom.Set {
			e.FieldStart("sms_vonage_from")
			s.SMSVonageFrom.Encode(e)
		}
	}
	{
		if s.SMSTemplate.Set {
			e.FieldStart("sms_template")
			s.SMSTemplate.Encode(e)
		}
	}
	{
		if s.HookMfaVerificationAttemptEnabled.Set {
			e.FieldStart("hook_mfa_verification_attempt_enabled")
			s.HookMfaVerificationAttemptEnabled.Encode(e)
		}
	}
	{
		if s.HookMfaVerificationAttemptURI.Set {
			e.FieldStart("hook_mfa_verification_attempt_uri")
			s.HookMfaVerificationAttemptURI.Encode(e)
		}
	}
	{
		if s.HookPasswordVerificationAttemptEnabled.Set {
			e.FieldStart("hook_password_verification_attempt_enabled")
			s.HookPasswordVerificationAttemptEnabled.Encode(e)
		}
	}
	{
		if s.HookPasswordVerificationAttemptURI.Set {
			e.FieldStart("hook_password_verification_attempt_uri")
			s.HookPasswordVerificationAttemptURI.Encode(e)
		}
	}
	{
		if s.HookCustomAccessTokenEnabled.Set {
			e.FieldStart("hook_custom_access_token_enabled")
			s.HookCustomAccessTokenEnabled.Encode(e)
		}
	}
	{
		if s.HookCustomAccessTokenURI.Set {
			e.FieldStart("hook_custom_access_token_uri")
			s.HookCustomAccessTokenURI.Encode(e)
		}
	}
	{
		if s.HookSendSMSEnabled.Set {
			e.FieldStart("hook_send_sms_enabled")
			s.HookSendSMSEnabled.Encode(e)
		}
	}
	{
		if s.HookSendSMSURI.Set {
			e.FieldStart("hook_send_sms_uri")
			s.HookSendSMSURI.Encode(e)
		}
	}
	{
		if s.HookSendEmailEnabled.Set {
			e.FieldStart("hook_send_email_enabled")
			s.HookSendEmailEnabled.Encode(e)
		}
	}
	{
		if s.HookSendEmailURI.Set {
			e.FieldStart("hook_send_email_uri")
			s.HookSendEmailURI.Encode(e)
		}
	}
	{
		if s.ExternalAppleEnabled.Set {
			e.FieldStart("external_apple_enabled")
			s.ExternalAppleEnabled.Encode(e)
		}
	}
	{
		if s.ExternalAppleClientID.Set {
			e.FieldStart("external_apple_client_id")
			s.ExternalAppleClientID.Encode(e)
		}
	}
	{
		if s.ExternalAppleSecret.Set {
			e.FieldStart("external_apple_secret")
			s.ExternalAppleSecret.Encode(e)
		}
	}
	{
		if s.ExternalAppleAdditionalClientIds.Set {
			e.FieldStart("external_apple_additional_client_ids")
			s.ExternalAppleAdditionalClientIds.Encode(e)
		}
	}
	{
		if s.ExternalAzureEnabled.Set {
			e.FieldStart("external_azure_enabled")
			s.ExternalAzureEnabled.Encode(e)
		}
	}
	{
		if s.ExternalAzureClientID.Set {
			e.FieldStart("external_azure_client_id")
			s.ExternalAzureClientID.Encode(e)
		}
	}
	{
		if s.ExternalAzureSecret.Set {
			e.FieldStart("external_azure_secret")
			s.ExternalAzureSecret.Encode(e)
		}
	}
	{
		if s.ExternalAzureURL.Set {
			e.FieldStart("external_azure_url")
			s.ExternalAzureURL.Encode(e)
		}
	}
	{
		if s.ExternalBitbucketEnabled.Set {
			e.FieldStart("external_bitbucket_enabled")
			s.ExternalBitbucketEnabled.Encode(e)
		}
	}
	{
		if s.ExternalBitbucketClientID.Set {
			e.FieldStart("external_bitbucket_client_id")
			s.ExternalBitbucketClientID.Encode(e)
		}
	}
	{
		if s.ExternalBitbucketSecret.Set {
			e.FieldStart("external_bitbucket_secret")
			s.ExternalBitbucketSecret.Encode(e)
		}
	}
	{
		if s.ExternalDiscordEnabled.Set {
			e.FieldStart("external_discord_enabled")
			s.ExternalDiscordEnabled.Encode(e)
		}
	}
	{
		if s.ExternalDiscordClientID.Set {
			e.FieldStart("external_discord_client_id")
			s.ExternalDiscordClientID.Encode(e)
		}
	}
	{
		if s.ExternalDiscordSecret.Set {
			e.FieldStart("external_discord_secret")
			s.ExternalDiscordSecret.Encode(e)
		}
	}
	{
		if s.ExternalFacebookEnabled.Set {
			e.FieldStart("external_facebook_enabled")
			s.ExternalFacebookEnabled.Encode(e)
		}
	}
	{
		if s.ExternalFacebookClientID.Set {
			e.FieldStart("external_facebook_client_id")
			s.ExternalFacebookClientID.Encode(e)
		}
	}
	{
		if s.ExternalFacebookSecret.Set {
			e.FieldStart("external_facebook_secret")
			s.ExternalFacebookSecret.Encode(e)
		}
	}
	{
		if s.ExternalFigmaEnabled.Set {
			e.FieldStart("external_figma_enabled")
			s.ExternalFigmaEnabled.Encode(e)
		}
	}
	{
		if s.ExternalFigmaClientID.Set {
			e.FieldStart("external_figma_client_id")
			s.ExternalFigmaClientID.Encode(e)
		}
	}
	{
		if s.ExternalFigmaSecret.Set {
			e.FieldStart("external_figma_secret")
			s.ExternalFigmaSecret.Encode(e)
		}
	}
	{
		if s.ExternalGithubEnabled.Set {
			e.FieldStart("external_github_enabled")
			s.ExternalGithubEnabled.Encode(e)
		}
	}
	{
		if s.ExternalGithubClientID.Set {
			e.FieldStart("external_github_client_id")
			s.ExternalGithubClientID.Encode(e)
		}
	}
	{
		if s.ExternalGithubSecret.Set {
			e.FieldStart("external_github_secret")
			s.ExternalGithubSecret.Encode(e)
		}
	}
	{
		if s.ExternalGitlabEnabled.Set {
			e.FieldStart("external_gitlab_enabled")
			s.ExternalGitlabEnabled.Encode(e)
		}
	}
	{
		if s.ExternalGitlabClientID.Set {
			e.FieldStart("external_gitlab_client_id")
			s.ExternalGitlabClientID.Encode(e)
		}
	}
	{
		if s.ExternalGitlabSecret.Set {
			e.FieldStart("external_gitlab_secret")
			s.ExternalGitlabSecret.Encode(e)
		}
	}
	{
		if s.ExternalGitlabURL.Set {
			e.FieldStart("external_gitlab_url")
			s.ExternalGitlabURL.Encode(e)
		}
	}
	{
		if s.ExternalGoogleEnabled.Set {
			e.FieldStart("external_google_enabled")
			s.ExternalGoogleEnabled.Encode(e)
		}
	}
	{
		if s.ExternalGoogleClientID.Set {
			e.FieldStart("external_google_client_id")
			s.ExternalGoogleClientID.Encode(e)
		}
	}
	{
		if s.ExternalGoogleSecret.Set {
			e.FieldStart("external_google_secret")
			s.ExternalGoogleSecret.Encode(e)
		}
	}
	{
		if s.ExternalGoogleAdditionalClientIds.Set {
			e.FieldStart("external_google_additional_client_ids")
			s.ExternalGoogleAdditionalClientIds.Encode(e)
		}
	}
	{
		if s.ExternalGoogleSkipNonceCheck.Set {
			e.FieldStart("external_google_skip_nonce_check")
			s.ExternalGoogleSkipNonceCheck.Encode(e)
		}
	}
	{
		if s.ExternalKakaoEnabled.Set {
			e.FieldStart("external_kakao_enabled")
			s.ExternalKakaoEnabled.Encode(e)
		}
	}
	{
		if s.ExternalKakaoClientID.Set {
			e.FieldStart("external_kakao_client_id")
			s.ExternalKakaoClientID.Encode(e)
		}
	}
	{
		if s.ExternalKakaoSecret.Set {
			e.FieldStart("external_kakao_secret")
			s.ExternalKakaoSecret.Encode(e)
		}
	}
	{
		if s.ExternalKeycloakEnabled.Set {
			e.FieldStart("external_keycloak_enabled")
			s.ExternalKeycloakEnabled.Encode(e)
		}
	}
	{
		if s.ExternalKeycloakClientID.Set {
			e.FieldStart("external_keycloak_client_id")
			s.ExternalKeycloakClientID.Encode(e)
		}
	}
	{
		if s.ExternalKeycloakSecret.Set {
			e.FieldStart("external_keycloak_secret")
			s.ExternalKeycloakSecret.Encode(e)
		}
	}
	{
		if s.ExternalKeycloakURL.Set {
			e.FieldStart("external_keycloak_url")
			s.ExternalKeycloakURL.Encode(e)
		}
	}
	{
		if s.ExternalLinkedinOidcEnabled.Set {
			e.FieldStart("external_linkedin_oidc_enabled")
			s.ExternalLinkedinOidcEnabled.Encode(e)
		}
	}
	{
		if s.ExternalLinkedinOidcClientID.Set {
			e.FieldStart("external_linkedin_oidc_client_id")
			s.ExternalLinkedinOidcClientID.Encode(e)
		}
	}
	{
		if s.ExternalLinkedinOidcSecret.Set {
			e.FieldStart("external_linkedin_oidc_secret")
			s.ExternalLinkedinOidcSecret.Encode(e)
		}
	}
	{
		if s.ExternalNotionEnabled.Set {
			e.FieldStart("external_notion_enabled")
			s.ExternalNotionEnabled.Encode(e)
		}
	}
	{
		if s.ExternalNotionClientID.Set {
			e.FieldStart("external_notion_client_id")
			s.ExternalNotionClientID.Encode(e)
		}
	}
	{
		if s.ExternalNotionSecret.Set {
			e.FieldStart("external_notion_secret")
			s.ExternalNotionSecret.Encode(e)
		}
	}
	{
		if s.ExternalSlackEnabled.Set {
			e.FieldStart("external_slack_enabled")
			s.ExternalSlackEnabled.Encode(e)
		}
	}
	{
		if s.ExternalSlackClientID.Set {
			e.FieldStart("external_slack_client_id")
			s.ExternalSlackClientID.Encode(e)
		}
	}
	{
		if s.ExternalSlackSecret.Set {
			e.FieldStart("external_slack_secret")
			s.ExternalSlackSecret.Encode(e)
		}
	}
	{
		if s.ExternalSpotifyEnabled.Set {
			e.FieldStart("external_spotify_enabled")
			s.ExternalSpotifyEnabled.Encode(e)
		}
	}
	{
		if s.ExternalSpotifyClientID.Set {
			e.FieldStart("external_spotify_client_id")
			s.ExternalSpotifyClientID.Encode(e)
		}
	}
	{
		if s.ExternalSpotifySecret.Set {
			e.FieldStart("external_spotify_secret")
			s.ExternalSpotifySecret.Encode(e)
		}
	}
	{
		if s.ExternalTwitchEnabled.Set {
			e.FieldStart("external_twitch_enabled")
			s.ExternalTwitchEnabled.Encode(e)
		}
	}
	{
		if s.ExternalTwitchClientID.Set {
			e.FieldStart("external_twitch_client_id")
			s.ExternalTwitchClientID.Encode(e)
		}
	}
	{
		if s.ExternalTwitchSecret.Set {
			e.FieldStart("external_twitch_secret")
			s.ExternalTwitchSecret.Encode(e)
		}
	}
	{
		if s.ExternalTwitterEnabled.Set {
			e.FieldStart("external_twitter_enabled")
			s.ExternalTwitterEnabled.Encode(e)
		}
	}
	{
		if s.ExternalTwitterClientID.Set {
			e.FieldStart("external_twitter_client_id")
			s.ExternalTwitterClientID.Encode(e)
		}
	}
	{
		if s.ExternalTwitterSecret.Set {
			e.FieldStart("external_twitter_secret")
			s.ExternalTwitterSecret.Encode(e)
		}
	}
	{
		if s.ExternalWorkosEnabled.Set {
			e.FieldStart("external_workos_enabled")
			s.ExternalWorkosEnabled.Encode(e)
		}
	}
	{
		if s.ExternalWorkosClientID.Set {
			e.FieldStart("external_workos_client_id")
			s.ExternalWorkosClientID.Encode(e)
		}
	}
	{
		if s.ExternalWorkosSecret.Set {
			e.FieldStart("external_workos_secret")
			s.ExternalWorkosSecret.Encode(e)
		}
	}
	{
		if s.ExternalWorkosURL.Set {
			e.FieldStart("external_workos_url")
			s.ExternalWorkosURL.Encode(e)
		}
	}
	{
		if s.ExternalZoomEnabled.Set {
			e.FieldStart("external_zoom_enabled")
			s.ExternalZoomEnabled.Encode(e)
		}
	}
	{
		if s.ExternalZoomClientID.Set {
			e.FieldStart("external_zoom_client_id")
			s.ExternalZoomClientID.Encode(e)
		}
	}
	{
		if s.ExternalZoomSecret.Set {
			e.FieldStart("external_zoom_secret")
			s.ExternalZoomSecret.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateAuthConfigBody = [147]string{
	0:   "site_url",
	1:   "disable_signup",
	2:   "jwt_exp",
	3:   "smtp_admin_email",
	4:   "smtp_host",
	5:   "smtp_port",
	6:   "smtp_user",
	7:   "smtp_pass",
	8:   "smtp_max_frequency",
	9:   "smtp_sender_name",
	10:  "mailer_allow_unverified_email_sign_ins",
	11:  "mailer_autoconfirm",
	12:  "mailer_subjects_invite",
	13:  "mailer_subjects_confirmation",
	14:  "mailer_subjects_recovery",
	15:  "mailer_subjects_email_change",
	16:  "mailer_subjects_magic_link",
	17:  "mailer_subjects_reauthentication",
	18:  "mailer_templates_invite_content",
	19:  "mailer_templates_confirmation_content",
	20:  "mailer_templates_recovery_content",
	21:  "mailer_templates_email_change_content",
	22:  "mailer_templates_magic_link_content",
	23:  "mailer_templates_reauthentication_content",
	24:  "mfa_max_enrolled_factors",
	25:  "uri_allow_list",
	26:  "external_anonymous_users_enabled",
	27:  "external_email_enabled",
	28:  "external_phone_enabled",
	29:  "saml_enabled",
	30:  "security_captcha_enabled",
	31:  "security_captcha_provider",
	32:  "security_captcha_secret",
	33:  "sessions_timebox",
	34:  "sessions_inactivity_timeout",
	35:  "sessions_single_per_user",
	36:  "sessions_tags",
	37:  "rate_limit_anonymous_users",
	38:  "rate_limit_email_sent",
	39:  "rate_limit_sms_sent",
	40:  "rate_limit_verify",
	41:  "rate_limit_token_refresh",
	42:  "mailer_secure_email_change_enabled",
	43:  "refresh_token_rotation_enabled",
	44:  "password_hibp_enabled",
	45:  "password_min_length",
	46:  "password_required_characters",
	47:  "security_manual_linking_enabled",
	48:  "security_update_password_require_reauthentication",
	49:  "security_refresh_token_reuse_interval",
	50:  "mailer_otp_exp",
	51:  "sms_autoconfirm",
	52:  "sms_max_frequency",
	53:  "sms_otp_exp",
	54:  "sms_otp_length",
	55:  "sms_provider",
	56:  "sms_messagebird_access_key",
	57:  "sms_messagebird_originator",
	58:  "sms_test_otp",
	59:  "sms_test_otp_valid_until",
	60:  "sms_textlocal_api_key",
	61:  "sms_textlocal_sender",
	62:  "sms_twilio_account_sid",
	63:  "sms_twilio_auth_token",
	64:  "sms_twilio_content_sid",
	65:  "sms_twilio_message_service_sid",
	66:  "sms_twilio_verify_account_sid",
	67:  "sms_twilio_verify_auth_token",
	68:  "sms_twilio_verify_message_service_sid",
	69:  "sms_vonage_api_key",
	70:  "sms_vonage_api_secret",
	71:  "sms_vonage_from",
	72:  "sms_template",
	73:  "hook_mfa_verification_attempt_enabled",
	74:  "hook_mfa_verification_attempt_uri",
	75:  "hook_password_verification_attempt_enabled",
	76:  "hook_password_verification_attempt_uri",
	77:  "hook_custom_access_token_enabled",
	78:  "hook_custom_access_token_uri",
	79:  "hook_send_sms_enabled",
	80:  "hook_send_sms_uri",
	81:  "hook_send_email_enabled",
	82:  "hook_send_email_uri",
	83:  "external_apple_enabled",
	84:  "external_apple_client_id",
	85:  "external_apple_secret",
	86:  "external_apple_additional_client_ids",
	87:  "external_azure_enabled",
	88:  "external_azure_client_id",
	89:  "external_azure_secret",
	90:  "external_azure_url",
	91:  "external_bitbucket_enabled",
	92:  "external_bitbucket_client_id",
	93:  "external_bitbucket_secret",
	94:  "external_discord_enabled",
	95:  "external_discord_client_id",
	96:  "external_discord_secret",
	97:  "external_facebook_enabled",
	98:  "external_facebook_client_id",
	99:  "external_facebook_secret",
	100: "external_figma_enabled",
	101: "external_figma_client_id",
	102: "external_figma_secret",
	103: "external_github_enabled",
	104: "external_github_client_id",
	105: "external_github_secret",
	106: "external_gitlab_enabled",
	107: "external_gitlab_client_id",
	108: "external_gitlab_secret",
	109: "external_gitlab_url",
	110: "external_google_enabled",
	111: "external_google_client_id",
	112: "external_google_secret",
	113: "external_google_additional_client_ids",
	114: "external_google_skip_nonce_check",
	115: "external_kakao_enabled",
	116: "external_kakao_client_id",
	117: "external_kakao_secret",
	118: "external_keycloak_enabled",
	119: "external_keycloak_client_id",
	120: "external_keycloak_secret",
	121: "external_keycloak_url",
	122: "external_linkedin_oidc_enabled",
	123: "external_linkedin_oidc_client_id",
	124: "external_linkedin_oidc_secret",
	125: "external_notion_enabled",
	126: "external_notion_client_id",
	127: "external_notion_secret",
	128: "external_slack_enabled",
	129: "external_slack_client_id",
	130: "external_slack_secret",
	131: "external_spotify_enabled",
	132: "external_spotify_client_id",
	133: "external_spotify_secret",
	134: "external_twitch_enabled",
	135: "external_twitch_client_id",
	136: "external_twitch_secret",
	137: "external_twitter_enabled",
	138: "external_twitter_client_id",
	139: "external_twitter_secret",
	140: "external_workos_enabled",
	141: "external_workos_client_id",
	142: "external_workos_secret",
	143: "external_workos_url",
	144: "external_zoom_enabled",
	145: "external_zoom_client_id",
	146: "external_zoom_secret",
}

// Decode decodes UpdateAuthConfigBody from json.
func (s *UpdateAuthConfigBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateAuthConfigBody to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "site_url":
			if err := func() error {
				s.SiteURL.Reset()
				if err := s.SiteURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"site_url\"")
			}
		case "disable_signup":
			if err := func() error {
				s.DisableSignup.Reset()
				if err := s.DisableSignup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_signup\"")
			}
		case "jwt_exp":
			if err := func() error {
				s.JwtExp.Reset()
				if err := s.JwtExp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jwt_exp\"")
			}
		case "smtp_admin_email":
			if err := func() error {
				s.SMTPAdminEmail.Reset()
				if err := s.SMTPAdminEmail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"smtp_admin_email\"")
			}
		case "smtp_host":
			if err := func() error {
				s.SMTPHost.Reset()
				if err := s.SMTPHost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"smtp_host\"")
			}
		case "smtp_port":
			if err := func() error {
				s.SMTPPort.Reset()
				if err := s.SMTPPort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"smtp_port\"")
			}
		case "smtp_user":
			if err := func() error {
				s.SMTPUser.Reset()
				if err := s.SMTPUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"smtp_user\"")
			}
		case "smtp_pass":
			if err := func() error {
				s.SMTPPass.Reset()
				if err := s.SMTPPass.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"smtp_pass\"")
			}
		case "smtp_max_frequency":
			if err := func() error {
				s.SMTPMaxFrequency.Reset()
				if err := s.SMTPMaxFrequency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"smtp_max_frequency\"")
			}
		case "smtp_sender_name":
			if err := func() error {
				s.SMTPSenderName.Reset()
				if err := s.SMTPSenderName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"smtp_sender_name\"")
			}
		case "mailer_allow_unverified_email_sign_ins":
			if err := func() error {
				s.MailerAllowUnverifiedEmailSignIns.Reset()
				if err := s.MailerAllowUnverifiedEmailSignIns.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mailer_allow_unverified_email_sign_ins\"")
			}
		case "mailer_autoconfirm":
			if err := func() error {
				s.MailerAutoconfirm.Reset()
				if err := s.MailerAutoconfirm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mailer_autoconfirm\"")
			}
		case "mailer_subjects_invite":
			if err := func() error {
				s.MailerSubjectsInvite.Reset()
				if err := s.MailerSubjectsInvite.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mailer_subjects_invite\"")
			}
		case "mailer_subjects_confirmation":
			if err := func() error {
				s.MailerSubjectsConfirmation.Reset()
				if err := s.MailerSubjectsConfirmation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mailer_subjects_confirmation\"")
			}
		case "mailer_subjects_recovery":
			if err := func() error {
				s.MailerSubjectsRecovery.Reset()
				if err := s.MailerSubjectsRecovery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mailer_subjects_recovery\"")
			}
		case "mailer_subjects_email_change":
			if err := func() error {
				s.MailerSubjectsEmailChange.Reset()
				if err := s.MailerSubjectsEmailChange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mailer_subjects_email_change\"")
			}
		case "mailer_subjects_magic_link":
			if err := func() error {
				s.MailerSubjectsMagicLink.Reset()
				if err := s.MailerSubjectsMagicLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mailer_subjects_magic_link\"")
			}
		case "mailer_subjects_reauthentication":
			if err := func() error {
				s.MailerSubjectsReauthentication.Reset()
				if err := s.MailerSubjectsReauthentication.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mailer_subjects_reauthentication\"")
			}
		case "mailer_templates_invite_content":
			if err := func() error {
				s.MailerTemplatesInviteContent.Reset()
				if err := s.MailerTemplatesInviteContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mailer_templates_invite_content\"")
			}
		case "mailer_templates_confirmation_content":
			if err := func() error {
				s.MailerTemplatesConfirmationContent.Reset()
				if err := s.MailerTemplatesConfirmationContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mailer_templates_confirmation_content\"")
			}
		case "mailer_templates_recovery_content":
			if err := func() error {
				s.MailerTemplatesRecoveryContent.Reset()
				if err := s.MailerTemplatesRecoveryContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mailer_templates_recovery_content\"")
			}
		case "mailer_templates_email_change_content":
			if err := func() error {
				s.MailerTemplatesEmailChangeContent.Reset()
				if err := s.MailerTemplatesEmailChangeContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mailer_templates_email_change_content\"")
			}
		case "mailer_templates_magic_link_content":
			if err := func() error {
				s.MailerTemplatesMagicLinkContent.Reset()
				if err := s.MailerTemplatesMagicLinkContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mailer_templates_magic_link_content\"")
			}
		case "mailer_templates_reauthentication_content":
			if err := func() error {
				s.MailerTemplatesReauthenticationContent.Reset()
				if err := s.MailerTemplatesReauthenticationContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mailer_templates_reauthentication_content\"")
			}
		case "mfa_max_enrolled_factors":
			if err := func() error {
				s.MfaMaxEnrolledFactors.Reset()
				if err := s.MfaMaxEnrolledFactors.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mfa_max_enrolled_factors\"")
			}
		case "uri_allow_list":
			if err := func() error {
				s.URIAllowList.Reset()
				if err := s.URIAllowList.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri_allow_list\"")
			}
		case "external_anonymous_users_enabled":
			if err := func() error {
				s.ExternalAnonymousUsersEnabled.Reset()
				if err := s.ExternalAnonymousUsersEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_anonymous_users_enabled\"")
			}
		case "external_email_enabled":
			if err := func() error {
				s.ExternalEmailEnabled.Reset()
				if err := s.ExternalEmailEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_email_enabled\"")
			}
		case "external_phone_enabled":
			if err := func() error {
				s.ExternalPhoneEnabled.Reset()
				if err := s.ExternalPhoneEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_phone_enabled\"")
			}
		case "saml_enabled":
			if err := func() error {
				s.SamlEnabled.Reset()
				if err := s.SamlEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"saml_enabled\"")
			}
		case "security_captcha_enabled":
			if err := func() error {
				s.SecurityCaptchaEnabled.Reset()
				if err := s.SecurityCaptchaEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security_captcha_enabled\"")
			}
		case "security_captcha_provider":
			if err := func() error {
				s.SecurityCaptchaProvider.Reset()
				if err := s.SecurityCaptchaProvider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security_captcha_provider\"")
			}
		case "security_captcha_secret":
			if err := func() error {
				s.SecurityCaptchaSecret.Reset()
				if err := s.SecurityCaptchaSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security_captcha_secret\"")
			}
		case "sessions_timebox":
			if err := func() error {
				s.SessionsTimebox.Reset()
				if err := s.SessionsTimebox.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sessions_timebox\"")
			}
		case "sessions_inactivity_timeout":
			if err := func() error {
				s.SessionsInactivityTimeout.Reset()
				if err := s.SessionsInactivityTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sessions_inactivity_timeout\"")
			}
		case "sessions_single_per_user":
			if err := func() error {
				s.SessionsSinglePerUser.Reset()
				if err := s.SessionsSinglePerUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sessions_single_per_user\"")
			}
		case "sessions_tags":
			if err := func() error {
				s.SessionsTags.Reset()
				if err := s.SessionsTags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sessions_tags\"")
			}
		case "rate_limit_anonymous_users":
			if err := func() error {
				s.RateLimitAnonymousUsers.Reset()
				if err := s.RateLimitAnonymousUsers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rate_limit_anonymous_users\"")
			}
		case "rate_limit_email_sent":
			if err := func() error {
				s.RateLimitEmailSent.Reset()
				if err := s.RateLimitEmailSent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rate_limit_email_sent\"")
			}
		case "rate_limit_sms_sent":
			if err := func() error {
				s.RateLimitSMSSent.Reset()
				if err := s.RateLimitSMSSent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rate_limit_sms_sent\"")
			}
		case "rate_limit_verify":
			if err := func() error {
				s.RateLimitVerify.Reset()
				if err := s.RateLimitVerify.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rate_limit_verify\"")
			}
		case "rate_limit_token_refresh":
			if err := func() error {
				s.RateLimitTokenRefresh.Reset()
				if err := s.RateLimitTokenRefresh.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rate_limit_token_refresh\"")
			}
		case "mailer_secure_email_change_enabled":
			if err := func() error {
				s.MailerSecureEmailChangeEnabled.Reset()
				if err := s.MailerSecureEmailChangeEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mailer_secure_email_change_enabled\"")
			}
		case "refresh_token_rotation_enabled":
			if err := func() error {
				s.RefreshTokenRotationEnabled.Reset()
				if err := s.RefreshTokenRotationEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"refresh_token_rotation_enabled\"")
			}
		case "password_hibp_enabled":
			if err := func() error {
				s.PasswordHibpEnabled.Reset()
				if err := s.PasswordHibpEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password_hibp_enabled\"")
			}
		case "password_min_length":
			if err := func() error {
				s.PasswordMinLength.Reset()
				if err := s.PasswordMinLength.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password_min_length\"")
			}
		case "password_required_characters":
			if err := func() error {
				s.PasswordRequiredCharacters.Reset()
				if err := s.PasswordRequiredCharacters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password_required_characters\"")
			}
		case "security_manual_linking_enabled":
			if err := func() error {
				s.SecurityManualLinkingEnabled.Reset()
				if err := s.SecurityManualLinkingEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security_manual_linking_enabled\"")
			}
		case "security_update_password_require_reauthentication":
			if err := func() error {
				s.SecurityUpdatePasswordRequireReauthentication.Reset()
				if err := s.SecurityUpdatePasswordRequireReauthentication.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security_update_password_require_reauthentication\"")
			}
		case "security_refresh_token_reuse_interval":
			if err := func() error {
				s.SecurityRefreshTokenReuseInterval.Reset()
				if err := s.SecurityRefreshTokenReuseInterval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security_refresh_token_reuse_interval\"")
			}
		case "mailer_otp_exp":
			if err := func() error {
				s.MailerOtpExp.Reset()
				if err := s.MailerOtpExp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mailer_otp_exp\"")
			}
		case "sms_autoconfirm":
			if err := func() error {
				s.SMSAutoconfirm.Reset()
				if err := s.SMSAutoconfirm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_autoconfirm\"")
			}
		case "sms_max_frequency":
			if err := func() error {
				s.SMSMaxFrequency.Reset()
				if err := s.SMSMaxFrequency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_max_frequency\"")
			}
		case "sms_otp_exp":
			if err := func() error {
				s.SMSOtpExp.Reset()
				if err := s.SMSOtpExp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_otp_exp\"")
			}
		case "sms_otp_length":
			if err := func() error {
				s.SMSOtpLength.Reset()
				if err := s.SMSOtpLength.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_otp_length\"")
			}
		case "sms_provider":
			if err := func() error {
				s.SMSProvider.Reset()
				if err := s.SMSProvider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_provider\"")
			}
		case "sms_messagebird_access_key":
			if err := func() error {
				s.SMSMessagebirdAccessKey.Reset()
				if err := s.SMSMessagebirdAccessKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_messagebird_access_key\"")
			}
		case "sms_messagebird_originator":
			if err := func() error {
				s.SMSMessagebirdOriginator.Reset()
				if err := s.SMSMessagebirdOriginator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_messagebird_originator\"")
			}
		case "sms_test_otp":
			if err := func() error {
				s.SMSTestOtp.Reset()
				if err := s.SMSTestOtp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_test_otp\"")
			}
		case "sms_test_otp_valid_until":
			if err := func() error {
				s.SMSTestOtpValidUntil.Reset()
				if err := s.SMSTestOtpValidUntil.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_test_otp_valid_until\"")
			}
		case "sms_textlocal_api_key":
			if err := func() error {
				s.SMSTextlocalAPIKey.Reset()
				if err := s.SMSTextlocalAPIKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_textlocal_api_key\"")
			}
		case "sms_textlocal_sender":
			if err := func() error {
				s.SMSTextlocalSender.Reset()
				if err := s.SMSTextlocalSender.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_textlocal_sender\"")
			}
		case "sms_twilio_account_sid":
			if err := func() error {
				s.SMSTwilioAccountSid.Reset()
				if err := s.SMSTwilioAccountSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_twilio_account_sid\"")
			}
		case "sms_twilio_auth_token":
			if err := func() error {
				s.SMSTwilioAuthToken.Reset()
				if err := s.SMSTwilioAuthToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_twilio_auth_token\"")
			}
		case "sms_twilio_content_sid":
			if err := func() error {
				s.SMSTwilioContentSid.Reset()
				if err := s.SMSTwilioContentSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_twilio_content_sid\"")
			}
		case "sms_twilio_message_service_sid":
			if err := func() error {
				s.SMSTwilioMessageServiceSid.Reset()
				if err := s.SMSTwilioMessageServiceSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_twilio_message_service_sid\"")
			}
		case "sms_twilio_verify_account_sid":
			if err := func() error {
				s.SMSTwilioVerifyAccountSid.Reset()
				if err := s.SMSTwilioVerifyAccountSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_twilio_verify_account_sid\"")
			}
		case "sms_twilio_verify_auth_token":
			if err := func() error {
				s.SMSTwilioVerifyAuthToken.Reset()
				if err := s.SMSTwilioVerifyAuthToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_twilio_verify_auth_token\"")
			}
		case "sms_twilio_verify_message_service_sid":
			if err := func() error {
				s.SMSTwilioVerifyMessageServiceSid.Reset()
				if err := s.SMSTwilioVerifyMessageServiceSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_twilio_verify_message_service_sid\"")
			}
		case "sms_vonage_api_key":
			if err := func() error {
				s.SMSVonageAPIKey.Reset()
				if err := s.SMSVonageAPIKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_vonage_api_key\"")
			}
		case "sms_vonage_api_secret":
			if err := func() error {
				s.SMSVonageAPISecret.Reset()
				if err := s.SMSVonageAPISecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_vonage_api_secret\"")
			}
		case "sms_vonage_from":
			if err := func() error {
				s.SMSVonageFrom.Reset()
				if err := s.SMSVonageFrom.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_vonage_from\"")
			}
		case "sms_template":
			if err := func() error {
				s.SMSTemplate.Reset()
				if err := s.SMSTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sms_template\"")
			}
		case "hook_mfa_verification_attempt_enabled":
			if err := func() error {
				s.HookMfaVerificationAttemptEnabled.Reset()
				if err := s.HookMfaVerificationAttemptEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hook_mfa_verification_attempt_enabled\"")
			}
		case "hook_mfa_verification_attempt_uri":
			if err := func() error {
				s.HookMfaVerificationAttemptURI.Reset()
				if err := s.HookMfaVerificationAttemptURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hook_mfa_verification_attempt_uri\"")
			}
		case "hook_password_verification_attempt_enabled":
			if err := func() error {
				s.HookPasswordVerificationAttemptEnabled.Reset()
				if err := s.HookPasswordVerificationAttemptEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hook_password_verification_attempt_enabled\"")
			}
		case "hook_password_verification_attempt_uri":
			if err := func() error {
				s.HookPasswordVerificationAttemptURI.Reset()
				if err := s.HookPasswordVerificationAttemptURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hook_password_verification_attempt_uri\"")
			}
		case "hook_custom_access_token_enabled":
			if err := func() error {
				s.HookCustomAccessTokenEnabled.Reset()
				if err := s.HookCustomAccessTokenEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hook_custom_access_token_enabled\"")
			}
		case "hook_custom_access_token_uri":
			if err := func() error {
				s.HookCustomAccessTokenURI.Reset()
				if err := s.HookCustomAccessTokenURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hook_custom_access_token_uri\"")
			}
		case "hook_send_sms_enabled":
			if err := func() error {
				s.HookSendSMSEnabled.Reset()
				if err := s.HookSendSMSEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hook_send_sms_enabled\"")
			}
		case "hook_send_sms_uri":
			if err := func() error {
				s.HookSendSMSURI.Reset()
				if err := s.HookSendSMSURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hook_send_sms_uri\"")
			}
		case "hook_send_email_enabled":
			if err := func() error {
				s.HookSendEmailEnabled.Reset()
				if err := s.HookSendEmailEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hook_send_email_enabled\"")
			}
		case "hook_send_email_uri":
			if err := func() error {
				s.HookSendEmailURI.Reset()
				if err := s.HookSendEmailURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hook_send_email_uri\"")
			}
		case "external_apple_enabled":
			if err := func() error {
				s.ExternalAppleEnabled.Reset()
				if err := s.ExternalAppleEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_apple_enabled\"")
			}
		case "external_apple_client_id":
			if err := func() error {
				s.ExternalAppleClientID.Reset()
				if err := s.ExternalAppleClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_apple_client_id\"")
			}
		case "external_apple_secret":
			if err := func() error {
				s.ExternalAppleSecret.Reset()
				if err := s.ExternalAppleSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_apple_secret\"")
			}
		case "external_apple_additional_client_ids":
			if err := func() error {
				s.ExternalAppleAdditionalClientIds.Reset()
				if err := s.ExternalAppleAdditionalClientIds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_apple_additional_client_ids\"")
			}
		case "external_azure_enabled":
			if err := func() error {
				s.ExternalAzureEnabled.Reset()
				if err := s.ExternalAzureEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_azure_enabled\"")
			}
		case "external_azure_client_id":
			if err := func() error {
				s.ExternalAzureClientID.Reset()
				if err := s.ExternalAzureClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_azure_client_id\"")
			}
		case "external_azure_secret":
			if err := func() error {
				s.ExternalAzureSecret.Reset()
				if err := s.ExternalAzureSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_azure_secret\"")
			}
		case "external_azure_url":
			if err := func() error {
				s.ExternalAzureURL.Reset()
				if err := s.ExternalAzureURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_azure_url\"")
			}
		case "external_bitbucket_enabled":
			if err := func() error {
				s.ExternalBitbucketEnabled.Reset()
				if err := s.ExternalBitbucketEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_bitbucket_enabled\"")
			}
		case "external_bitbucket_client_id":
			if err := func() error {
				s.ExternalBitbucketClientID.Reset()
				if err := s.ExternalBitbucketClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_bitbucket_client_id\"")
			}
		case "external_bitbucket_secret":
			if err := func() error {
				s.ExternalBitbucketSecret.Reset()
				if err := s.ExternalBitbucketSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_bitbucket_secret\"")
			}
		case "external_discord_enabled":
			if err := func() error {
				s.ExternalDiscordEnabled.Reset()
				if err := s.ExternalDiscordEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_discord_enabled\"")
			}
		case "external_discord_client_id":
			if err := func() error {
				s.ExternalDiscordClientID.Reset()
				if err := s.ExternalDiscordClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_discord_client_id\"")
			}
		case "external_discord_secret":
			if err := func() error {
				s.ExternalDiscordSecret.Reset()
				if err := s.ExternalDiscordSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_discord_secret\"")
			}
		case "external_facebook_enabled":
			if err := func() error {
				s.ExternalFacebookEnabled.Reset()
				if err := s.ExternalFacebookEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_facebook_enabled\"")
			}
		case "external_facebook_client_id":
			if err := func() error {
				s.ExternalFacebookClientID.Reset()
				if err := s.ExternalFacebookClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_facebook_client_id\"")
			}
		case "external_facebook_secret":
			if err := func() error {
				s.ExternalFacebookSecret.Reset()
				if err := s.ExternalFacebookSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_facebook_secret\"")
			}
		case "external_figma_enabled":
			if err := func() error {
				s.ExternalFigmaEnabled.Reset()
				if err := s.ExternalFigmaEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_figma_enabled\"")
			}
		case "external_figma_client_id":
			if err := func() error {
				s.ExternalFigmaClientID.Reset()
				if err := s.ExternalFigmaClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_figma_client_id\"")
			}
		case "external_figma_secret":
			if err := func() error {
				s.ExternalFigmaSecret.Reset()
				if err := s.ExternalFigmaSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_figma_secret\"")
			}
		case "external_github_enabled":
			if err := func() error {
				s.ExternalGithubEnabled.Reset()
				if err := s.ExternalGithubEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_github_enabled\"")
			}
		case "external_github_client_id":
			if err := func() error {
				s.ExternalGithubClientID.Reset()
				if err := s.ExternalGithubClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_github_client_id\"")
			}
		case "external_github_secret":
			if err := func() error {
				s.ExternalGithubSecret.Reset()
				if err := s.ExternalGithubSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_github_secret\"")
			}
		case "external_gitlab_enabled":
			if err := func() error {
				s.ExternalGitlabEnabled.Reset()
				if err := s.ExternalGitlabEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_gitlab_enabled\"")
			}
		case "external_gitlab_client_id":
			if err := func() error {
				s.ExternalGitlabClientID.Reset()
				if err := s.ExternalGitlabClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_gitlab_client_id\"")
			}
		case "external_gitlab_secret":
			if err := func() error {
				s.ExternalGitlabSecret.Reset()
				if err := s.ExternalGitlabSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_gitlab_secret\"")
			}
		case "external_gitlab_url":
			if err := func() error {
				s.ExternalGitlabURL.Reset()
				if err := s.ExternalGitlabURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_gitlab_url\"")
			}
		case "external_google_enabled":
			if err := func() error {
				s.ExternalGoogleEnabled.Reset()
				if err := s.ExternalGoogleEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_google_enabled\"")
			}
		case "external_google_client_id":
			if err := func() error {
				s.ExternalGoogleClientID.Reset()
				if err := s.ExternalGoogleClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_google_client_id\"")
			}
		case "external_google_secret":
			if err := func() error {
				s.ExternalGoogleSecret.Reset()
				if err := s.ExternalGoogleSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_google_secret\"")
			}
		case "external_google_additional_client_ids":
			if err := func() error {
				s.ExternalGoogleAdditionalClientIds.Reset()
				if err := s.ExternalGoogleAdditionalClientIds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_google_additional_client_ids\"")
			}
		case "external_google_skip_nonce_check":
			if err := func() error {
				s.ExternalGoogleSkipNonceCheck.Reset()
				if err := s.ExternalGoogleSkipNonceCheck.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_google_skip_nonce_check\"")
			}
		case "external_kakao_enabled":
			if err := func() error {
				s.ExternalKakaoEnabled.Reset()
				if err := s.ExternalKakaoEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_kakao_enabled\"")
			}
		case "external_kakao_client_id":
			if err := func() error {
				s.ExternalKakaoClientID.Reset()
				if err := s.ExternalKakaoClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_kakao_client_id\"")
			}
		case "external_kakao_secret":
			if err := func() error {
				s.ExternalKakaoSecret.Reset()
				if err := s.ExternalKakaoSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_kakao_secret\"")
			}
		case "external_keycloak_enabled":
			if err := func() error {
				s.ExternalKeycloakEnabled.Reset()
				if err := s.ExternalKeycloakEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_keycloak_enabled\"")
			}
		case "external_keycloak_client_id":
			if err := func() error {
				s.ExternalKeycloakClientID.Reset()
				if err := s.ExternalKeycloakClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_keycloak_client_id\"")
			}
		case "external_keycloak_secret":
			if err := func() error {
				s.ExternalKeycloakSecret.Reset()
				if err := s.ExternalKeycloakSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_keycloak_secret\"")
			}
		case "external_keycloak_url":
			if err := func() error {
				s.ExternalKeycloakURL.Reset()
				if err := s.ExternalKeycloakURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_keycloak_url\"")
			}
		case "external_linkedin_oidc_enabled":
			if err := func() error {
				s.ExternalLinkedinOidcEnabled.Reset()
				if err := s.ExternalLinkedinOidcEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_linkedin_oidc_enabled\"")
			}
		case "external_linkedin_oidc_client_id":
			if err := func() error {
				s.ExternalLinkedinOidcClientID.Reset()
				if err := s.ExternalLinkedinOidcClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_linkedin_oidc_client_id\"")
			}
		case "external_linkedin_oidc_secret":
			if err := func() error {
				s.ExternalLinkedinOidcSecret.Reset()
				if err := s.ExternalLinkedinOidcSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_linkedin_oidc_secret\"")
			}
		case "external_notion_enabled":
			if err := func() error {
				s.ExternalNotionEnabled.Reset()
				if err := s.ExternalNotionEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_notion_enabled\"")
			}
		case "external_notion_client_id":
			if err := func() error {
				s.ExternalNotionClientID.Reset()
				if err := s.ExternalNotionClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_notion_client_id\"")
			}
		case "external_notion_secret":
			if err := func() error {
				s.ExternalNotionSecret.Reset()
				if err := s.ExternalNotionSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_notion_secret\"")
			}
		case "external_slack_enabled":
			if err := func() error {
				s.ExternalSlackEnabled.Reset()
				if err := s.ExternalSlackEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_slack_enabled\"")
			}
		case "external_slack_client_id":
			if err := func() error {
				s.ExternalSlackClientID.Reset()
				if err := s.ExternalSlackClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_slack_client_id\"")
			}
		case "external_slack_secret":
			if err := func() error {
				s.ExternalSlackSecret.Reset()
				if err := s.ExternalSlackSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_slack_secret\"")
			}
		case "external_spotify_enabled":
			if err := func() error {
				s.ExternalSpotifyEnabled.Reset()
				if err := s.ExternalSpotifyEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_spotify_enabled\"")
			}
		case "external_spotify_client_id":
			if err := func() error {
				s.ExternalSpotifyClientID.Reset()
				if err := s.ExternalSpotifyClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_spotify_client_id\"")
			}
		case "external_spotify_secret":
			if err := func() error {
				s.ExternalSpotifySecret.Reset()
				if err := s.ExternalSpotifySecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_spotify_secret\"")
			}
		case "external_twitch_enabled":
			if err := func() error {
				s.ExternalTwitchEnabled.Reset()
				if err := s.ExternalTwitchEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_twitch_enabled\"")
			}
		case "external_twitch_client_id":
			if err := func() error {
				s.ExternalTwitchClientID.Reset()
				if err := s.ExternalTwitchClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_twitch_client_id\"")
			}
		case "external_twitch_secret":
			if err := func() error {
				s.ExternalTwitchSecret.Reset()
				if err := s.ExternalTwitchSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_twitch_secret\"")
			}
		case "external_twitter_enabled":
			if err := func() error {
				s.ExternalTwitterEnabled.Reset()
				if err := s.ExternalTwitterEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_twitter_enabled\"")
			}
		case "external_twitter_client_id":
			if err := func() error {
				s.ExternalTwitterClientID.Reset()
				if err := s.ExternalTwitterClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_twitter_client_id\"")
			}
		case "external_twitter_secret":
			if err := func() error {
				s.ExternalTwitterSecret.Reset()
				if err := s.ExternalTwitterSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_twitter_secret\"")
			}
		case "external_workos_enabled":
			if err := func() error {
				s.ExternalWorkosEnabled.Reset()
				if err := s.ExternalWorkosEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_workos_enabled\"")
			}
		case "external_workos_client_id":
			if err := func() error {
				s.ExternalWorkosClientID.Reset()
				if err := s.ExternalWorkosClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_workos_client_id\"")
			}
		case "external_workos_secret":
			if err := func() error {
				s.ExternalWorkosSecret.Reset()
				if err := s.ExternalWorkosSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_workos_secret\"")
			}
		case "external_workos_url":
			if err := func() error {
				s.ExternalWorkosURL.Reset()
				if err := s.ExternalWorkosURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_workos_url\"")
			}
		case "external_zoom_enabled":
			if err := func() error {
				s.ExternalZoomEnabled.Reset()
				if err := s.ExternalZoomEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_zoom_enabled\"")
			}
		case "external_zoom_client_id":
			if err := func() error {
				s.ExternalZoomClientID.Reset()
				if err := s.ExternalZoomClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_zoom_client_id\"")
			}
		case "external_zoom_secret":
			if err := func() error {
				s.ExternalZoomSecret.Reset()
				if err := s.ExternalZoomSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_zoom_secret\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateAuthConfigBody")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateAuthConfigBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateAuthConfigBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateAuthConfigBodyPasswordRequiredCharacters as json.
func (s UpdateAuthConfigBodyPasswordRequiredCharacters) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateAuthConfigBodyPasswordRequiredCharacters from json.
func (s *UpdateAuthConfigBodyPasswordRequiredCharacters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateAuthConfigBodyPasswordRequiredCharacters to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateAuthConfigBodyPasswordRequiredCharacters(v) {
	case UpdateAuthConfigBodyPasswordRequiredCharacters_0:
		*s = UpdateAuthConfigBodyPasswordRequiredCharacters_0
	case UpdateAuthConfigBodyPasswordRequiredCharacters_1:
		*s = UpdateAuthConfigBodyPasswordRequiredCharacters_1
	case UpdateAuthConfigBodyPasswordRequiredCharacters_2:
		*s = UpdateAuthConfigBodyPasswordRequiredCharacters_2
	case UpdateAuthConfigBodyPasswordRequiredCharacters_3:
		*s = UpdateAuthConfigBodyPasswordRequiredCharacters_3
	default:
		*s = UpdateAuthConfigBodyPasswordRequiredCharacters(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateAuthConfigBodyPasswordRequiredCharacters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateAuthConfigBodyPasswordRequiredCharacters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateBranchBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateBranchBody) encodeFields(e *jx.Encoder) {
	{
		if s.BranchName.Set {
			e.FieldStart("branch_name")
			s.BranchName.Encode(e)
		}
	}
	{
		if s.GitBranch.Set {
			e.FieldStart("git_branch")
			s.GitBranch.Encode(e)
		}
	}
	{
		if s.ResetOnPush.Set {
			e.FieldStart("reset_on_push")
			s.ResetOnPush.Encode(e)
		}
	}
	{
		if s.Persistent.Set {
			e.FieldStart("persistent")
			s.Persistent.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateBranchBody = [4]string{
	0: "branch_name",
	1: "git_branch",
	2: "reset_on_push",
	3: "persistent",
}

// Decode decodes UpdateBranchBody from json.
func (s *UpdateBranchBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateBranchBody to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "branch_name":
			if err := func() error {
				s.BranchName.Reset()
				if err := s.BranchName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branch_name\"")
			}
		case "git_branch":
			if err := func() error {
				s.GitBranch.Reset()
				if err := s.GitBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_branch\"")
			}
		case "reset_on_push":
			if err := func() error {
				s.ResetOnPush.Reset()
				if err := s.ResetOnPush.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reset_on_push\"")
			}
		case "persistent":
			if err := func() error {
				s.Persistent.Reset()
				if err := s.Persistent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"persistent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateBranchBody")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateBranchBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateBranchBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateCustomHostnameBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateCustomHostnameBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("custom_hostname")
		e.Str(s.CustomHostname)
	}
}

var jsonFieldsNameOfUpdateCustomHostnameBody = [1]string{
	0: "custom_hostname",
}

// Decode decodes UpdateCustomHostnameBody from json.
func (s *UpdateCustomHostnameBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCustomHostnameBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "custom_hostname":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CustomHostname = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_hostname\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateCustomHostnameBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateCustomHostnameBody) {
					name = jsonFieldsNameOfUpdateCustomHostnameBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCustomHostnameBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCustomHostnameBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateCustomHostnameResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateCustomHostnameResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("custom_hostname")
		e.Str(s.CustomHostname)
	}
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfUpdateCustomHostnameResponse = [3]string{
	0: "status",
	1: "custom_hostname",
	2: "data",
}

// Decode decodes UpdateCustomHostnameResponse from json.
func (s *UpdateCustomHostnameResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCustomHostnameResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "custom_hostname":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CustomHostname = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_hostname\"")
			}
		case "data":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateCustomHostnameResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateCustomHostnameResponse) {
					name = jsonFieldsNameOfUpdateCustomHostnameResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCustomHostnameResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCustomHostnameResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateCustomHostnameResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateCustomHostnameResponseData) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateCustomHostnameResponseData = [0]string{}

// Decode decodes UpdateCustomHostnameResponseData from json.
func (s *UpdateCustomHostnameResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCustomHostnameResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateCustomHostnameResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCustomHostnameResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCustomHostnameResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCustomHostnameResponseStatus as json.
func (s UpdateCustomHostnameResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateCustomHostnameResponseStatus from json.
func (s *UpdateCustomHostnameResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCustomHostnameResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateCustomHostnameResponseStatus(v) {
	case UpdateCustomHostnameResponseStatus1NotStarted:
		*s = UpdateCustomHostnameResponseStatus1NotStarted
	case UpdateCustomHostnameResponseStatus2Initiated:
		*s = UpdateCustomHostnameResponseStatus2Initiated
	case UpdateCustomHostnameResponseStatus3ChallengeVerified:
		*s = UpdateCustomHostnameResponseStatus3ChallengeVerified
	case UpdateCustomHostnameResponseStatus4OriginSetupCompleted:
		*s = UpdateCustomHostnameResponseStatus4OriginSetupCompleted
	case UpdateCustomHostnameResponseStatus5ServicesReconfigured:
		*s = UpdateCustomHostnameResponseStatus5ServicesReconfigured
	default:
		*s = UpdateCustomHostnameResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateCustomHostnameResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCustomHostnameResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdatePgsodiumConfigBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdatePgsodiumConfigBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("root_key")
		e.Str(s.RootKey)
	}
}

var jsonFieldsNameOfUpdatePgsodiumConfigBody = [1]string{
	0: "root_key",
}

// Decode decodes UpdatePgsodiumConfigBody from json.
func (s *UpdatePgsodiumConfigBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdatePgsodiumConfigBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "root_key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.RootKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"root_key\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdatePgsodiumConfigBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdatePgsodiumConfigBody) {
					name = jsonFieldsNameOfUpdatePgsodiumConfigBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdatePgsodiumConfigBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdatePgsodiumConfigBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdatePostgresConfigBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdatePostgresConfigBody) encodeFields(e *jx.Encoder) {
	{
		if s.StatementTimeout.Set {
			e.FieldStart("statement_timeout")
			s.StatementTimeout.Encode(e)
		}
	}
	{
		if s.EffectiveCacheSize.Set {
			e.FieldStart("effective_cache_size")
			s.EffectiveCacheSize.Encode(e)
		}
	}
	{
		if s.MaintenanceWorkMem.Set {
			e.FieldStart("maintenance_work_mem")
			s.MaintenanceWorkMem.Encode(e)
		}
	}
	{
		if s.MaxConnections.Set {
			e.FieldStart("max_connections")
			s.MaxConnections.Encode(e)
		}
	}
	{
		if s.MaxLocksPerTransaction.Set {
			e.FieldStart("max_locks_per_transaction")
			s.MaxLocksPerTransaction.Encode(e)
		}
	}
	{
		if s.MaxParallelMaintenanceWorkers.Set {
			e.FieldStart("max_parallel_maintenance_workers")
			s.MaxParallelMaintenanceWorkers.Encode(e)
		}
	}
	{
		if s.MaxParallelWorkers.Set {
			e.FieldStart("max_parallel_workers")
			s.MaxParallelWorkers.Encode(e)
		}
	}
	{
		if s.MaxParallelWorkersPerGather.Set {
			e.FieldStart("max_parallel_workers_per_gather")
			s.MaxParallelWorkersPerGather.Encode(e)
		}
	}
	{
		if s.MaxStandbyArchiveDelay.Set {
			e.FieldStart("max_standby_archive_delay")
			s.MaxStandbyArchiveDelay.Encode(e)
		}
	}
	{
		if s.MaxStandbyStreamingDelay.Set {
			e.FieldStart("max_standby_streaming_delay")
			s.MaxStandbyStreamingDelay.Encode(e)
		}
	}
	{
		if s.MaxWorkerProcesses.Set {
			e.FieldStart("max_worker_processes")
			s.MaxWorkerProcesses.Encode(e)
		}
	}
	{
		if s.SharedBuffers.Set {
			e.FieldStart("shared_buffers")
			s.SharedBuffers.Encode(e)
		}
	}
	{
		if s.WorkMem.Set {
			e.FieldStart("work_mem")
			s.WorkMem.Encode(e)
		}
	}
	{
		if s.SessionReplicationRole.Set {
			e.FieldStart("session_replication_role")
			s.SessionReplicationRole.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdatePostgresConfigBody = [14]string{
	0:  "statement_timeout",
	1:  "effective_cache_size",
	2:  "maintenance_work_mem",
	3:  "max_connections",
	4:  "max_locks_per_transaction",
	5:  "max_parallel_maintenance_workers",
	6:  "max_parallel_workers",
	7:  "max_parallel_workers_per_gather",
	8:  "max_standby_archive_delay",
	9:  "max_standby_streaming_delay",
	10: "max_worker_processes",
	11: "shared_buffers",
	12: "work_mem",
	13: "session_replication_role",
}

// Decode decodes UpdatePostgresConfigBody from json.
func (s *UpdatePostgresConfigBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdatePostgresConfigBody to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "statement_timeout":
			if err := func() error {
				s.StatementTimeout.Reset()
				if err := s.StatementTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statement_timeout\"")
			}
		case "effective_cache_size":
			if err := func() error {
				s.EffectiveCacheSize.Reset()
				if err := s.EffectiveCacheSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effective_cache_size\"")
			}
		case "maintenance_work_mem":
			if err := func() error {
				s.MaintenanceWorkMem.Reset()
				if err := s.MaintenanceWorkMem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintenance_work_mem\"")
			}
		case "max_connections":
			if err := func() error {
				s.MaxConnections.Reset()
				if err := s.MaxConnections.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_connections\"")
			}
		case "max_locks_per_transaction":
			if err := func() error {
				s.MaxLocksPerTransaction.Reset()
				if err := s.MaxLocksPerTransaction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_locks_per_transaction\"")
			}
		case "max_parallel_maintenance_workers":
			if err := func() error {
				s.MaxParallelMaintenanceWorkers.Reset()
				if err := s.MaxParallelMaintenanceWorkers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_parallel_maintenance_workers\"")
			}
		case "max_parallel_workers":
			if err := func() error {
				s.MaxParallelWorkers.Reset()
				if err := s.MaxParallelWorkers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_parallel_workers\"")
			}
		case "max_parallel_workers_per_gather":
			if err := func() error {
				s.MaxParallelWorkersPerGather.Reset()
				if err := s.MaxParallelWorkersPerGather.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_parallel_workers_per_gather\"")
			}
		case "max_standby_archive_delay":
			if err := func() error {
				s.MaxStandbyArchiveDelay.Reset()
				if err := s.MaxStandbyArchiveDelay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_standby_archive_delay\"")
			}
		case "max_standby_streaming_delay":
			if err := func() error {
				s.MaxStandbyStreamingDelay.Reset()
				if err := s.MaxStandbyStreamingDelay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_standby_streaming_delay\"")
			}
		case "max_worker_processes":
			if err := func() error {
				s.MaxWorkerProcesses.Reset()
				if err := s.MaxWorkerProcesses.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_worker_processes\"")
			}
		case "shared_buffers":
			if err := func() error {
				s.SharedBuffers.Reset()
				if err := s.SharedBuffers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shared_buffers\"")
			}
		case "work_mem":
			if err := func() error {
				s.WorkMem.Reset()
				if err := s.WorkMem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"work_mem\"")
			}
		case "session_replication_role":
			if err := func() error {
				s.SessionReplicationRole.Reset()
				if err := s.SessionReplicationRole.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"session_replication_role\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdatePostgresConfigBody")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdatePostgresConfigBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdatePostgresConfigBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdatePostgresConfigBodySessionReplicationRole as json.
func (s UpdatePostgresConfigBodySessionReplicationRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdatePostgresConfigBodySessionReplicationRole from json.
func (s *UpdatePostgresConfigBodySessionReplicationRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdatePostgresConfigBodySessionReplicationRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdatePostgresConfigBodySessionReplicationRole(v) {
	case UpdatePostgresConfigBodySessionReplicationRoleOrigin:
		*s = UpdatePostgresConfigBodySessionReplicationRoleOrigin
	case UpdatePostgresConfigBodySessionReplicationRoleReplica:
		*s = UpdatePostgresConfigBodySessionReplicationRoleReplica
	case UpdatePostgresConfigBodySessionReplicationRoleLocal:
		*s = UpdatePostgresConfigBodySessionReplicationRoleLocal
	default:
		*s = UpdatePostgresConfigBodySessionReplicationRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdatePostgresConfigBodySessionReplicationRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdatePostgresConfigBodySessionReplicationRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdatePostgrestConfigBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdatePostgrestConfigBody) encodeFields(e *jx.Encoder) {
	{
		if s.MaxRows.Set {
			e.FieldStart("max_rows")
			s.MaxRows.Encode(e)
		}
	}
	{
		if s.DbPool.Set {
			e.FieldStart("db_pool")
			s.DbPool.Encode(e)
		}
	}
	{
		if s.DbExtraSearchPath.Set {
			e.FieldStart("db_extra_search_path")
			s.DbExtraSearchPath.Encode(e)
		}
	}
	{
		if s.DbSchema.Set {
			e.FieldStart("db_schema")
			s.DbSchema.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdatePostgrestConfigBody = [4]string{
	0: "max_rows",
	1: "db_pool",
	2: "db_extra_search_path",
	3: "db_schema",
}

// Decode decodes UpdatePostgrestConfigBody from json.
func (s *UpdatePostgrestConfigBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdatePostgrestConfigBody to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "max_rows":
			if err := func() error {
				s.MaxRows.Reset()
				if err := s.MaxRows.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_rows\"")
			}
		case "db_pool":
			if err := func() error {
				s.DbPool.Reset()
				if err := s.DbPool.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"db_pool\"")
			}
		case "db_extra_search_path":
			if err := func() error {
				s.DbExtraSearchPath.Reset()
				if err := s.DbExtraSearchPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"db_extra_search_path\"")
			}
		case "db_schema":
			if err := func() error {
				s.DbSchema.Reset()
				if err := s.DbSchema.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"db_schema\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdatePostgrestConfigBody")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdatePostgrestConfigBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdatePostgrestConfigBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateProviderBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateProviderBody) encodeFields(e *jx.Encoder) {
	{
		if s.MetadataXML.Set {
			e.FieldStart("metadata_xml")
			s.MetadataXML.Encode(e)
		}
	}
	{
		if s.MetadataURL.Set {
			e.FieldStart("metadata_url")
			s.MetadataURL.Encode(e)
		}
	}
	{
		if s.Domains != nil {
			e.FieldStart("domains")
			e.ArrStart()
			for _, elem := range s.Domains {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AttributeMapping.Set {
			e.FieldStart("attribute_mapping")
			s.AttributeMapping.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateProviderBody = [4]string{
	0: "metadata_xml",
	1: "metadata_url",
	2: "domains",
	3: "attribute_mapping",
}

// Decode decodes UpdateProviderBody from json.
func (s *UpdateProviderBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateProviderBody to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metadata_xml":
			if err := func() error {
				s.MetadataXML.Reset()
				if err := s.MetadataXML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata_xml\"")
			}
		case "metadata_url":
			if err := func() error {
				s.MetadataURL.Reset()
				if err := s.MetadataURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata_url\"")
			}
		case "domains":
			if err := func() error {
				s.Domains = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Domains = append(s.Domains, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domains\"")
			}
		case "attribute_mapping":
			if err := func() error {
				s.AttributeMapping.Reset()
				if err := s.AttributeMapping.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attribute_mapping\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateProviderBody")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateProviderBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateProviderBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateProviderResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateProviderResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.Saml.Set {
			e.FieldStart("saml")
			s.Saml.Encode(e)
		}
	}
	{
		if s.Domains != nil {
			e.FieldStart("domains")
			e.ArrStart()
			for _, elem := range s.Domains {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateProviderResponse = [5]string{
	0: "id",
	1: "saml",
	2: "domains",
	3: "created_at",
	4: "updated_at",
}

// Decode decodes UpdateProviderResponse from json.
func (s *UpdateProviderResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateProviderResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "saml":
			if err := func() error {
				s.Saml.Reset()
				if err := s.Saml.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"saml\"")
			}
		case "domains":
			if err := func() error {
				s.Domains = make([]Domain, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Domain
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Domains = append(s.Domains, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domains\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateProviderResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateProviderResponse) {
					name = jsonFieldsNameOfUpdateProviderResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateProviderResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateProviderResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpgradeDatabaseBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpgradeDatabaseBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("target_version")
		e.Float64(s.TargetVersion)
	}
}

var jsonFieldsNameOfUpgradeDatabaseBody = [1]string{
	0: "target_version",
}

// Decode decodes UpgradeDatabaseBody from json.
func (s *UpgradeDatabaseBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpgradeDatabaseBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "target_version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TargetVersion = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpgradeDatabaseBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpgradeDatabaseBody) {
					name = jsonFieldsNameOfUpgradeDatabaseBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpgradeDatabaseBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpgradeDatabaseBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1Backup) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1Backup) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("is_physical_backup")
		e.Bool(s.IsPhysicalBackup)
	}
	{
		e.FieldStart("inserted_at")
		e.Str(s.InsertedAt)
	}
}

var jsonFieldsNameOfV1Backup = [3]string{
	0: "status",
	1: "is_physical_backup",
	2: "inserted_at",
}

// Decode decodes V1Backup from json.
func (s *V1Backup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1Backup to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "is_physical_backup":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IsPhysicalBackup = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_physical_backup\"")
			}
		case "inserted_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.InsertedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inserted_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1Backup")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfV1Backup) {
					name = jsonFieldsNameOfV1Backup[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1Backup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1Backup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1BackupStatus as json.
func (s V1BackupStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1BackupStatus from json.
func (s *V1BackupStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1BackupStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1BackupStatus(v) {
	case V1BackupStatusCOMPLETED:
		*s = V1BackupStatusCOMPLETED
	case V1BackupStatusFAILED:
		*s = V1BackupStatusFAILED
	case V1BackupStatusPENDING:
		*s = V1BackupStatusPENDING
	case V1BackupStatusREMOVED:
		*s = V1BackupStatusREMOVED
	case V1BackupStatusARCHIVED:
		*s = V1BackupStatusARCHIVED
	default:
		*s = V1BackupStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1BackupStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1BackupStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1BackupsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1BackupsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("region")
		e.Str(s.Region)
	}
	{
		e.FieldStart("walg_enabled")
		e.Bool(s.WalgEnabled)
	}
	{
		e.FieldStart("pitr_enabled")
		e.Bool(s.PitrEnabled)
	}
	{
		e.FieldStart("backups")
		e.ArrStart()
		for _, elem := range s.Backups {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("physical_backup_data")
		s.PhysicalBackupData.Encode(e)
	}
}

var jsonFieldsNameOfV1BackupsResponse = [5]string{
	0: "region",
	1: "walg_enabled",
	2: "pitr_enabled",
	3: "backups",
	4: "physical_backup_data",
}

// Decode decodes V1BackupsResponse from json.
func (s *V1BackupsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1BackupsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "region":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Region = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		case "walg_enabled":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.WalgEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"walg_enabled\"")
			}
		case "pitr_enabled":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.PitrEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pitr_enabled\"")
			}
		case "backups":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Backups = make([]V1Backup, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1Backup
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Backups = append(s.Backups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backups\"")
			}
		case "physical_backup_data":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.PhysicalBackupData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"physical_backup_data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1BackupsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfV1BackupsResponse) {
					name = jsonFieldsNameOfV1BackupsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1BackupsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1BackupsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1CreateFunctionBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1CreateFunctionBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("slug")
		e.Str(s.Slug)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
	{
		if s.VerifyJwt.Set {
			e.FieldStart("verify_jwt")
			s.VerifyJwt.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1CreateFunctionBody = [4]string{
	0: "slug",
	1: "name",
	2: "body",
	3: "verify_jwt",
}

// Decode decodes V1CreateFunctionBody from json.
func (s *V1CreateFunctionBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1CreateFunctionBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "slug":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Slug = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "body":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "verify_jwt":
			if err := func() error {
				s.VerifyJwt.Reset()
				if err := s.VerifyJwt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verify_jwt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1CreateFunctionBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfV1CreateFunctionBody) {
					name = jsonFieldsNameOfV1CreateFunctionBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1CreateFunctionBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1CreateFunctionBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1CreateProjectBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1CreateProjectBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("db_pass")
		e.Str(s.DbPass)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("organization_id")
		e.Str(s.OrganizationID)
	}
	{
		if s.Plan.Set {
			e.FieldStart("plan")
			s.Plan.Encode(e)
		}
	}
	{
		e.FieldStart("region")
		s.Region.Encode(e)
	}
	{
		if s.KpsEnabled.Set {
			e.FieldStart("kps_enabled")
			s.KpsEnabled.Encode(e)
		}
	}
	{
		if s.DesiredInstanceSize.Set {
			e.FieldStart("desired_instance_size")
			s.DesiredInstanceSize.Encode(e)
		}
	}
	{
		if s.TemplateURL.Set {
			e.FieldStart("template_url")
			s.TemplateURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1CreateProjectBody = [8]string{
	0: "db_pass",
	1: "name",
	2: "organization_id",
	3: "plan",
	4: "region",
	5: "kps_enabled",
	6: "desired_instance_size",
	7: "template_url",
}

// Decode decodes V1CreateProjectBody from json.
func (s *V1CreateProjectBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1CreateProjectBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "db_pass":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DbPass = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"db_pass\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "organization_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.OrganizationID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_id\"")
			}
		case "plan":
			if err := func() error {
				s.Plan.Reset()
				if err := s.Plan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plan\"")
			}
		case "region":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Region.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		case "kps_enabled":
			if err := func() error {
				s.KpsEnabled.Reset()
				if err := s.KpsEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kps_enabled\"")
			}
		case "desired_instance_size":
			if err := func() error {
				s.DesiredInstanceSize.Reset()
				if err := s.DesiredInstanceSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"desired_instance_size\"")
			}
		case "template_url":
			if err := func() error {
				s.TemplateURL.Reset()
				if err := s.TemplateURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1CreateProjectBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfV1CreateProjectBody) {
					name = jsonFieldsNameOfV1CreateProjectBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1CreateProjectBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1CreateProjectBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1CreateProjectBodyPlan as json.
func (s V1CreateProjectBodyPlan) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1CreateProjectBodyPlan from json.
func (s *V1CreateProjectBodyPlan) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1CreateProjectBodyPlan to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1CreateProjectBodyPlan(v) {
	case V1CreateProjectBodyPlanFree:
		*s = V1CreateProjectBodyPlanFree
	case V1CreateProjectBodyPlanPro:
		*s = V1CreateProjectBodyPlanPro
	default:
		*s = V1CreateProjectBodyPlan(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1CreateProjectBodyPlan) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1CreateProjectBodyPlan) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1CreateProjectBodyRegion as json.
func (s V1CreateProjectBodyRegion) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1CreateProjectBodyRegion from json.
func (s *V1CreateProjectBodyRegion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1CreateProjectBodyRegion to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1CreateProjectBodyRegion(v) {
	case V1CreateProjectBodyRegionUsEast1:
		*s = V1CreateProjectBodyRegionUsEast1
	case V1CreateProjectBodyRegionUsWest1:
		*s = V1CreateProjectBodyRegionUsWest1
	case V1CreateProjectBodyRegionUsWest2:
		*s = V1CreateProjectBodyRegionUsWest2
	case V1CreateProjectBodyRegionApEast1:
		*s = V1CreateProjectBodyRegionApEast1
	case V1CreateProjectBodyRegionApSoutheast1:
		*s = V1CreateProjectBodyRegionApSoutheast1
	case V1CreateProjectBodyRegionApNortheast1:
		*s = V1CreateProjectBodyRegionApNortheast1
	case V1CreateProjectBodyRegionApNortheast2:
		*s = V1CreateProjectBodyRegionApNortheast2
	case V1CreateProjectBodyRegionApSoutheast2:
		*s = V1CreateProjectBodyRegionApSoutheast2
	case V1CreateProjectBodyRegionEuWest1:
		*s = V1CreateProjectBodyRegionEuWest1
	case V1CreateProjectBodyRegionEuWest2:
		*s = V1CreateProjectBodyRegionEuWest2
	case V1CreateProjectBodyRegionEuWest3:
		*s = V1CreateProjectBodyRegionEuWest3
	case V1CreateProjectBodyRegionEuCentral1:
		*s = V1CreateProjectBodyRegionEuCentral1
	case V1CreateProjectBodyRegionCaCentral1:
		*s = V1CreateProjectBodyRegionCaCentral1
	case V1CreateProjectBodyRegionApSouth1:
		*s = V1CreateProjectBodyRegionApSouth1
	case V1CreateProjectBodyRegionSaEast1:
		*s = V1CreateProjectBodyRegionSaEast1
	default:
		*s = V1CreateProjectBodyRegion(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1CreateProjectBodyRegion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1CreateProjectBodyRegion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1DatabaseResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1DatabaseResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("host")
		e.Str(s.Host)
	}
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
}

var jsonFieldsNameOfV1DatabaseResponse = [2]string{
	0: "host",
	1: "version",
}

// Decode decodes V1DatabaseResponse from json.
func (s *V1DatabaseResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1DatabaseResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "host":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Host = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1DatabaseResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfV1DatabaseResponse) {
					name = jsonFieldsNameOfV1DatabaseResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1DatabaseResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1DatabaseResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1OrganizationMemberResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1OrganizationMemberResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("user_id")
		e.Str(s.UserID)
	}
	{
		e.FieldStart("user_name")
		e.Str(s.UserName)
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		e.FieldStart("role_name")
		e.Str(s.RoleName)
	}
	{
		e.FieldStart("mfa_enabled")
		e.Bool(s.MfaEnabled)
	}
}

var jsonFieldsNameOfV1OrganizationMemberResponse = [5]string{
	0: "user_id",
	1: "user_name",
	2: "email",
	3: "role_name",
	4: "mfa_enabled",
}

// Decode decodes V1OrganizationMemberResponse from json.
func (s *V1OrganizationMemberResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1OrganizationMemberResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.UserID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "user_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.UserName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "role_name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.RoleName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role_name\"")
			}
		case "mfa_enabled":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.MfaEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mfa_enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1OrganizationMemberResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfV1OrganizationMemberResponse) {
					name = jsonFieldsNameOfV1OrganizationMemberResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1OrganizationMemberResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1OrganizationMemberResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1OrganizationSlugResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1OrganizationSlugResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Plan.Set {
			e.FieldStart("plan")
			s.Plan.Encode(e)
		}
	}
	{
		e.FieldStart("opt_in_tags")
		e.ArrStart()
		for _, elem := range s.OptInTags {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfV1OrganizationSlugResponse = [4]string{
	0: "plan",
	1: "opt_in_tags",
	2: "id",
	3: "name",
}

// Decode decodes V1OrganizationSlugResponse from json.
func (s *V1OrganizationSlugResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1OrganizationSlugResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "plan":
			if err := func() error {
				s.Plan.Reset()
				if err := s.Plan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plan\"")
			}
		case "opt_in_tags":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.OptInTags = make([]V1OrganizationSlugResponseOptInTagsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1OrganizationSlugResponseOptInTagsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.OptInTags = append(s.OptInTags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"opt_in_tags\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1OrganizationSlugResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfV1OrganizationSlugResponse) {
					name = jsonFieldsNameOfV1OrganizationSlugResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1OrganizationSlugResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1OrganizationSlugResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1OrganizationSlugResponseOptInTagsItem as json.
func (s V1OrganizationSlugResponseOptInTagsItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1OrganizationSlugResponseOptInTagsItem from json.
func (s *V1OrganizationSlugResponseOptInTagsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1OrganizationSlugResponseOptInTagsItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1OrganizationSlugResponseOptInTagsItem(v) {
	case V1OrganizationSlugResponseOptInTagsItemAISQLGENERATOROPTIN:
		*s = V1OrganizationSlugResponseOptInTagsItemAISQLGENERATOROPTIN
	default:
		*s = V1OrganizationSlugResponseOptInTagsItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1OrganizationSlugResponseOptInTagsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1OrganizationSlugResponseOptInTagsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1PgbouncerConfigResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1PgbouncerConfigResponse) encodeFields(e *jx.Encoder) {
	{
		if s.PoolMode.Set {
			e.FieldStart("pool_mode")
			s.PoolMode.Encode(e)
		}
	}
	{
		if s.DefaultPoolSize.Set {
			e.FieldStart("default_pool_size")
			s.DefaultPoolSize.Encode(e)
		}
	}
	{
		if s.IgnoreStartupParameters.Set {
			e.FieldStart("ignore_startup_parameters")
			s.IgnoreStartupParameters.Encode(e)
		}
	}
	{
		if s.MaxClientConn.Set {
			e.FieldStart("max_client_conn")
			s.MaxClientConn.Encode(e)
		}
	}
	{
		if s.ConnectionString.Set {
			e.FieldStart("connection_string")
			s.ConnectionString.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1PgbouncerConfigResponse = [5]string{
	0: "pool_mode",
	1: "default_pool_size",
	2: "ignore_startup_parameters",
	3: "max_client_conn",
	4: "connection_string",
}

// Decode decodes V1PgbouncerConfigResponse from json.
func (s *V1PgbouncerConfigResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1PgbouncerConfigResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pool_mode":
			if err := func() error {
				s.PoolMode.Reset()
				if err := s.PoolMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pool_mode\"")
			}
		case "default_pool_size":
			if err := func() error {
				s.DefaultPoolSize.Reset()
				if err := s.DefaultPoolSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_pool_size\"")
			}
		case "ignore_startup_parameters":
			if err := func() error {
				s.IgnoreStartupParameters.Reset()
				if err := s.IgnoreStartupParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ignore_startup_parameters\"")
			}
		case "max_client_conn":
			if err := func() error {
				s.MaxClientConn.Reset()
				if err := s.MaxClientConn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_client_conn\"")
			}
		case "connection_string":
			if err := func() error {
				s.ConnectionString.Reset()
				if err := s.ConnectionString.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connection_string\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1PgbouncerConfigResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1PgbouncerConfigResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1PgbouncerConfigResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1PgbouncerConfigResponsePoolMode as json.
func (s V1PgbouncerConfigResponsePoolMode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1PgbouncerConfigResponsePoolMode from json.
func (s *V1PgbouncerConfigResponsePoolMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1PgbouncerConfigResponsePoolMode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1PgbouncerConfigResponsePoolMode(v) {
	case V1PgbouncerConfigResponsePoolModeTransaction:
		*s = V1PgbouncerConfigResponsePoolModeTransaction
	case V1PgbouncerConfigResponsePoolModeSession:
		*s = V1PgbouncerConfigResponsePoolModeSession
	case V1PgbouncerConfigResponsePoolModeStatement:
		*s = V1PgbouncerConfigResponsePoolModeStatement
	default:
		*s = V1PgbouncerConfigResponsePoolMode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1PgbouncerConfigResponsePoolMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1PgbouncerConfigResponsePoolMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1PhysicalBackup) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1PhysicalBackup) encodeFields(e *jx.Encoder) {
	{
		if s.EarliestPhysicalBackupDateUnix.Set {
			e.FieldStart("earliest_physical_backup_date_unix")
			s.EarliestPhysicalBackupDateUnix.Encode(e)
		}
	}
	{
		if s.LatestPhysicalBackupDateUnix.Set {
			e.FieldStart("latest_physical_backup_date_unix")
			s.LatestPhysicalBackupDateUnix.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1PhysicalBackup = [2]string{
	0: "earliest_physical_backup_date_unix",
	1: "latest_physical_backup_date_unix",
}

// Decode decodes V1PhysicalBackup from json.
func (s *V1PhysicalBackup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1PhysicalBackup to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "earliest_physical_backup_date_unix":
			if err := func() error {
				s.EarliestPhysicalBackupDateUnix.Reset()
				if err := s.EarliestPhysicalBackupDateUnix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"earliest_physical_backup_date_unix\"")
			}
		case "latest_physical_backup_date_unix":
			if err := func() error {
				s.LatestPhysicalBackupDateUnix.Reset()
				if err := s.LatestPhysicalBackupDateUnix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latest_physical_backup_date_unix\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1PhysicalBackup")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1PhysicalBackup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1PhysicalBackup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1PostgrestConfigResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1PostgrestConfigResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("max_rows")
		e.Int(s.MaxRows)
	}
	{
		e.FieldStart("db_pool")
		s.DbPool.Encode(e)
	}
	{
		e.FieldStart("db_schema")
		e.Str(s.DbSchema)
	}
	{
		e.FieldStart("db_extra_search_path")
		e.Str(s.DbExtraSearchPath)
	}
}

var jsonFieldsNameOfV1PostgrestConfigResponse = [4]string{
	0: "max_rows",
	1: "db_pool",
	2: "db_schema",
	3: "db_extra_search_path",
}

// Decode decodes V1PostgrestConfigResponse from json.
func (s *V1PostgrestConfigResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1PostgrestConfigResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "max_rows":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MaxRows = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_rows\"")
			}
		case "db_pool":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.DbPool.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"db_pool\"")
			}
		case "db_schema":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DbSchema = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"db_schema\"")
			}
		case "db_extra_search_path":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.DbExtraSearchPath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"db_extra_search_path\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1PostgrestConfigResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfV1PostgrestConfigResponse) {
					name = jsonFieldsNameOfV1PostgrestConfigResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1PostgrestConfigResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1PostgrestConfigResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1ProjectRefResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1ProjectRefResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Float64(s.ID)
	}
	{
		e.FieldStart("ref")
		e.Str(s.Ref)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfV1ProjectRefResponse = [3]string{
	0: "id",
	1: "ref",
	2: "name",
}

// Decode decodes V1ProjectRefResponse from json.
func (s *V1ProjectRefResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1ProjectRefResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.ID = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "ref":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Ref = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ref\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1ProjectRefResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfV1ProjectRefResponse) {
					name = jsonFieldsNameOfV1ProjectRefResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1ProjectRefResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1ProjectRefResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1ProjectResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1ProjectResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("organization_id")
		e.Str(s.OrganizationID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("region")
		e.Str(s.Region)
	}
	{
		e.FieldStart("created_at")
		e.Str(s.CreatedAt)
	}
	{
		if s.Database.Set {
			e.FieldStart("database")
			s.Database.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
}

var jsonFieldsNameOfV1ProjectResponse = [7]string{
	0: "id",
	1: "organization_id",
	2: "name",
	3: "region",
	4: "created_at",
	5: "database",
	6: "status",
}

// Decode decodes V1ProjectResponse from json.
func (s *V1ProjectResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1ProjectResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "organization_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.OrganizationID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "region":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Region = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.CreatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "database":
			if err := func() error {
				s.Database.Reset()
				if err := s.Database.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"database\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1ProjectResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfV1ProjectResponse) {
					name = jsonFieldsNameOfV1ProjectResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1ProjectResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1ProjectResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1ProjectResponseStatus as json.
func (s V1ProjectResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1ProjectResponseStatus from json.
func (s *V1ProjectResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1ProjectResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1ProjectResponseStatus(v) {
	case V1ProjectResponseStatusACTIVEHEALTHY:
		*s = V1ProjectResponseStatusACTIVEHEALTHY
	case V1ProjectResponseStatusACTIVEUNHEALTHY:
		*s = V1ProjectResponseStatusACTIVEUNHEALTHY
	case V1ProjectResponseStatusCOMINGUP:
		*s = V1ProjectResponseStatusCOMINGUP
	case V1ProjectResponseStatusGOINGDOWN:
		*s = V1ProjectResponseStatusGOINGDOWN
	case V1ProjectResponseStatusINACTIVE:
		*s = V1ProjectResponseStatusINACTIVE
	case V1ProjectResponseStatusINITFAILED:
		*s = V1ProjectResponseStatusINITFAILED
	case V1ProjectResponseStatusREMOVED:
		*s = V1ProjectResponseStatusREMOVED
	case V1ProjectResponseStatusRESTORING:
		*s = V1ProjectResponseStatusRESTORING
	case V1ProjectResponseStatusUNKNOWN:
		*s = V1ProjectResponseStatusUNKNOWN
	case V1ProjectResponseStatusUPGRADING:
		*s = V1ProjectResponseStatusUPGRADING
	case V1ProjectResponseStatusPAUSING:
		*s = V1ProjectResponseStatusPAUSING
	default:
		*s = V1ProjectResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1ProjectResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1ProjectResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1RestorePitrBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1RestorePitrBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("recovery_time_target_unix")
		e.Float64(s.RecoveryTimeTargetUnix)
	}
}

var jsonFieldsNameOfV1RestorePitrBody = [1]string{
	0: "recovery_time_target_unix",
}

// Decode decodes V1RestorePitrBody from json.
func (s *V1RestorePitrBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1RestorePitrBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "recovery_time_target_unix":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.RecoveryTimeTargetUnix = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recovery_time_target_unix\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1RestorePitrBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfV1RestorePitrBody) {
					name = jsonFieldsNameOfV1RestorePitrBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1RestorePitrBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1RestorePitrBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1RunQueryBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1RunQueryBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("query")
		e.Str(s.Query)
	}
}

var jsonFieldsNameOfV1RunQueryBody = [1]string{
	0: "query",
}

// Decode decodes V1RunQueryBody from json.
func (s *V1RunQueryBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1RunQueryBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "query":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Query = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"query\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1RunQueryBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfV1RunQueryBody) {
					name = jsonFieldsNameOfV1RunQueryBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1RunQueryBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1RunQueryBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1RunQueryCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1RunQueryCreated) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfV1RunQueryCreated = [0]string{}

// Decode decodes V1RunQueryCreated from json.
func (s *V1RunQueryCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1RunQueryCreated to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode V1RunQueryCreated")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1RunQueryCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1RunQueryCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1ServiceHealthResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1ServiceHealthResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Info.Set {
			e.FieldStart("info")
			s.Info.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		e.FieldStart("healthy")
		e.Bool(s.Healthy)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1ServiceHealthResponse = [5]string{
	0: "info",
	1: "name",
	2: "healthy",
	3: "status",
	4: "error",
}

// Decode decodes V1ServiceHealthResponse from json.
func (s *V1ServiceHealthResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1ServiceHealthResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "info":
			if err := func() error {
				s.Info.Reset()
				if err := s.Info.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"info\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "healthy":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Healthy = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"healthy\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1ServiceHealthResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfV1ServiceHealthResponse) {
					name = jsonFieldsNameOfV1ServiceHealthResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1ServiceHealthResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1ServiceHealthResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1ServiceHealthResponseInfo as json.
func (s V1ServiceHealthResponseInfo) Encode(e *jx.Encoder) {
	switch s.Type {
	case AuthHealthResponseV1ServiceHealthResponseInfo:
		s.AuthHealthResponse.Encode(e)
	case RealtimeHealthResponseV1ServiceHealthResponseInfo:
		s.RealtimeHealthResponse.Encode(e)
	}
}

func (s V1ServiceHealthResponseInfo) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case AuthHealthResponseV1ServiceHealthResponseInfo:
		s.AuthHealthResponse.encodeFields(e)
	case RealtimeHealthResponseV1ServiceHealthResponseInfo:
		s.RealtimeHealthResponse.encodeFields(e)
	}
}

// Decode decodes V1ServiceHealthResponseInfo from json.
func (s *V1ServiceHealthResponseInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1ServiceHealthResponseInfo to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "name":
				match := AuthHealthResponseV1ServiceHealthResponseInfo
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "version":
				match := AuthHealthResponseV1ServiceHealthResponseInfo
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "description":
				match := AuthHealthResponseV1ServiceHealthResponseInfo
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "healthy":
				match := RealtimeHealthResponseV1ServiceHealthResponseInfo
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "db_connected":
				match := RealtimeHealthResponseV1ServiceHealthResponseInfo
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "connected_cluster":
				match := RealtimeHealthResponseV1ServiceHealthResponseInfo
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case AuthHealthResponseV1ServiceHealthResponseInfo:
		if err := s.AuthHealthResponse.Decode(d); err != nil {
			return err
		}
	case RealtimeHealthResponseV1ServiceHealthResponseInfo:
		if err := s.RealtimeHealthResponse.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1ServiceHealthResponseInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1ServiceHealthResponseInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1ServiceHealthResponseName as json.
func (s V1ServiceHealthResponseName) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1ServiceHealthResponseName from json.
func (s *V1ServiceHealthResponseName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1ServiceHealthResponseName to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1ServiceHealthResponseName(v) {
	case V1ServiceHealthResponseNameAuth:
		*s = V1ServiceHealthResponseNameAuth
	case V1ServiceHealthResponseNameDb:
		*s = V1ServiceHealthResponseNameDb
	case V1ServiceHealthResponseNamePooler:
		*s = V1ServiceHealthResponseNamePooler
	case V1ServiceHealthResponseNameRealtime:
		*s = V1ServiceHealthResponseNameRealtime
	case V1ServiceHealthResponseNameRest:
		*s = V1ServiceHealthResponseNameRest
	case V1ServiceHealthResponseNameStorage:
		*s = V1ServiceHealthResponseNameStorage
	default:
		*s = V1ServiceHealthResponseName(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1ServiceHealthResponseName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1ServiceHealthResponseName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1ServiceHealthResponseStatus as json.
func (s V1ServiceHealthResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1ServiceHealthResponseStatus from json.
func (s *V1ServiceHealthResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1ServiceHealthResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1ServiceHealthResponseStatus(v) {
	case V1ServiceHealthResponseStatusCOMINGUP:
		*s = V1ServiceHealthResponseStatusCOMINGUP
	case V1ServiceHealthResponseStatusACTIVEHEALTHY:
		*s = V1ServiceHealthResponseStatusACTIVEHEALTHY
	case V1ServiceHealthResponseStatusUNHEALTHY:
		*s = V1ServiceHealthResponseStatusUNHEALTHY
	default:
		*s = V1ServiceHealthResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1ServiceHealthResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1ServiceHealthResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1StorageBucketResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1StorageBucketResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("owner")
		e.Str(s.Owner)
	}
	{
		e.FieldStart("created_at")
		e.Str(s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		e.Str(s.UpdatedAt)
	}
	{
		e.FieldStart("public")
		e.Bool(s.Public)
	}
}

var jsonFieldsNameOfV1StorageBucketResponse = [6]string{
	0: "id",
	1: "name",
	2: "owner",
	3: "created_at",
	4: "updated_at",
	5: "public",
}

// Decode decodes V1StorageBucketResponse from json.
func (s *V1StorageBucketResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1StorageBucketResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "owner":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Owner = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.CreatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.UpdatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "public":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Public = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1StorageBucketResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfV1StorageBucketResponse) {
					name = jsonFieldsNameOfV1StorageBucketResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1StorageBucketResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1StorageBucketResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1UpdateFunctionBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1UpdateFunctionBody) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Body.Set {
			e.FieldStart("body")
			s.Body.Encode(e)
		}
	}
	{
		if s.VerifyJwt.Set {
			e.FieldStart("verify_jwt")
			s.VerifyJwt.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1UpdateFunctionBody = [3]string{
	0: "name",
	1: "body",
	2: "verify_jwt",
}

// Decode decodes V1UpdateFunctionBody from json.
func (s *V1UpdateFunctionBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1UpdateFunctionBody to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "verify_jwt":
			if err := func() error {
				s.VerifyJwt.Reset()
				if err := s.VerifyJwt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verify_jwt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1UpdateFunctionBody")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1UpdateFunctionBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1UpdateFunctionBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VanitySubdomainBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VanitySubdomainBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("vanity_subdomain")
		e.Str(s.VanitySubdomain)
	}
}

var jsonFieldsNameOfVanitySubdomainBody = [1]string{
	0: "vanity_subdomain",
}

// Decode decodes VanitySubdomainBody from json.
func (s *VanitySubdomainBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VanitySubdomainBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vanity_subdomain":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.VanitySubdomain = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vanity_subdomain\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VanitySubdomainBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVanitySubdomainBody) {
					name = jsonFieldsNameOfVanitySubdomainBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VanitySubdomainBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VanitySubdomainBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VanitySubdomainConfigResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VanitySubdomainConfigResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.CustomDomain.Set {
			e.FieldStart("custom_domain")
			s.CustomDomain.Encode(e)
		}
	}
}

var jsonFieldsNameOfVanitySubdomainConfigResponse = [2]string{
	0: "status",
	1: "custom_domain",
}

// Decode decodes VanitySubdomainConfigResponse from json.
func (s *VanitySubdomainConfigResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VanitySubdomainConfigResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "custom_domain":
			if err := func() error {
				s.CustomDomain.Reset()
				if err := s.CustomDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_domain\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VanitySubdomainConfigResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVanitySubdomainConfigResponse) {
					name = jsonFieldsNameOfVanitySubdomainConfigResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VanitySubdomainConfigResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VanitySubdomainConfigResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VanitySubdomainConfigResponseStatus as json.
func (s VanitySubdomainConfigResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VanitySubdomainConfigResponseStatus from json.
func (s *VanitySubdomainConfigResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VanitySubdomainConfigResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VanitySubdomainConfigResponseStatus(v) {
	case VanitySubdomainConfigResponseStatusNotUsed:
		*s = VanitySubdomainConfigResponseStatusNotUsed
	case VanitySubdomainConfigResponseStatusCustomDomainUsed:
		*s = VanitySubdomainConfigResponseStatusCustomDomainUsed
	case VanitySubdomainConfigResponseStatusActive:
		*s = VanitySubdomainConfigResponseStatusActive
	default:
		*s = VanitySubdomainConfigResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VanitySubdomainConfigResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VanitySubdomainConfigResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
