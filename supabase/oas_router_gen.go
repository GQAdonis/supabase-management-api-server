// Code generated by ogen, DO NOT EDIT.

package api

import (
	"net/http"
	"net/url"
	"strings"

	"github.com/ogen-go/ogen/uri"
)

func (s *Server) cutPrefix(path string) (string, bool) {
	prefix := s.cfg.Prefix
	if prefix == "" {
		return path, true
	}
	if !strings.HasPrefix(path, prefix) {
		// Prefix doesn't match.
		return "", false
	}
	// Cut prefix from the path.
	return strings.TrimPrefix(path, prefix), true
}

// ServeHTTP serves http request as defined by OpenAPI v3 specification,
// calling handler that matches the path or returning not found error.
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	elem := r.URL.Path
	elemIsEscaped := false
	if rawPath := r.URL.RawPath; rawPath != "" {
		if normalized, ok := uri.NormalizeEscapedPath(rawPath); ok {
			elem = normalized
			elemIsEscaped = strings.ContainsRune(elem, '%')
		}
	}

	elem, ok := s.cutPrefix(elem)
	if !ok || len(elem) == 0 {
		s.notFound(w, r)
		return
	}
	args := [2]string{}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/v1/"
			origElem := elem
			if l := len("/v1/"); len(elem) >= l && elem[0:l] == "/v1/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case 'b': // Prefix: "branches/"
				origElem := elem
				if l := len("branches/"); len(elem) >= l && elem[0:l] == "branches/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "branch_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					switch r.Method {
					case "DELETE":
						s.handleDeleteBranchRequest([1]string{
							args[0],
						}, elemIsEscaped, w, r)
					case "GET":
						s.handleGetBranchDetailsRequest([1]string{
							args[0],
						}, elemIsEscaped, w, r)
					case "PATCH":
						s.handleUpdateBranchRequest([1]string{
							args[0],
						}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "DELETE,GET,PATCH")
					}

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/reset"
					origElem := elem
					if l := len("/reset"); len(elem) >= l && elem[0:l] == "/reset" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "POST":
							s.handleResetBranchRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "POST")
						}

						return
					}

					elem = origElem
				}

				elem = origElem
			case 'o': // Prefix: "o"
				origElem := elem
				if l := len("o"); len(elem) >= l && elem[0:l] == "o" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "auth/"
					origElem := elem
					if l := len("auth/"); len(elem) >= l && elem[0:l] == "auth/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'a': // Prefix: "authorize"
						origElem := elem
						if l := len("authorize"); len(elem) >= l && elem[0:l] == "authorize" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleAuthorizeRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

						elem = origElem
					case 't': // Prefix: "token"
						origElem := elem
						if l := len("token"); len(elem) >= l && elem[0:l] == "token" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleTokenRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

						elem = origElem
					}

					elem = origElem
				case 'r': // Prefix: "rganizations"
					origElem := elem
					if l := len("rganizations"); len(elem) >= l && elem[0:l] == "rganizations" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleGetOrganizationsRequest([0]string{}, elemIsEscaped, w, r)
						case "POST":
							s.handleCreateOrganizationRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						origElem := elem
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "slug"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleGetOrganizationRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/members"
							origElem := elem
							if l := len("/members"); len(elem) >= l && elem[0:l] == "/members" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleV1ListOrganizationMembersRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				}

				elem = origElem
			case 'p': // Prefix: "projects"
				origElem := elem
				if l := len("projects"); len(elem) >= l && elem[0:l] == "projects" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch r.Method {
					case "GET":
						s.handleGetProjectsRequest([0]string{}, elemIsEscaped, w, r)
					case "POST":
						s.handleCreateProjectRequest([0]string{}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "GET,POST")
					}

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					origElem := elem
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "ref"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						switch r.Method {
						case "DELETE":
							s.handleDeleteProjectRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "DELETE")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						origElem := elem
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "api-keys"
							origElem := elem
							if l := len("api-keys"); len(elem) >= l && elem[0:l] == "api-keys" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetProjectApiKeysRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

							elem = origElem
						case 'b': // Prefix: "branches"
							origElem := elem
							if l := len("branches"); len(elem) >= l && elem[0:l] == "branches" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "DELETE":
									s.handleDisableBranchRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "GET":
									s.handleGetBranchesRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "POST":
									s.handleCreateBranchRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET,POST")
								}

								return
							}

							elem = origElem
						case 'c': // Prefix: "c"
							origElem := elem
							if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'o': // Prefix: "onfig/"
								origElem := elem
								if l := len("onfig/"); len(elem) >= l && elem[0:l] == "onfig/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "auth"
									origElem := elem
									if l := len("auth"); len(elem) >= l && elem[0:l] == "auth" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleGetV1AuthConfigRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										case "PATCH":
											s.handleUpdateV1AuthConfigRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET,PATCH")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										origElem := elem
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 's': // Prefix: "sso/providers"
											origElem := elem
											if l := len("sso/providers"); len(elem) >= l && elem[0:l] == "sso/providers" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleListAllProvidersRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												case "POST":
													s.handleCreateProviderForProjectRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET,POST")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												origElem := elem
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "provider_id"
												// Leaf parameter
												args[1] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "DELETE":
														s.handleRemoveProviderByIdRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													case "GET":
														s.handleGetProviderByIdRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													case "PUT":
														s.handleUpdateProviderByIdRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "DELETE,GET,PUT")
													}

													return
												}

												elem = origElem
											}

											elem = origElem
										case 't': // Prefix: "third-party-auth"
											origElem := elem
											if l := len("third-party-auth"); len(elem) >= l && elem[0:l] == "third-party-auth" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleListTPAForProjectRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												case "POST":
													s.handleCreateTPAForProjectRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET,POST")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												origElem := elem
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "tpa_id"
												// Leaf parameter
												args[1] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "DELETE":
														s.handleDeleteTPAForProjectRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													case "GET":
														s.handleGetTPAForProjectRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "DELETE,GET")
													}

													return
												}

												elem = origElem
											}

											elem = origElem
										}

										elem = origElem
									}

									elem = origElem
								case 'd': // Prefix: "database/p"
									origElem := elem
									if l := len("database/p"); len(elem) >= l && elem[0:l] == "database/p" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'g': // Prefix: "gbouncer"
										origElem := elem
										if l := len("gbouncer"); len(elem) >= l && elem[0:l] == "gbouncer" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleV1GetPgbouncerConfigRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

										elem = origElem
									case 'o': // Prefix: "ostgres"
										origElem := elem
										if l := len("ostgres"); len(elem) >= l && elem[0:l] == "ostgres" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleGetConfigRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											case "PUT":
												s.handleUpdateConfigRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET,PUT")
											}

											return
										}

										elem = origElem
									}

									elem = origElem
								}

								elem = origElem
							case 'u': // Prefix: "ustom-hostname"
								origElem := elem
								if l := len("ustom-hostname"); len(elem) >= l && elem[0:l] == "ustom-hostname" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "DELETE":
										s.handleRemoveCustomHostnameConfigRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "GET":
										s.handleGetCustomHostnameConfigRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									origElem := elem
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'a': // Prefix: "activate"
										origElem := elem
										if l := len("activate"); len(elem) >= l && elem[0:l] == "activate" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleActivateRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

										elem = origElem
									case 'i': // Prefix: "initialize"
										origElem := elem
										if l := len("initialize"); len(elem) >= l && elem[0:l] == "initialize" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleCreateCustomHostnameConfigRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

										elem = origElem
									case 'r': // Prefix: "reverify"
										origElem := elem
										if l := len("reverify"); len(elem) >= l && elem[0:l] == "reverify" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleReverifyRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

										elem = origElem
									}

									elem = origElem
								}

								elem = origElem
							}

							elem = origElem
						case 'd': // Prefix: "database/"
							origElem := elem
							if l := len("database/"); len(elem) >= l && elem[0:l] == "database/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'b': // Prefix: "backups"
								origElem := elem
								if l := len("backups"); len(elem) >= l && elem[0:l] == "backups" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleGetBackupsRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/restore-pitr"
									origElem := elem
									if l := len("/restore-pitr"); len(elem) >= l && elem[0:l] == "/restore-pitr" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleV1RestorePitrRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

									elem = origElem
								}

								elem = origElem
							case 'q': // Prefix: "query"
								origElem := elem
								if l := len("query"); len(elem) >= l && elem[0:l] == "query" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleV1RunQueryRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

								elem = origElem
							case 'w': // Prefix: "webhooks/enable"
								origElem := elem
								if l := len("webhooks/enable"); len(elem) >= l && elem[0:l] == "webhooks/enable" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleV1EnableDatabaseWebhooksRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

								elem = origElem
							}

							elem = origElem
						case 'f': // Prefix: "functions"
							origElem := elem
							if l := len("functions"); len(elem) >= l && elem[0:l] == "functions" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleGetFunctionsRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "POST":
									s.handleCreateFunctionRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "function_slug"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch r.Method {
									case "DELETE":
										s.handleDeleteFunctionRequest([2]string{
											args[0],
											args[1],
										}, elemIsEscaped, w, r)
									case "GET":
										s.handleGetFunctionRequest([2]string{
											args[0],
											args[1],
										}, elemIsEscaped, w, r)
									case "PATCH":
										s.handleUpdateFunctionRequest([2]string{
											args[0],
											args[1],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET,PATCH")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/body"
									origElem := elem
									if l := len("/body"); len(elem) >= l && elem[0:l] == "/body" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetFunctionBodyRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

									elem = origElem
								}

								elem = origElem
							}

							elem = origElem
						case 'h': // Prefix: "health"
							origElem := elem
							if l := len("health"); len(elem) >= l && elem[0:l] == "health" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleCheckServiceHealthRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

							elem = origElem
						case 'n': // Prefix: "network-"
							origElem := elem
							if l := len("network-"); len(elem) >= l && elem[0:l] == "network-" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'b': // Prefix: "bans"
								origElem := elem
								if l := len("bans"); len(elem) >= l && elem[0:l] == "bans" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "DELETE":
										s.handleRemoveNetworkBanRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/retrieve"
									origElem := elem
									if l := len("/retrieve"); len(elem) >= l && elem[0:l] == "/retrieve" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleGetNetworkBansRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

									elem = origElem
								}

								elem = origElem
							case 'r': // Prefix: "restrictions"
								origElem := elem
								if l := len("restrictions"); len(elem) >= l && elem[0:l] == "restrictions" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleGetNetworkRestrictionsRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/apply"
									origElem := elem
									if l := len("/apply"); len(elem) >= l && elem[0:l] == "/apply" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleApplyNetworkRestrictionsRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

									elem = origElem
								}

								elem = origElem
							}

							elem = origElem
						case 'p': // Prefix: "p"
							origElem := elem
							if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'g': // Prefix: "gsodium"
								origElem := elem
								if l := len("gsodium"); len(elem) >= l && elem[0:l] == "gsodium" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetPgsodiumConfigRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "PUT":
										s.handleUpdatePgsodiumConfigRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET,PUT")
									}

									return
								}

								elem = origElem
							case 'o': // Prefix: "ostgrest"
								origElem := elem
								if l := len("ostgrest"); len(elem) >= l && elem[0:l] == "ostgrest" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetPostgRESTConfigRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "PATCH":
										s.handleUpdatePostgRESTConfigRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET,PATCH")
									}

									return
								}

								elem = origElem
							}

							elem = origElem
						case 'r': // Prefix: "read"
							origElem := elem
							if l := len("read"); len(elem) >= l && elem[0:l] == "read" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '-': // Prefix: "-replicas/"
								origElem := elem
								if l := len("-replicas/"); len(elem) >= l && elem[0:l] == "-replicas/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'r': // Prefix: "remove"
									origElem := elem
									if l := len("remove"); len(elem) >= l && elem[0:l] == "remove" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleRemoveReadReplicaRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

									elem = origElem
								case 's': // Prefix: "setup"
									origElem := elem
									if l := len("setup"); len(elem) >= l && elem[0:l] == "setup" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleSetUpReadReplicaRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

									elem = origElem
								}

								elem = origElem
							case 'o': // Prefix: "only"
								origElem := elem
								if l := len("only"); len(elem) >= l && elem[0:l] == "only" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleGetReadOnlyModeStatusRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/temporary-disable"
									origElem := elem
									if l := len("/temporary-disable"); len(elem) >= l && elem[0:l] == "/temporary-disable" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleTemporarilyDisableReadonlyModeRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

									elem = origElem
								}

								elem = origElem
							}

							elem = origElem
						case 's': // Prefix: "s"
							origElem := elem
							if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'e': // Prefix: "ecrets"
								origElem := elem
								if l := len("ecrets"); len(elem) >= l && elem[0:l] == "ecrets" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleDeleteSecretsRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "GET":
										s.handleGetSecretsRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "POST":
										s.handleCreateSecretsRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET,POST")
									}

									return
								}

								elem = origElem
							case 's': // Prefix: "sl-enforcement"
								origElem := elem
								if l := len("sl-enforcement"); len(elem) >= l && elem[0:l] == "sl-enforcement" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetSslEnforcementConfigRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "PUT":
										s.handleUpdateSslEnforcementConfigRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET,PUT")
									}

									return
								}

								elem = origElem
							case 't': // Prefix: "torage/buckets"
								origElem := elem
								if l := len("torage/buckets"); len(elem) >= l && elem[0:l] == "torage/buckets" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetBucketsRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

								elem = origElem
							}

							elem = origElem
						case 't': // Prefix: "types/typescript"
							origElem := elem
							if l := len("types/typescript"); len(elem) >= l && elem[0:l] == "types/typescript" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetTypescriptTypesRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

							elem = origElem
						case 'u': // Prefix: "upgrade"
							origElem := elem
							if l := len("upgrade"); len(elem) >= l && elem[0:l] == "upgrade" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "POST":
									s.handleUpgradeProjectRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'e': // Prefix: "eligibility"
									origElem := elem
									if l := len("eligibility"); len(elem) >= l && elem[0:l] == "eligibility" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleUpgradeEligibilityInformationRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

									elem = origElem
								case 's': // Prefix: "status"
									origElem := elem
									if l := len("status"); len(elem) >= l && elem[0:l] == "status" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetUpgradeStatusRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

									elem = origElem
								}

								elem = origElem
							}

							elem = origElem
						case 'v': // Prefix: "vanity-subdomain"
							origElem := elem
							if l := len("vanity-subdomain"); len(elem) >= l && elem[0:l] == "vanity-subdomain" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "DELETE":
									s.handleRemoveVanitySubdomainConfigRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "GET":
									s.handleGetVanitySubdomainConfigRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "activate"
									origElem := elem
									if l := len("activate"); len(elem) >= l && elem[0:l] == "activate" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleActivateVanitySubdomainPleaseRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

									elem = origElem
								case 'c': // Prefix: "check-availability"
									origElem := elem
									if l := len("check-availability"); len(elem) >= l && elem[0:l] == "check-availability" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleCheckVanitySubdomainAvailabilityRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

									elem = origElem
								}

								elem = origElem
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				}

				elem = origElem
			case 's': // Prefix: "snippets"
				origElem := elem
				if l := len("snippets"); len(elem) >= l && elem[0:l] == "snippets" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch r.Method {
					case "GET":
						s.handleListSnippetsRequest([0]string{}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "GET")
					}

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					origElem := elem
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "id"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleGetSnippetRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}

					elem = origElem
				}

				elem = origElem
			}

			elem = origElem
		}
	}
	s.notFound(w, r)
}

// Route is route object.
type Route struct {
	name        string
	summary     string
	operationID string
	pathPattern string
	count       int
	args        [2]string
}

// Name returns ogen operation name.
//
// It is guaranteed to be unique and not empty.
func (r Route) Name() string {
	return r.name
}

// Summary returns OpenAPI summary.
func (r Route) Summary() string {
	return r.summary
}

// OperationID returns OpenAPI operationId.
func (r Route) OperationID() string {
	return r.operationID
}

// PathPattern returns OpenAPI path.
func (r Route) PathPattern() string {
	return r.pathPattern
}

// Args returns parsed arguments.
func (r Route) Args() []string {
	return r.args[:r.count]
}

// FindRoute finds Route for given method and path.
//
// Note: this method does not unescape path or handle reserved characters in path properly. Use FindPath instead.
func (s *Server) FindRoute(method, path string) (Route, bool) {
	return s.FindPath(method, &url.URL{Path: path})
}

// FindPath finds Route for given method and URL.
func (s *Server) FindPath(method string, u *url.URL) (r Route, _ bool) {
	var (
		elem = u.Path
		args = r.args
	)
	if rawPath := u.RawPath; rawPath != "" {
		if normalized, ok := uri.NormalizeEscapedPath(rawPath); ok {
			elem = normalized
		}
		defer func() {
			for i, arg := range r.args[:r.count] {
				if unescaped, err := url.PathUnescape(arg); err == nil {
					r.args[i] = unescaped
				}
			}
		}()
	}

	elem, ok := s.cutPrefix(elem)
	if !ok {
		return r, false
	}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/v1/"
			origElem := elem
			if l := len("/v1/"); len(elem) >= l && elem[0:l] == "/v1/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case 'b': // Prefix: "branches/"
				origElem := elem
				if l := len("branches/"); len(elem) >= l && elem[0:l] == "branches/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "branch_id"
				// Match until "/"
				idx := strings.IndexByte(elem, '/')
				if idx < 0 {
					idx = len(elem)
				}
				args[0] = elem[:idx]
				elem = elem[idx:]

				if len(elem) == 0 {
					switch method {
					case "DELETE":
						r.name = "DeleteBranch"
						r.summary = "Delete a database branch"
						r.operationID = "deleteBranch"
						r.pathPattern = "/v1/branches/{branch_id}"
						r.args = args
						r.count = 1
						return r, true
					case "GET":
						r.name = "GetBranchDetails"
						r.summary = "Get database branch config"
						r.operationID = "getBranchDetails"
						r.pathPattern = "/v1/branches/{branch_id}"
						r.args = args
						r.count = 1
						return r, true
					case "PATCH":
						r.name = "UpdateBranch"
						r.summary = "Update database branch config"
						r.operationID = "updateBranch"
						r.pathPattern = "/v1/branches/{branch_id}"
						r.args = args
						r.count = 1
						return r, true
					default:
						return
					}
				}
				switch elem[0] {
				case '/': // Prefix: "/reset"
					origElem := elem
					if l := len("/reset"); len(elem) >= l && elem[0:l] == "/reset" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "POST":
							// Leaf: ResetBranch
							r.name = "ResetBranch"
							r.summary = "Resets a database branch"
							r.operationID = "resetBranch"
							r.pathPattern = "/v1/branches/{branch_id}/reset"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}

					elem = origElem
				}

				elem = origElem
			case 'o': // Prefix: "o"
				origElem := elem
				if l := len("o"); len(elem) >= l && elem[0:l] == "o" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "auth/"
					origElem := elem
					if l := len("auth/"); len(elem) >= l && elem[0:l] == "auth/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'a': // Prefix: "authorize"
						origElem := elem
						if l := len("authorize"); len(elem) >= l && elem[0:l] == "authorize" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								// Leaf: Authorize
								r.name = "Authorize"
								r.summary = "Authorize user through oauth"
								r.operationID = "authorize"
								r.pathPattern = "/v1/oauth/authorize"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

						elem = origElem
					case 't': // Prefix: "token"
						origElem := elem
						if l := len("token"); len(elem) >= l && elem[0:l] == "token" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "POST":
								// Leaf: Token
								r.name = "Token"
								r.summary = "Exchange auth code for user's access and refresh token"
								r.operationID = "token"
								r.pathPattern = "/v1/oauth/token"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

						elem = origElem
					}

					elem = origElem
				case 'r': // Prefix: "rganizations"
					origElem := elem
					if l := len("rganizations"); len(elem) >= l && elem[0:l] == "rganizations" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "GetOrganizations"
							r.summary = "List all organizations"
							r.operationID = "getOrganizations"
							r.pathPattern = "/v1/organizations"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = "CreateOrganization"
							r.summary = "Create an organization"
							r.operationID = "createOrganization"
							r.pathPattern = "/v1/organizations"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						origElem := elem
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "slug"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = "GetOrganization"
								r.summary = "Gets information about the organization"
								r.operationID = "getOrganization"
								r.pathPattern = "/v1/organizations/{slug}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/members"
							origElem := elem
							if l := len("/members"); len(elem) >= l && elem[0:l] == "/members" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: V1ListOrganizationMembers
									r.name = "V1ListOrganizationMembers"
									r.summary = "List members of an organization"
									r.operationID = "v1ListOrganizationMembers"
									r.pathPattern = "/v1/organizations/{slug}/members"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				}

				elem = origElem
			case 'p': // Prefix: "projects"
				origElem := elem
				if l := len("projects"); len(elem) >= l && elem[0:l] == "projects" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch method {
					case "GET":
						r.name = "GetProjects"
						r.summary = "List all projects"
						r.operationID = "getProjects"
						r.pathPattern = "/v1/projects"
						r.args = args
						r.count = 0
						return r, true
					case "POST":
						r.name = "CreateProject"
						r.summary = "Create a project"
						r.operationID = "createProject"
						r.pathPattern = "/v1/projects"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					origElem := elem
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "ref"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						switch method {
						case "DELETE":
							r.name = "DeleteProject"
							r.summary = "Deletes the given project"
							r.operationID = "deleteProject"
							r.pathPattern = "/v1/projects/{ref}"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						origElem := elem
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "api-keys"
							origElem := elem
							if l := len("api-keys"); len(elem) >= l && elem[0:l] == "api-keys" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: GetProjectApiKeys
									r.name = "GetProjectApiKeys"
									r.summary = "Get project api keys"
									r.operationID = "getProjectApiKeys"
									r.pathPattern = "/v1/projects/{ref}/api-keys"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

							elem = origElem
						case 'b': // Prefix: "branches"
							origElem := elem
							if l := len("branches"); len(elem) >= l && elem[0:l] == "branches" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									// Leaf: DisableBranch
									r.name = "DisableBranch"
									r.summary = "Disables preview branching"
									r.operationID = "disableBranch"
									r.pathPattern = "/v1/projects/{ref}/branches"
									r.args = args
									r.count = 1
									return r, true
								case "GET":
									// Leaf: GetBranches
									r.name = "GetBranches"
									r.summary = "List all database branches"
									r.operationID = "getBranches"
									r.pathPattern = "/v1/projects/{ref}/branches"
									r.args = args
									r.count = 1
									return r, true
								case "POST":
									// Leaf: CreateBranch
									r.name = "CreateBranch"
									r.summary = "Create a database branch"
									r.operationID = "createBranch"
									r.pathPattern = "/v1/projects/{ref}/branches"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

							elem = origElem
						case 'c': // Prefix: "c"
							origElem := elem
							if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'o': // Prefix: "onfig/"
								origElem := elem
								if l := len("onfig/"); len(elem) >= l && elem[0:l] == "onfig/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "auth"
									origElem := elem
									if l := len("auth"); len(elem) >= l && elem[0:l] == "auth" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = "GetV1AuthConfig"
											r.summary = "Gets project's auth config"
											r.operationID = "getV1AuthConfig"
											r.pathPattern = "/v1/projects/{ref}/config/auth"
											r.args = args
											r.count = 1
											return r, true
										case "PATCH":
											r.name = "UpdateV1AuthConfig"
											r.summary = "Updates a project's auth config"
											r.operationID = "updateV1AuthConfig"
											r.pathPattern = "/v1/projects/{ref}/config/auth"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										origElem := elem
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 's': // Prefix: "sso/providers"
											origElem := elem
											if l := len("sso/providers"); len(elem) >= l && elem[0:l] == "sso/providers" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = "ListAllProviders"
													r.summary = "Lists all SSO providers"
													r.operationID = "listAllProviders"
													r.pathPattern = "/v1/projects/{ref}/config/auth/sso/providers"
													r.args = args
													r.count = 1
													return r, true
												case "POST":
													r.name = "CreateProviderForProject"
													r.summary = "Creates a new SSO provider"
													r.operationID = "createProviderForProject"
													r.pathPattern = "/v1/projects/{ref}/config/auth/sso/providers"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												origElem := elem
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "provider_id"
												// Leaf parameter
												args[1] = elem
												elem = ""

												if len(elem) == 0 {
													switch method {
													case "DELETE":
														// Leaf: RemoveProviderById
														r.name = "RemoveProviderById"
														r.summary = "Removes a SSO provider by its UUID"
														r.operationID = "removeProviderById"
														r.pathPattern = "/v1/projects/{ref}/config/auth/sso/providers/{provider_id}"
														r.args = args
														r.count = 2
														return r, true
													case "GET":
														// Leaf: GetProviderById
														r.name = "GetProviderById"
														r.summary = "Gets a SSO provider by its UUID"
														r.operationID = "getProviderById"
														r.pathPattern = "/v1/projects/{ref}/config/auth/sso/providers/{provider_id}"
														r.args = args
														r.count = 2
														return r, true
													case "PUT":
														// Leaf: UpdateProviderById
														r.name = "UpdateProviderById"
														r.summary = "Updates a SSO provider by its UUID"
														r.operationID = "updateProviderById"
														r.pathPattern = "/v1/projects/{ref}/config/auth/sso/providers/{provider_id}"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}

												elem = origElem
											}

											elem = origElem
										case 't': // Prefix: "third-party-auth"
											origElem := elem
											if l := len("third-party-auth"); len(elem) >= l && elem[0:l] == "third-party-auth" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = "ListTPAForProject"
													r.summary = "Lists all third-party auth integrations"
													r.operationID = "listTPAForProject"
													r.pathPattern = "/v1/projects/{ref}/config/auth/third-party-auth"
													r.args = args
													r.count = 1
													return r, true
												case "POST":
													r.name = "CreateTPAForProject"
													r.summary = "Creates a new third-party auth integration"
													r.operationID = "createTPAForProject"
													r.pathPattern = "/v1/projects/{ref}/config/auth/third-party-auth"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"
												origElem := elem
												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "tpa_id"
												// Leaf parameter
												args[1] = elem
												elem = ""

												if len(elem) == 0 {
													switch method {
													case "DELETE":
														// Leaf: DeleteTPAForProject
														r.name = "DeleteTPAForProject"
														r.summary = "Removes a third-party auth integration"
														r.operationID = "deleteTPAForProject"
														r.pathPattern = "/v1/projects/{ref}/config/auth/third-party-auth/{tpa_id}"
														r.args = args
														r.count = 2
														return r, true
													case "GET":
														// Leaf: GetTPAForProject
														r.name = "GetTPAForProject"
														r.summary = "Get a third-party integration"
														r.operationID = "getTPAForProject"
														r.pathPattern = "/v1/projects/{ref}/config/auth/third-party-auth/{tpa_id}"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}

												elem = origElem
											}

											elem = origElem
										}

										elem = origElem
									}

									elem = origElem
								case 'd': // Prefix: "database/p"
									origElem := elem
									if l := len("database/p"); len(elem) >= l && elem[0:l] == "database/p" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'g': // Prefix: "gbouncer"
										origElem := elem
										if l := len("gbouncer"); len(elem) >= l && elem[0:l] == "gbouncer" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												// Leaf: V1GetPgbouncerConfig
												r.name = "V1GetPgbouncerConfig"
												r.summary = "Get project's pgbouncer config"
												r.operationID = "v1GetPgbouncerConfig"
												r.pathPattern = "/v1/projects/{ref}/config/database/pgbouncer"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

										elem = origElem
									case 'o': // Prefix: "ostgres"
										origElem := elem
										if l := len("ostgres"); len(elem) >= l && elem[0:l] == "ostgres" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												// Leaf: GetConfig
												r.name = "GetConfig"
												r.summary = "Gets project's Postgres config"
												r.operationID = "getConfig"
												r.pathPattern = "/v1/projects/{ref}/config/database/postgres"
												r.args = args
												r.count = 1
												return r, true
											case "PUT":
												// Leaf: UpdateConfig
												r.name = "UpdateConfig"
												r.summary = "Updates project's Postgres config"
												r.operationID = "updateConfig"
												r.pathPattern = "/v1/projects/{ref}/config/database/postgres"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

										elem = origElem
									}

									elem = origElem
								}

								elem = origElem
							case 'u': // Prefix: "ustom-hostname"
								origElem := elem
								if l := len("ustom-hostname"); len(elem) >= l && elem[0:l] == "ustom-hostname" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										r.name = "RemoveCustomHostnameConfig"
										r.summary = "Deletes a project's custom hostname configuration"
										r.operationID = "removeCustomHostnameConfig"
										r.pathPattern = "/v1/projects/{ref}/custom-hostname"
										r.args = args
										r.count = 1
										return r, true
									case "GET":
										r.name = "GetCustomHostnameConfig"
										r.summary = "Gets project's custom hostname config"
										r.operationID = "getCustomHostnameConfig"
										r.pathPattern = "/v1/projects/{ref}/custom-hostname"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									origElem := elem
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'a': // Prefix: "activate"
										origElem := elem
										if l := len("activate"); len(elem) >= l && elem[0:l] == "activate" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "POST":
												// Leaf: Activate
												r.name = "Activate"
												r.summary = "Activates a custom hostname for a project."
												r.operationID = "activate"
												r.pathPattern = "/v1/projects/{ref}/custom-hostname/activate"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

										elem = origElem
									case 'i': // Prefix: "initialize"
										origElem := elem
										if l := len("initialize"); len(elem) >= l && elem[0:l] == "initialize" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "POST":
												// Leaf: CreateCustomHostnameConfig
												r.name = "CreateCustomHostnameConfig"
												r.summary = "Updates project's custom hostname configuration"
												r.operationID = "createCustomHostnameConfig"
												r.pathPattern = "/v1/projects/{ref}/custom-hostname/initialize"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

										elem = origElem
									case 'r': // Prefix: "reverify"
										origElem := elem
										if l := len("reverify"); len(elem) >= l && elem[0:l] == "reverify" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "POST":
												// Leaf: Reverify
												r.name = "Reverify"
												r.summary = "Attempts to verify the DNS configuration for project's custom hostname configuration"
												r.operationID = "reverify"
												r.pathPattern = "/v1/projects/{ref}/custom-hostname/reverify"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

										elem = origElem
									}

									elem = origElem
								}

								elem = origElem
							}

							elem = origElem
						case 'd': // Prefix: "database/"
							origElem := elem
							if l := len("database/"); len(elem) >= l && elem[0:l] == "database/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'b': // Prefix: "backups"
								origElem := elem
								if l := len("backups"); len(elem) >= l && elem[0:l] == "backups" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = "GetBackups"
										r.summary = "Lists all backups"
										r.operationID = "getBackups"
										r.pathPattern = "/v1/projects/{ref}/database/backups"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/restore-pitr"
									origElem := elem
									if l := len("/restore-pitr"); len(elem) >= l && elem[0:l] == "/restore-pitr" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "POST":
											// Leaf: V1RestorePitr
											r.name = "V1RestorePitr"
											r.summary = "Restores a PITR backup for a database"
											r.operationID = "v1RestorePitr"
											r.pathPattern = "/v1/projects/{ref}/database/backups/restore-pitr"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

									elem = origElem
								}

								elem = origElem
							case 'q': // Prefix: "query"
								origElem := elem
								if l := len("query"); len(elem) >= l && elem[0:l] == "query" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "POST":
										// Leaf: V1RunQuery
										r.name = "V1RunQuery"
										r.summary = "Run sql query"
										r.operationID = "v1RunQuery"
										r.pathPattern = "/v1/projects/{ref}/database/query"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

								elem = origElem
							case 'w': // Prefix: "webhooks/enable"
								origElem := elem
								if l := len("webhooks/enable"); len(elem) >= l && elem[0:l] == "webhooks/enable" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "POST":
										// Leaf: V1EnableDatabaseWebhooks
										r.name = "V1EnableDatabaseWebhooks"
										r.summary = "Enables Database Webhooks on the project"
										r.operationID = "v1EnableDatabaseWebhooks"
										r.pathPattern = "/v1/projects/{ref}/database/webhooks/enable"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

								elem = origElem
							}

							elem = origElem
						case 'f': // Prefix: "functions"
							origElem := elem
							if l := len("functions"); len(elem) >= l && elem[0:l] == "functions" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = "GetFunctions"
									r.summary = "List all functions"
									r.operationID = "getFunctions"
									r.pathPattern = "/v1/projects/{ref}/functions"
									r.args = args
									r.count = 1
									return r, true
								case "POST":
									r.name = "CreateFunction"
									r.summary = "Create a function"
									r.operationID = "createFunction"
									r.pathPattern = "/v1/projects/{ref}/functions"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "function_slug"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										r.name = "DeleteFunction"
										r.summary = "Delete a function"
										r.operationID = "deleteFunction"
										r.pathPattern = "/v1/projects/{ref}/functions/{function_slug}"
										r.args = args
										r.count = 2
										return r, true
									case "GET":
										r.name = "GetFunction"
										r.summary = "Retrieve a function"
										r.operationID = "getFunction"
										r.pathPattern = "/v1/projects/{ref}/functions/{function_slug}"
										r.args = args
										r.count = 2
										return r, true
									case "PATCH":
										r.name = "UpdateFunction"
										r.summary = "Update a function"
										r.operationID = "updateFunction"
										r.pathPattern = "/v1/projects/{ref}/functions/{function_slug}"
										r.args = args
										r.count = 2
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/body"
									origElem := elem
									if l := len("/body"); len(elem) >= l && elem[0:l] == "/body" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											// Leaf: GetFunctionBody
											r.name = "GetFunctionBody"
											r.summary = "Retrieve a function body"
											r.operationID = "getFunctionBody"
											r.pathPattern = "/v1/projects/{ref}/functions/{function_slug}/body"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}

									elem = origElem
								}

								elem = origElem
							}

							elem = origElem
						case 'h': // Prefix: "health"
							origElem := elem
							if l := len("health"); len(elem) >= l && elem[0:l] == "health" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: CheckServiceHealth
									r.name = "CheckServiceHealth"
									r.summary = "Gets project's service health status"
									r.operationID = "checkServiceHealth"
									r.pathPattern = "/v1/projects/{ref}/health"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

							elem = origElem
						case 'n': // Prefix: "network-"
							origElem := elem
							if l := len("network-"); len(elem) >= l && elem[0:l] == "network-" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'b': // Prefix: "bans"
								origElem := elem
								if l := len("bans"); len(elem) >= l && elem[0:l] == "bans" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										r.name = "RemoveNetworkBan"
										r.summary = "Remove network bans."
										r.operationID = "removeNetworkBan"
										r.pathPattern = "/v1/projects/{ref}/network-bans"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/retrieve"
									origElem := elem
									if l := len("/retrieve"); len(elem) >= l && elem[0:l] == "/retrieve" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "POST":
											// Leaf: GetNetworkBans
											r.name = "GetNetworkBans"
											r.summary = "Gets project's network bans"
											r.operationID = "getNetworkBans"
											r.pathPattern = "/v1/projects/{ref}/network-bans/retrieve"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

									elem = origElem
								}

								elem = origElem
							case 'r': // Prefix: "restrictions"
								origElem := elem
								if l := len("restrictions"); len(elem) >= l && elem[0:l] == "restrictions" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = "GetNetworkRestrictions"
										r.summary = "Gets project's network restrictions"
										r.operationID = "getNetworkRestrictions"
										r.pathPattern = "/v1/projects/{ref}/network-restrictions"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/apply"
									origElem := elem
									if l := len("/apply"); len(elem) >= l && elem[0:l] == "/apply" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "POST":
											// Leaf: ApplyNetworkRestrictions
											r.name = "ApplyNetworkRestrictions"
											r.summary = "Updates project's network restrictions"
											r.operationID = "applyNetworkRestrictions"
											r.pathPattern = "/v1/projects/{ref}/network-restrictions/apply"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

									elem = origElem
								}

								elem = origElem
							}

							elem = origElem
						case 'p': // Prefix: "p"
							origElem := elem
							if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'g': // Prefix: "gsodium"
								origElem := elem
								if l := len("gsodium"); len(elem) >= l && elem[0:l] == "gsodium" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: GetPgsodiumConfig
										r.name = "GetPgsodiumConfig"
										r.summary = "Gets project's pgsodium config"
										r.operationID = "getPgsodiumConfig"
										r.pathPattern = "/v1/projects/{ref}/pgsodium"
										r.args = args
										r.count = 1
										return r, true
									case "PUT":
										// Leaf: UpdatePgsodiumConfig
										r.name = "UpdatePgsodiumConfig"
										r.summary = "Updates project's pgsodium config. Updating the root_key can cause all data encrypted with the older key to become inaccessible."
										r.operationID = "updatePgsodiumConfig"
										r.pathPattern = "/v1/projects/{ref}/pgsodium"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

								elem = origElem
							case 'o': // Prefix: "ostgrest"
								origElem := elem
								if l := len("ostgrest"); len(elem) >= l && elem[0:l] == "ostgrest" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: GetPostgRESTConfig
										r.name = "GetPostgRESTConfig"
										r.summary = "Gets project's postgrest config"
										r.operationID = "getPostgRESTConfig"
										r.pathPattern = "/v1/projects/{ref}/postgrest"
										r.args = args
										r.count = 1
										return r, true
									case "PATCH":
										// Leaf: UpdatePostgRESTConfig
										r.name = "UpdatePostgRESTConfig"
										r.summary = "Updates project's postgrest config"
										r.operationID = "updatePostgRESTConfig"
										r.pathPattern = "/v1/projects/{ref}/postgrest"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

								elem = origElem
							}

							elem = origElem
						case 'r': // Prefix: "read"
							origElem := elem
							if l := len("read"); len(elem) >= l && elem[0:l] == "read" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '-': // Prefix: "-replicas/"
								origElem := elem
								if l := len("-replicas/"); len(elem) >= l && elem[0:l] == "-replicas/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'r': // Prefix: "remove"
									origElem := elem
									if l := len("remove"); len(elem) >= l && elem[0:l] == "remove" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "POST":
											// Leaf: RemoveReadReplica
											r.name = "RemoveReadReplica"
											r.summary = "Remove a read replica"
											r.operationID = "removeReadReplica"
											r.pathPattern = "/v1/projects/{ref}/read-replicas/remove"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

									elem = origElem
								case 's': // Prefix: "setup"
									origElem := elem
									if l := len("setup"); len(elem) >= l && elem[0:l] == "setup" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "POST":
											// Leaf: SetUpReadReplica
											r.name = "SetUpReadReplica"
											r.summary = "Set up a read replica"
											r.operationID = "setUpReadReplica"
											r.pathPattern = "/v1/projects/{ref}/read-replicas/setup"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

									elem = origElem
								}

								elem = origElem
							case 'o': // Prefix: "only"
								origElem := elem
								if l := len("only"); len(elem) >= l && elem[0:l] == "only" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = "GetReadOnlyModeStatus"
										r.summary = "Returns project's readonly mode status"
										r.operationID = "getReadOnlyModeStatus"
										r.pathPattern = "/v1/projects/{ref}/readonly"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/temporary-disable"
									origElem := elem
									if l := len("/temporary-disable"); len(elem) >= l && elem[0:l] == "/temporary-disable" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "POST":
											// Leaf: TemporarilyDisableReadonlyMode
											r.name = "TemporarilyDisableReadonlyMode"
											r.summary = "Disables project's readonly mode for the next 15 minutes"
											r.operationID = "temporarilyDisableReadonlyMode"
											r.pathPattern = "/v1/projects/{ref}/readonly/temporary-disable"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

									elem = origElem
								}

								elem = origElem
							}

							elem = origElem
						case 's': // Prefix: "s"
							origElem := elem
							if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'e': // Prefix: "ecrets"
								origElem := elem
								if l := len("ecrets"); len(elem) >= l && elem[0:l] == "ecrets" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										// Leaf: DeleteSecrets
										r.name = "DeleteSecrets"
										r.summary = "Bulk delete secrets"
										r.operationID = "deleteSecrets"
										r.pathPattern = "/v1/projects/{ref}/secrets"
										r.args = args
										r.count = 1
										return r, true
									case "GET":
										// Leaf: GetSecrets
										r.name = "GetSecrets"
										r.summary = "List all secrets"
										r.operationID = "getSecrets"
										r.pathPattern = "/v1/projects/{ref}/secrets"
										r.args = args
										r.count = 1
										return r, true
									case "POST":
										// Leaf: CreateSecrets
										r.name = "CreateSecrets"
										r.summary = "Bulk create secrets"
										r.operationID = "createSecrets"
										r.pathPattern = "/v1/projects/{ref}/secrets"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

								elem = origElem
							case 's': // Prefix: "sl-enforcement"
								origElem := elem
								if l := len("sl-enforcement"); len(elem) >= l && elem[0:l] == "sl-enforcement" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: GetSslEnforcementConfig
										r.name = "GetSslEnforcementConfig"
										r.summary = "Get project's SSL enforcement configuration."
										r.operationID = "getSslEnforcementConfig"
										r.pathPattern = "/v1/projects/{ref}/ssl-enforcement"
										r.args = args
										r.count = 1
										return r, true
									case "PUT":
										// Leaf: UpdateSslEnforcementConfig
										r.name = "UpdateSslEnforcementConfig"
										r.summary = "Update project's SSL enforcement configuration."
										r.operationID = "updateSslEnforcementConfig"
										r.pathPattern = "/v1/projects/{ref}/ssl-enforcement"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

								elem = origElem
							case 't': // Prefix: "torage/buckets"
								origElem := elem
								if l := len("torage/buckets"); len(elem) >= l && elem[0:l] == "torage/buckets" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: GetBuckets
										r.name = "GetBuckets"
										r.summary = "Lists all buckets"
										r.operationID = "getBuckets"
										r.pathPattern = "/v1/projects/{ref}/storage/buckets"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

								elem = origElem
							}

							elem = origElem
						case 't': // Prefix: "types/typescript"
							origElem := elem
							if l := len("types/typescript"); len(elem) >= l && elem[0:l] == "types/typescript" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: GetTypescriptTypes
									r.name = "GetTypescriptTypes"
									r.summary = "Generate TypeScript types"
									r.operationID = "getTypescriptTypes"
									r.pathPattern = "/v1/projects/{ref}/types/typescript"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

							elem = origElem
						case 'u': // Prefix: "upgrade"
							origElem := elem
							if l := len("upgrade"); len(elem) >= l && elem[0:l] == "upgrade" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "POST":
									r.name = "UpgradeProject"
									r.summary = "Upgrades the project's Postgres version"
									r.operationID = "upgradeProject"
									r.pathPattern = "/v1/projects/{ref}/upgrade"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'e': // Prefix: "eligibility"
									origElem := elem
									if l := len("eligibility"); len(elem) >= l && elem[0:l] == "eligibility" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											// Leaf: UpgradeEligibilityInformation
											r.name = "UpgradeEligibilityInformation"
											r.summary = "Returns the project's eligibility for upgrades"
											r.operationID = "upgradeEligibilityInformation"
											r.pathPattern = "/v1/projects/{ref}/upgrade/eligibility"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

									elem = origElem
								case 's': // Prefix: "status"
									origElem := elem
									if l := len("status"); len(elem) >= l && elem[0:l] == "status" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											// Leaf: GetUpgradeStatus
											r.name = "GetUpgradeStatus"
											r.summary = "Gets the latest status of the project's upgrade"
											r.operationID = "getUpgradeStatus"
											r.pathPattern = "/v1/projects/{ref}/upgrade/status"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

									elem = origElem
								}

								elem = origElem
							}

							elem = origElem
						case 'v': // Prefix: "vanity-subdomain"
							origElem := elem
							if l := len("vanity-subdomain"); len(elem) >= l && elem[0:l] == "vanity-subdomain" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									r.name = "RemoveVanitySubdomainConfig"
									r.summary = "Deletes a project's vanity subdomain configuration"
									r.operationID = "removeVanitySubdomainConfig"
									r.pathPattern = "/v1/projects/{ref}/vanity-subdomain"
									r.args = args
									r.count = 1
									return r, true
								case "GET":
									r.name = "GetVanitySubdomainConfig"
									r.summary = "Gets current vanity subdomain config"
									r.operationID = "getVanitySubdomainConfig"
									r.pathPattern = "/v1/projects/{ref}/vanity-subdomain"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								origElem := elem
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "activate"
									origElem := elem
									if l := len("activate"); len(elem) >= l && elem[0:l] == "activate" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "POST":
											// Leaf: ActivateVanitySubdomainPlease
											r.name = "ActivateVanitySubdomainPlease"
											r.summary = "Activates a vanity subdomain for a project."
											r.operationID = "activateVanitySubdomainPlease"
											r.pathPattern = "/v1/projects/{ref}/vanity-subdomain/activate"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

									elem = origElem
								case 'c': // Prefix: "check-availability"
									origElem := elem
									if l := len("check-availability"); len(elem) >= l && elem[0:l] == "check-availability" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "POST":
											// Leaf: CheckVanitySubdomainAvailability
											r.name = "CheckVanitySubdomainAvailability"
											r.summary = "Checks vanity subdomain availability"
											r.operationID = "checkVanitySubdomainAvailability"
											r.pathPattern = "/v1/projects/{ref}/vanity-subdomain/check-availability"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

									elem = origElem
								}

								elem = origElem
							}

							elem = origElem
						}

						elem = origElem
					}

					elem = origElem
				}

				elem = origElem
			case 's': // Prefix: "snippets"
				origElem := elem
				if l := len("snippets"); len(elem) >= l && elem[0:l] == "snippets" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch method {
					case "GET":
						r.name = "ListSnippets"
						r.summary = "Lists SQL snippets for the logged in user"
						r.operationID = "listSnippets"
						r.pathPattern = "/v1/snippets"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					origElem := elem
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "id"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						switch method {
						case "GET":
							// Leaf: GetSnippet
							r.name = "GetSnippet"
							r.summary = "Gets a specific SQL snippet"
							r.operationID = "getSnippet"
							r.pathPattern = "/v1/snippets/{id}"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}

					elem = origElem
				}

				elem = origElem
			}

			elem = origElem
		}
	}
	return r, false
}
